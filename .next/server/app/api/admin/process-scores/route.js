"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/admin/process-scores/route";
exports.ids = ["app/api/admin/process-scores/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "http2":
/*!************************!*\
  !*** external "http2" ***!
  \************************/
/***/ ((module) => {

module.exports = require("http2");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("process");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "node:buffer":
/*!******************************!*\
  !*** external "node:buffer" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:buffer");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("node:fs");

/***/ }),

/***/ "node:http":
/*!****************************!*\
  !*** external "node:http" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:http");

/***/ }),

/***/ "node:https":
/*!*****************************!*\
  !*** external "node:https" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node:https");

/***/ }),

/***/ "node:net":
/*!***************************!*\
  !*** external "node:net" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("node:net");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:path");

/***/ }),

/***/ "node:process":
/*!*******************************!*\
  !*** external "node:process" ***!
  \*******************************/
/***/ ((module) => {

module.exports = require("node:process");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("node:stream/web");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("node:url");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:util");

/***/ }),

/***/ "node:zlib":
/*!****************************!*\
  !*** external "node:zlib" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fadmin%2Fprocess-scores%2Froute&page=%2Fapi%2Fadmin%2Fprocess-scores%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fadmin%2Fprocess-scores%2Froute.ts&appDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fadmin%2Fprocess-scores%2Froute&page=%2Fapi%2Fadmin%2Fprocess-scores%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fadmin%2Fprocess-scores%2Froute.ts&appDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_arunm_Downloads_judge_dashboard_nextjs_v29_judgePanelv1_app_api_admin_process_scores_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/admin/process-scores/route.ts */ \"(rsc)/./app/api/admin/process-scores/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/admin/process-scores/route\",\n        pathname: \"/api/admin/process-scores\",\n        filename: \"route\",\n        bundlePath: \"app/api/admin/process-scores/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\arunm\\\\Downloads\\\\judge-dashboard-nextjs-v29-judgePanelv1\\\\app\\\\api\\\\admin\\\\process-scores\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_arunm_Downloads_judge_dashboard_nextjs_v29_judgePanelv1_app_api_admin_process_scores_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/admin/process-scores/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZhZG1pbiUyRnByb2Nlc3Mtc2NvcmVzJTJGcm91dGUmcGFnZT0lMkZhcGklMkZhZG1pbiUyRnByb2Nlc3Mtc2NvcmVzJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGYWRtaW4lMkZwcm9jZXNzLXNjb3JlcyUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNhcnVubSU1Q0Rvd25sb2FkcyU1Q2p1ZGdlLWRhc2hib2FyZC1uZXh0anMtdjI5LWp1ZGdlUGFuZWx2MSU1Q2FwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9QyUzQSU1Q1VzZXJzJTVDYXJ1bm0lNUNEb3dubG9hZHMlNUNqdWRnZS1kYXNoYm9hcmQtbmV4dGpzLXYyOS1qdWRnZVBhbmVsdjEmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQytEO0FBQzVJO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8/NDY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFxhcnVubVxcXFxEb3dubG9hZHNcXFxcanVkZ2UtZGFzaGJvYXJkLW5leHRqcy12MjktanVkZ2VQYW5lbHYxXFxcXGFwcFxcXFxhcGlcXFxcYWRtaW5cXFxccHJvY2Vzcy1zY29yZXNcXFxccm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2FkbWluL3Byb2Nlc3Mtc2NvcmVzL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvYWRtaW4vcHJvY2Vzcy1zY29yZXNcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL2FkbWluL3Byb2Nlc3Mtc2NvcmVzL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiQzpcXFxcVXNlcnNcXFxcYXJ1bm1cXFxcRG93bmxvYWRzXFxcXGp1ZGdlLWRhc2hib2FyZC1uZXh0anMtdjI5LWp1ZGdlUGFuZWx2MVxcXFxhcHBcXFxcYXBpXFxcXGFkbWluXFxcXHByb2Nlc3Mtc2NvcmVzXFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9hZG1pbi9wcm9jZXNzLXNjb3Jlcy9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fadmin%2Fprocess-scores%2Froute&page=%2Fapi%2Fadmin%2Fprocess-scores%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fadmin%2Fprocess-scores%2Froute.ts&appDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/admin/process-scores/route.ts":
/*!***********************************************!*\
  !*** ./app/api/admin/process-scores/route.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_google_sheets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/google-sheets */ \"(rsc)/./lib/google-sheets.ts\");\n\n\nasync function POST(request) {\n    try {\n        const sheetsService = new _lib_google_sheets__WEBPACK_IMPORTED_MODULE_1__.GoogleSheetsService();\n        const classes = Object.keys(_lib_google_sheets__WEBPACK_IMPORTED_MODULE_1__.SPREADSHEET_CONFIG.CLASSES);\n        const allTopProjects = [];\n        for (const className of classes){\n            console.log(`Processing scores for ${className}...`);\n            await sheetsService.processClassScores(className);\n            const topProjects = await sheetsService.getTopProjects(className);\n            allTopProjects.push(...topProjects);\n        }\n        // Sort all top projects by standard and then by rank\n        allTopProjects.sort((a, b)=>{\n            if (a.standard < b.standard) return -1;\n            if (a.standard > b.standard) return 1;\n            return a.rank - b.rank;\n        });\n        await sheetsService.updateAdminSummary(allTopProjects);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: \"Scores and top projects updated for all standards.\",\n            timestamp: new Date().toISOString()\n        });\n    } catch (error) {\n        console.error(\"Error processing all scores:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message || \"Failed to process all scores.\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2FkbWluL3Byb2Nlc3Mtc2NvcmVzL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQztBQUNtQztBQUd2RSxlQUFlRyxLQUFLQyxPQUFnQjtJQUN6QyxJQUFJO1FBQ0YsTUFBTUMsZ0JBQWdCLElBQUlKLG1FQUFtQkE7UUFDN0MsTUFBTUssVUFBVUMsT0FBT0MsSUFBSSxDQUFDTixrRUFBa0JBLENBQUNPLE9BQU87UUFDdEQsTUFBTUMsaUJBQXNDLEVBQUU7UUFFOUMsS0FBSyxNQUFNQyxhQUFhTCxRQUFTO1lBQy9CTSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxzQkFBc0IsRUFBRUYsVUFBVSxHQUFHLENBQUM7WUFDbkQsTUFBTU4sY0FBY1Msa0JBQWtCLENBQUNIO1lBQ3ZDLE1BQU1JLGNBQWMsTUFBTVYsY0FBY1csY0FBYyxDQUFDTDtZQUN2REQsZUFBZU8sSUFBSSxJQUFJRjtRQUN6QjtRQUVBLHFEQUFxRDtRQUNyREwsZUFBZVEsSUFBSSxDQUFDLENBQUNDLEdBQUdDO1lBQ3RCLElBQUlELEVBQUVFLFFBQVEsR0FBR0QsRUFBRUMsUUFBUSxFQUFFLE9BQU8sQ0FBQztZQUNyQyxJQUFJRixFQUFFRSxRQUFRLEdBQUdELEVBQUVDLFFBQVEsRUFBRSxPQUFPO1lBQ3BDLE9BQU9GLEVBQUVHLElBQUksR0FBR0YsRUFBRUUsSUFBSTtRQUN4QjtRQUVBLE1BQU1qQixjQUFja0Isa0JBQWtCLENBQUNiO1FBRXZDLE9BQU9WLHFEQUFZQSxDQUFDd0IsSUFBSSxDQUFDO1lBQ3ZCQyxTQUFTO1lBQ1RDLFNBQVM7WUFDVEMsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1FBQ25DO0lBQ0YsRUFBRSxPQUFPQyxPQUFZO1FBQ25CbEIsUUFBUWtCLEtBQUssQ0FBQyxnQ0FBZ0NBO1FBQzlDLE9BQU85QixxREFBWUEsQ0FBQ3dCLElBQUksQ0FDdEI7WUFDRUMsU0FBUztZQUNUSyxPQUFPQSxNQUFNSixPQUFPLElBQUk7UUFDMUIsR0FDQTtZQUFFSyxRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9hcHAvYXBpL2FkbWluL3Byb2Nlc3Mtc2NvcmVzL3JvdXRlLnRzPzg3YjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvc2VydmVyXCI7XG5pbXBvcnQgeyBHb29nbGVTaGVldHNTZXJ2aWNlLCBTUFJFQURTSEVFVF9DT05GSUcgfSBmcm9tIFwiQC9saWIvZ29vZ2xlLXNoZWV0c1wiO1xuaW1wb3J0IHsgdHlwZSBUb3BQcm9qZWN0U3VtbWFyeSB9IGZyb20gXCJAL2FwcC9hZG1pbi1kYXNoYm9hcmQvcGFnZVwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2hlZXRzU2VydmljZSA9IG5ldyBHb29nbGVTaGVldHNTZXJ2aWNlKCk7XG4gICAgY29uc3QgY2xhc3NlcyA9IE9iamVjdC5rZXlzKFNQUkVBRFNIRUVUX0NPTkZJRy5DTEFTU0VTKTtcbiAgICBjb25zdCBhbGxUb3BQcm9qZWN0czogVG9wUHJvamVjdFN1bW1hcnlbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3Nlcykge1xuICAgICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgc2NvcmVzIGZvciAke2NsYXNzTmFtZX0uLi5gKTtcbiAgICAgIGF3YWl0IHNoZWV0c1NlcnZpY2UucHJvY2Vzc0NsYXNzU2NvcmVzKGNsYXNzTmFtZSk7XG4gICAgICBjb25zdCB0b3BQcm9qZWN0cyA9IGF3YWl0IHNoZWV0c1NlcnZpY2UuZ2V0VG9wUHJvamVjdHMoY2xhc3NOYW1lKTtcbiAgICAgIGFsbFRvcFByb2plY3RzLnB1c2goLi4udG9wUHJvamVjdHMpO1xuICAgIH1cblxuICAgIC8vIFNvcnQgYWxsIHRvcCBwcm9qZWN0cyBieSBzdGFuZGFyZCBhbmQgdGhlbiBieSByYW5rXG4gICAgYWxsVG9wUHJvamVjdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEuc3RhbmRhcmQgPCBiLnN0YW5kYXJkKSByZXR1cm4gLTE7XG4gICAgICBpZiAoYS5zdGFuZGFyZCA+IGIuc3RhbmRhcmQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIGEucmFuayAtIGIucmFuaztcbiAgICB9KTtcblxuICAgIGF3YWl0IHNoZWV0c1NlcnZpY2UudXBkYXRlQWRtaW5TdW1tYXJ5KGFsbFRvcFByb2plY3RzKTtcblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgbWVzc2FnZTogXCJTY29yZXMgYW5kIHRvcCBwcm9qZWN0cyB1cGRhdGVkIGZvciBhbGwgc3RhbmRhcmRzLlwiLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJvY2Vzc2luZyBhbGwgc2NvcmVzOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gcHJvY2VzcyBhbGwgc2NvcmVzLlwiLFxuICAgICAgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfSxcbiAgICApO1xuICB9XG59XG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiR29vZ2xlU2hlZXRzU2VydmljZSIsIlNQUkVBRFNIRUVUX0NPTkZJRyIsIlBPU1QiLCJyZXF1ZXN0Iiwic2hlZXRzU2VydmljZSIsImNsYXNzZXMiLCJPYmplY3QiLCJrZXlzIiwiQ0xBU1NFUyIsImFsbFRvcFByb2plY3RzIiwiY2xhc3NOYW1lIiwiY29uc29sZSIsImxvZyIsInByb2Nlc3NDbGFzc1Njb3JlcyIsInRvcFByb2plY3RzIiwiZ2V0VG9wUHJvamVjdHMiLCJwdXNoIiwic29ydCIsImEiLCJiIiwic3RhbmRhcmQiLCJyYW5rIiwidXBkYXRlQWRtaW5TdW1tYXJ5IiwianNvbiIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZXJyb3IiLCJzdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/api/admin/process-scores/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/google-sheets.ts":
/*!******************************!*\
  !*** ./lib/google-sheets.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GOOGLE_SHEETS_CONFIG: () => (/* binding */ GOOGLE_SHEETS_CONFIG),\n/* harmony export */   GoogleSheetsService: () => (/* binding */ GoogleSheetsService),\n/* harmony export */   SPREADSHEET_CONFIG: () => (/* binding */ SPREADSHEET_CONFIG),\n/* harmony export */   googleSheetsService: () => (/* binding */ googleSheetsService)\n/* harmony export */ });\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var googleapis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! googleapis */ \"(rsc)/./node_modules/googleapis/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nconst CLASS_SHEET_IDS_PATH = path__WEBPACK_IMPORTED_MODULE_2__.resolve(process.cwd(), \"config/class-sheet-ids.json\");\nfunction loadClassSheetIds() {\n    try {\n        const raw = fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(CLASS_SHEET_IDS_PATH, \"utf-8\");\n        return JSON.parse(raw);\n    } catch  {\n        return {};\n    }\n}\nfunction saveClassSheetIds(ids) {\n    fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(CLASS_SHEET_IDS_PATH, JSON.stringify(ids, null, 2), \"utf-8\");\n}\n// Configuration for Google Sheets API\nconst GOOGLE_SHEETS_CONFIG = {\n    serviceAccountKeyPath: process.env.GOOGLE_SERVICE_ACCOUNT_KEY_PATH || \"./config/service-account-key.json\",\n    scopes: [\n        \"https://www.googleapis.com/auth/spreadsheets\"\n    ]\n};\n// Spreadsheet configurations - changed to 'let' to allow dynamic updates for demonstration\nconst persistedIds = loadClassSheetIds();\nlet SPREADSHEET_CONFIG = {\n    CREDENTIALS: {\n        id: process.env.CREDENTIALS_SPREADSHEET_ID || \"1snk-FZaxyZbSu_Ww-oPnam8JxZ2RLg3etI5TBkr-T1A\",\n        range: \"Sheet1!A:C\"\n    },\n    ADMIN_MASTER: {\n        id: process.env.ADMIN_MASTER_SPREADSHEET_ID || \"1snk-FZaxyZbSu_Ww-oPnam8JxZ2RLg3etI5TBkr-T1A\"\n    },\n    CLASSES: {\n        \"Class 4\": {\n            id: persistedIds[\"Class 4\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 5\": {\n            id: persistedIds[\"Class 5\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 6\": {\n            id: persistedIds[\"Class 6\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 7\": {\n            id: persistedIds[\"Class 7\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 8\": {\n            id: persistedIds[\"Class 8\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 9\": {\n            id: persistedIds[\"Class 9\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 10\": {\n            id: persistedIds[\"Class 10\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 11\": {\n            id: persistedIds[\"Class 11\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 12\": {\n            id: persistedIds[\"Class 12\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        }\n    }\n};\nclass GoogleSheetsService {\n    constructor(){\n        // Handle both file path and base64 encoded key for deployment\n        if (process.env.GOOGLE_SERVICE_ACCOUNT_KEY_BASE64) {\n            const keyData = Buffer.from(process.env.GOOGLE_SERVICE_ACCOUNT_KEY_BASE64, \"base64\").toString(\"utf8\");\n            const keyPath = \"/tmp/service-account-key.json\" // Vercel /tmp directory is writable\n            ;\n            fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(keyPath, keyData);\n            this.auth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth({\n                keyFile: keyPath,\n                scopes: GOOGLE_SHEETS_CONFIG.scopes\n            });\n        } else {\n            this.auth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth({\n                keyFile: GOOGLE_SHEETS_CONFIG.serviceAccountKeyPath,\n                scopes: GOOGLE_SHEETS_CONFIG.scopes\n            });\n        }\n        this.sheets = googleapis__WEBPACK_IMPORTED_MODULE_3__.google.sheets({\n            version: \"v4\",\n            auth: this.auth\n        });\n    }\n    async getSheetData(spreadsheetId, range) {\n        try {\n            console.log(`ðŸ”— Fetching data from Google Sheets: ${spreadsheetId}, Range: ${range}`);\n            const response = await this.sheets.spreadsheets.values.get({\n                spreadsheetId,\n                range\n            });\n            return {\n                values: response.data.values || [],\n                range,\n                spreadsheetId\n            };\n        } catch (error) {\n            console.error(\"Error fetching sheet data:\", error);\n            throw new Error(`Failed to fetch data from spreadsheet ${spreadsheetId}. Please check permissions and spreadsheet ID.`);\n        }\n    }\n    async batchGetSheetData(spreadsheetId, ranges) {\n        try {\n            const response = await this.sheets.spreadsheets.values.batchGet({\n                spreadsheetId,\n                ranges\n            });\n            const result = {};\n            (response.data.valueRanges || []).forEach((valueRange)=>{\n                result[valueRange.range] = valueRange.values || [];\n            });\n            return result;\n        } catch (error) {\n            console.error(\"Error in batchGetSheetData:\", error);\n            throw new Error(`Failed to batch get data from spreadsheet ${spreadsheetId}.`);\n        }\n    }\n    async getCredentials() {\n        try {\n            const data = await this.getSheetData(SPREADSHEET_CONFIG.CREDENTIALS.id, SPREADSHEET_CONFIG.CREDENTIALS.range);\n            if (!data.values || data.values.length === 0) {\n                throw new Error(\"No credentials found in the spreadsheet\");\n            }\n            // Skip header row and map to credential objects\n            return data.values.slice(1).map((row)=>({\n                    username: row[0] || \"\",\n                    password: row[1] || \"\",\n                    role: row[2] || \"\"\n                })).filter((cred)=>cred.username && cred.password && cred.role);\n        } catch (error) {\n            console.error(\"Error fetching credentials:\", error);\n            throw new Error(\"Failed to fetch credentials from Google Sheets\");\n        }\n    }\n    async getProjectIds(className) {\n        try {\n            const classConfig = this.getClassConfig(className);\n            if (!classConfig) {\n                throw new Error(`No configuration found for class: ${className}`);\n            }\n            const data = await this.getSheetData(classConfig.id, classConfig.range);\n            if (!data.values || data.values.length === 0) {\n                return [];\n            }\n            // Skip header row and extract Project IDs from column E (index 4)\n            const projectIds = data.values.slice(1) // Skip header row\n            .map((row)=>row[4]) // Column E (Project ID) is at index 4\n            .filter((id)=>id && id.trim() !== \"\") // Remove empty cells\n            .map((id)=>id.trim()) // Clean whitespace\n            ;\n            // Return unique project IDs only\n            return [\n                ...new Set(projectIds)\n            ];\n        } catch (error) {\n            console.error(`Error fetching project IDs for ${className}:`, error);\n            throw new Error(`Failed to fetch project IDs for ${className} from Google Sheets`);\n        }\n    }\n    async getStudentsByProjectId(className, projectId) {\n        try {\n            const classConfig = this.getClassConfig(className);\n            if (!classConfig) {\n                throw new Error(`No configuration found for class: ${className}`);\n            }\n            const data = await this.getSheetData(classConfig.id, classConfig.range);\n            if (!data.values || data.values.length === 0) {\n                return [];\n            }\n            // Skip header row and filter by Project ID\n            const students = data.values.slice(1) // Skip header row\n            .filter((row)=>row[4] && row[4].trim() === projectId.trim()) // Filter by Project ID\n            .map((row)=>({\n                    sno: row[0] || \"\",\n                    studentName: row[1] || \"\",\n                    grade: row[2] || \"\",\n                    projectTitle: row[3] || \"\",\n                    projectId: row[4] || \"\",\n                    theme: row[5] || \"\"\n                })).filter((student)=>student.studentName && student.projectId);\n            return students;\n        } catch (error) {\n            console.error(`Error fetching students for project ${projectId}:`, error);\n            throw new Error(`Failed to fetch students for project ${projectId} from Google Sheets`);\n        }\n    }\n    async getJudgeScores(className, judgeName, projectId) {\n        try {\n            const classConfig = this.getClassConfig(className);\n            if (!classConfig) {\n                throw new Error(`No configuration found for class: ${className}`);\n            }\n            const judgeSheetName = `Judge_${judgeName}`;\n            const judgeRange = `${judgeSheetName}!A:K` // Updated range to include Theme Fit (assuming column K)\n            ;\n            try {\n                const data = await this.getSheetData(classConfig.id, judgeRange);\n                if (!data.values || data.values.length === 0) {\n                    return [];\n                }\n                // Skip header row and optionally filter by Project ID\n                let scores = data.values.slice(1) // Skip header row\n                .map((row)=>({\n                        sno: row[0] || \"\",\n                        studentName: row[1] || \"\",\n                        grade: row[2] || \"\",\n                        projectTitle: row[3] || \"\",\n                        projectId: row[4] || \"\",\n                        creativity: row[5] ? Number.parseFloat(row[5]) : null,\n                        scientificThought: row[6] ? Number.parseFloat(row[6]) : null,\n                        technicalSkills: row[7] ? Number.parseFloat(row[7]) : null,\n                        presentation: row[8] ? Number.parseFloat(row[8]) : null,\n                        status: row[9] || \"Present\",\n                        themeFit: row[10] || null\n                    }));\n                console.log(`ðŸ”— Fetched ${scores.length} scores from ${judgeSheetName} for class ${className}`);\n                // Filter by project ID if specified\n                if (projectId) {\n                    scores = scores.filter((score)=>score.projectId.trim() === projectId.trim());\n                }\n                return scores;\n            } catch (error) {\n                // Judge sheet doesn't exist yet or is empty, which is fine for initial fetch\n                console.log(`Judge sheet ${judgeSheetName} doesn't exist yet or is empty.`);\n                return [];\n            }\n        } catch (error) {\n            console.error(`Error fetching judge scores:`, error);\n            throw new Error(`Failed to fetch judge scores from Google Sheets`);\n        }\n    }\n    async saveJudgeScores(className, judgeName, scores) {\n        try {\n            const classConfig = this.getClassConfig(className);\n            if (!classConfig) {\n                throw new Error(`No configuration found for class: ${className}`);\n            }\n            const judgeSheetName = `Judge_${judgeName}`;\n            const judgeHeaderRow = [\n                \"S.No.\",\n                \"Name of the Student\",\n                \"Grade\",\n                \"Project Title\",\n                \"Project ID\",\n                \"Creativity & Imagination\",\n                \"Scientific Thought\",\n                \"Technical Skills\",\n                \"Presentation\",\n                \"Status\",\n                \"Theme Fit\"\n            ];\n            // Ensure judge sheet exists and has header\n            await this.ensureSheetExists(classConfig.id, judgeSheetName, judgeHeaderRow);\n            // Prepare new score rows for appending\n            const newRows = scores.map((score)=>[\n                    score.sno,\n                    score.studentName,\n                    score.grade,\n                    score.projectTitle,\n                    score.projectId,\n                    score.creativity?.toString() || \"\",\n                    score.scientificThought?.toString() || \"\",\n                    score.technicalSkills?.toString() || \"\",\n                    score.presentation?.toString() || \"\",\n                    score.status || \"Present\",\n                    score.themeFit || \"\"\n                ]);\n            // Append new scores (never overwrite)\n            await this.sheets.spreadsheets.values.append({\n                spreadsheetId: classConfig.id,\n                range: `${judgeSheetName}!A:K`,\n                valueInputOption: \"USER_ENTERED\",\n                resource: {\n                    values: newRows\n                }\n            });\n            console.log(`âœ… Appended ${newRows.length} new score rows to ${judgeSheetName}`);\n        } catch (error) {\n            console.error(`Error appending judge scores:`, error);\n            throw new Error(`Failed to append judge scores to Google Sheets`);\n        }\n    }\n    async getExistingJudgeData(spreadsheetId, sheetName) {\n        try {\n            const response = await this.sheets.spreadsheets.values.get({\n                spreadsheetId,\n                range: `${sheetName}!A:K`\n            });\n            return response.data.values || [];\n        } catch (error) {\n            // Sheet doesn't exist or is empty\n            return [];\n        }\n    }\n    async ensureSheetExists(spreadsheetId, sheetName, headerRow) {\n        try {\n            const spreadsheet = await this.sheets.spreadsheets.get({\n                spreadsheetId: spreadsheetId,\n                fields: \"sheets.properties.title,sheets.properties.sheetId\"\n            });\n            const sheetExists = spreadsheet.data.sheets?.some((sheet)=>sheet.properties.title === sheetName);\n            if (!sheetExists) {\n                await this.sheets.spreadsheets.batchUpdate({\n                    spreadsheetId: spreadsheetId,\n                    resource: {\n                        requests: [\n                            {\n                                addSheet: {\n                                    properties: {\n                                        title: sheetName\n                                    }\n                                }\n                            }\n                        ]\n                    }\n                });\n                console.log(`âœ… Created new sheet: ${sheetName} in spreadsheet ${spreadsheetId}`);\n                // If header row is provided, write it\n                if (headerRow && headerRow.length > 0) {\n                    await this.sheets.spreadsheets.values.append({\n                        spreadsheetId: spreadsheetId,\n                        range: `${sheetName}!A1`,\n                        valueInputOption: \"USER_ENTERED\",\n                        resource: {\n                            values: [\n                                headerRow\n                            ]\n                        }\n                    });\n                    console.log(`âœ… Added header to new sheet: ${sheetName}`);\n                }\n            }\n        } catch (error) {\n            console.error(`Error ensuring sheet ${sheetName} exists in ${spreadsheetId}:`, error);\n            throw new Error(`Failed to create or verify sheet: ${sheetName}`);\n        }\n    }\n    async getAllSheetTitles(spreadsheetId) {\n        try {\n            const response = await this.sheets.spreadsheets.get({\n                spreadsheetId: spreadsheetId,\n                fields: \"sheets.properties.title\"\n            });\n            return response.data.sheets?.map((sheet)=>sheet.properties.title) || [];\n        } catch (error) {\n            console.error(`Error fetching sheet titles for ${spreadsheetId}:`, error);\n            throw new Error(`Failed to fetch sheet titles for spreadsheet ${spreadsheetId}.`);\n        }\n    }\n    async getAllJudgeSheetNames(classSpreadsheetId) {\n        const allSheetTitles = await this.getAllSheetTitles(classSpreadsheetId);\n        return allSheetTitles.filter((title)=>title.startsWith(\"Judge_\"));\n    }\n    async getProjectDetailsMap(className) {\n        const classConfig = this.getClassConfig(className);\n        if (!classConfig) {\n            throw new Error(`No configuration found for class: ${className}`);\n        }\n        const data = await this.getSheetData(classConfig.id, classConfig.range) // Reads Sheet1!A:F\n        ;\n        const projectMap = new Map();\n        if (data.values && data.values.length > 1) {\n            // Skip header\n            data.values.slice(1).forEach((row)=>{\n                const projectId = row[4]?.trim() // Column E\n                ;\n                const projectTitle = row[3]?.trim() // Column D\n                ;\n                const theme = row[5]?.trim() // Column F\n                ;\n                const studentName = row[1]?.trim() // Column B\n                ;\n                if (projectId) {\n                    if (!projectMap.has(projectId)) {\n                        projectMap.set(projectId, {\n                            title: projectTitle || \"\",\n                            theme: theme || \"\",\n                            studentNames: new Set()\n                        });\n                    }\n                    if (studentName) {\n                        projectMap.get(projectId)?.studentNames.add(studentName);\n                    }\n                }\n            });\n        }\n        return projectMap;\n    }\n    async processClassScores(className) {\n        const classConfig = this.getClassConfig(className);\n        if (!classConfig) {\n            throw new Error(`No configuration found for class: ${className}`);\n        }\n        const classSpreadsheetId = classConfig.id;\n        const projectDetailsMap = await this.getProjectDetailsMap(className);\n        console.log(`[${className}] Found ${projectDetailsMap.size} unique projects from BaseSheet.`);\n        const judgeSheetNames = await this.getAllJudgeSheetNames(classSpreadsheetId);\n        console.log(`[${className}] Found ${judgeSheetNames.length} judge sheets.`);\n        // Map to store the latest score for each project by each judge\n        const latestProjectScoresByJudge = new Map() // projectId -> (judgeName -> latestScore)\n        ;\n        const judgeRanges = judgeSheetNames.map((judgeSheetName)=>`${judgeSheetName}!A:K`);\n        console.log(\"judgeRangeMAddy\");\n        console.log(`[${className}] Fetching data for judgeRangeMAddy sheets: ${judgeRanges}`);\n        const batchData = await this.batchGetSheetData(classSpreadsheetId, judgeRanges);\n        console.log(\"batchData:\", JSON.stringify(batchData, null, 2));\n        console.log(`[${className}] FetchedMaddy data for ${judgeRanges.length} ${judgeRanges} ${batchData} judge sheets in batch.`);\n        for (const judgeSheetName of judgeSheetNames){\n            console.log(`[${className}] Processing judge sheet maddy: ${judgeSheetName}`);\n            const judgeName = judgeSheetName.replace(\"Judge_\", \"\");\n            const values = batchData[`${judgeSheetName}!A1:K1000`] || [];\n            console.log(`[${className}] FoundMAddys ${values.length} rows in sheet ${judgeSheetName} for Judge ${judgeName}.`);\n            if (values.length <= 1) continue; // skip if only header or empty\n            // Parse scores as in getJudgeScores\n            const scoresForJudge = values.slice(1).map((row)=>({\n                    sno: row[0] || \"\",\n                    studentName: row[1] || \"\",\n                    grade: row[2] || \"\",\n                    projectTitle: row[3] || \"\",\n                    projectId: row[4] || \"\",\n                    creativity: row[5] ? Number.parseFloat(row[5]) : null,\n                    scientificThought: row[6] ? Number.parseFloat(row[6]) : null,\n                    technicalSkills: row[7] ? Number.parseFloat(row[7]) : null,\n                    presentation: row[8] ? Number.parseFloat(row[8]) : null,\n                    status: row[9] || \"Present\",\n                    themeFit: row[10] || null\n                }));\n            console.log(`[${className}] FoundMaddy ${scoresForJudge.length} scores for Judge ${judgeName} in sheet ${judgeSheetName}.`);\n            for (const score of scoresForJudge){\n                const pId = score.projectId.trim();\n                console.log(`[${className}] Processing score for Project ${pId} by Judge ${judgeName}:`, score);\n                if (!latestProjectScoresByJudge.has(pId)) {\n                    latestProjectScoresByJudge.set(pId, new Map());\n                }\n                latestProjectScoresByJudge.get(pId)?.set(judgeName, score);\n            }\n        }\n        console.log(`[${className}] Collected latest scores for projects from each judge.`);\n        console.log(`[${className}] latestProjectScoresByJudge for a sample project (e.g., P4001):`, latestProjectScoresByJudge.get(\"P4001\"));\n        // Aggregate scores per project\n        const projectAggregatedScores = {};\n        // Initialize projectAggregatedScores with details from BaseSheet\n        for (const [pId, details] of projectDetailsMap.entries()){\n            projectAggregatedScores[pId] = {\n                projectTitle: details.title,\n                theme: details.theme,\n                creativitySum: 0,\n                scientificThoughtSum: 0,\n                technicalSkillsSum: 0,\n                presentationSum: 0,\n                judgeCount: 0,\n                absentCount: 0,\n                studentNames: Array.from(details.studentNames).sort()\n            };\n        }\n        // Populate aggregated scores from judge submissions\n        for (const [pId, judgeScoresMap] of latestProjectScoresByJudge.entries()){\n            console.log(`[${className}] Processing scores for Project ${pId} from judges:`, Array.from(judgeScoresMap.keys()));\n            console.log(`[${className}] judgeScoresMap for Project ${pId} has ${judgeScoresMap.size} entries.`);\n            if (!projectAggregatedScores[pId]) {\n                // This project was scored but not found in BaseSheet (e.g., if BaseSheet is incomplete)\n                // Try to get details from the first score entry for this project\n                const firstScore = Array.from(judgeScoresMap.values())[0];\n                projectAggregatedScores[pId] = {\n                    projectTitle: firstScore?.projectTitle || \"\",\n                    theme: projectDetailsMap.get(pId)?.theme || \"\",\n                    creativitySum: 0,\n                    scientificThoughtSum: 0,\n                    technicalSkillsSum: 0,\n                    presentationSum: 0,\n                    judgeCount: 0,\n                    absentCount: 0,\n                    studentNames: []\n                };\n                console.warn(`[${className}] Project ${pId} found in judge sheets but not in BaseSheet. Student names might be incomplete.`);\n            }\n            for (const [judgeName, score] of judgeScoresMap.entries()){\n                if (score.status === \"Absent\") {\n                    console.log(`[${className}] Judge ${judgeName} marked Project ${pId} as Absent.`);\n                    projectAggregatedScores[pId].absentCount++;\n                } else {\n                    // Present\n                    console.log(`[${className}] Adding score for Project ${pId} by Judge ${judgeName}: Creativity=${score.creativity}, ScientificThought=${score.scientificThought}, TechnicalSkills=${score.technicalSkills}, Presentation=${score.presentation}`);\n                    projectAggregatedScores[pId].judgeCount++;\n                    projectAggregatedScores[pId].creativitySum += score.creativity || 0;\n                    projectAggregatedScores[pId].scientificThoughtSum += score.scientificThought || 0;\n                    projectAggregatedScores[pId].technicalSkillsSum += score.technicalSkills || 0;\n                    projectAggregatedScores[pId].presentationSum += score.presentation || 0;\n                }\n            }\n        }\n        console.log(`[${className}] Aggregation complete for project scores.`);\n        console.log(`[${className}] projectAggregatedScores for a sample project (e.g., P4001):`, projectAggregatedScores[\"P4001\"]);\n        // Calculate project averages and prepare rows for \"Score\" tab\n        const scoreTabRows = [];\n        scoreTabRows.push([\n            \"Project ID\",\n            \"Project Title\",\n            \"Theme\",\n            \"Avg Creativity\",\n            \"Avg Scientific Thought\",\n            \"Avg Technical Skills\",\n            \"Avg Presentation\",\n            \"Project Average Score\",\n            \"Student Names\"\n        ]) // New Header for Score tab\n        ;\n        const projectsForScoreTab = [];\n        for(const pId in projectAggregatedScores){\n            const projectData = projectAggregatedScores[pId];\n            let avgCreativity = 0;\n            let avgScientificThought = 0;\n            let avgTechnicalSkills = 0;\n            let avgPresentation = 0;\n            let projectAvgScore = 0;\n            if (projectData.judgeCount > 0) {\n                avgCreativity = projectData.creativitySum / projectData.judgeCount;\n                avgScientificThought = projectData.scientificThoughtSum / projectData.judgeCount;\n                avgTechnicalSkills = projectData.technicalSkillsSum / projectData.judgeCount;\n                avgPresentation = projectData.presentationSum / projectData.judgeCount;\n                projectAvgScore = (avgCreativity + avgScientificThought + avgTechnicalSkills + avgPresentation) / 4;\n            } else if (projectData.absentCount > 0 && projectData.judgeCount === 0) {\n                // All judges marked project absent, so all scores are 0\n                avgCreativity = 0;\n                avgScientificThought = 0;\n                avgTechnicalSkills = 0;\n                avgPresentation = 0;\n                projectAvgScore = 0;\n            }\n            // If no judges scored the project (judgeCount and absentCount are 0), all averages remain 0 (initialized)\n            projectsForScoreTab.push({\n                projectId: pId,\n                projectTitle: projectData.projectTitle,\n                theme: projectData.theme,\n                avgCreativity: avgCreativity,\n                avgScientificThought: avgScientificThought,\n                avgTechnicalSkills: avgTechnicalSkills,\n                avgPresentation: avgPresentation,\n                projectAvgScore: projectAvgScore,\n                studentNames: projectData.studentNames.join(\", \")\n            });\n        }\n        // Sort projects for the Score tab by Project ID for consistent ordering\n        projectsForScoreTab.sort((a, b)=>a.projectId.localeCompare(b.projectId));\n        projectsForScoreTab.forEach((project)=>{\n            scoreTabRows.push([\n                project.projectId,\n                project.projectTitle,\n                project.theme,\n                project.avgCreativity.toFixed(2),\n                project.avgScientificThought.toFixed(2),\n                project.avgTechnicalSkills.toFixed(2),\n                project.avgPresentation.toFixed(2),\n                project.projectAvgScore.toFixed(2),\n                project.studentNames\n            ]);\n        });\n        console.log(`[${className}] Prepared ${scoreTabRows.length - 1} rows for \"Score\" tab (excluding header).`);\n        console.log(`[${className}] Final scoreTabRows before writing:`, scoreTabRows);\n        const scoreSheetName = \"Score\";\n        await this.ensureSheetExists(classSpreadsheetId, scoreSheetName, scoreTabRows[0]) // Pass header for creation\n        ;\n        // Clear existing content before writing new data (excluding header)\n        await this.sheets.spreadsheets.values.clear({\n            spreadsheetId: classSpreadsheetId,\n            range: `${scoreSheetName}!A2:I`\n        });\n        // Write new data (including header)\n        if (scoreTabRows.length > 1) {\n            // Only update if there's data beyond the header\n            await this.sheets.spreadsheets.values.update({\n                spreadsheetId: classSpreadsheetId,\n                range: `${scoreSheetName}!A1`,\n                valueInputOption: \"USER_ENTERED\",\n                resource: {\n                    values: scoreTabRows\n                }\n            });\n            console.log(`âœ… Updated \"Score\" tab for ${className} with ${scoreTabRows.length - 1} project average entries.`);\n        } else {\n            console.log(`[${className}] No project average scores to write to \"Score\" tab.`);\n        }\n    }\n    async getTopProjects(className) {\n        const classConfig = this.getClassConfig(className);\n        if (!classConfig) {\n            throw new Error(`No configuration found for class: ${className}`);\n        }\n        const scoreSheetName = \"Score\";\n        const scoreRange = `${scoreSheetName}!A:I` // Updated range for new Score tab columns\n        ;\n        try {\n            const data = await this.getSheetData(classConfig.id, scoreRange);\n            console.log(`[${className}] Read \"Score\" tab for top projects. Rows fetched: ${data.values.length}.`);\n            if (!data.values || data.values.length <= 1) {\n                // No data or only header\n                console.log(`[${className}] \"Score\" tab is empty or only has header. No projects to rank.`);\n                return [];\n            }\n            const projects = [];\n            data.values.slice(1).forEach((row)=>{\n                const projectId = row[0]?.trim() // Project ID is now column A\n                ;\n                const projectTitle = row[1]?.trim() // Project Title is now column B\n                ;\n                const theme = row[2]?.trim() // Theme is now column C\n                ;\n                const projectAvgScore = Number.parseFloat(row[7]) || 0 // Project Average Score is now column H (index 7)\n                ;\n                const studentNames = row[8]?.trim() || \"\" // Student Names is now column I (index 8)\n                ;\n                if (projectId) {\n                    projects.push({\n                        projectId: projectId,\n                        projectTitle: projectTitle,\n                        theme: theme,\n                        projectAvgScore: projectAvgScore,\n                        studentNames: studentNames\n                    });\n                } else {\n                    console.warn(`[${className}] Skipping row in \"Score\" tab for top projects due to missing Project ID: ${row.join(\", \")}`);\n                }\n            });\n            console.log(`[${className}] Parsed ${projects.length} projects from \"Score\" tab.`);\n            // Sort by project average score descending\n            projects.sort((a, b)=>b.projectAvgScore - a.projectAvgScore);\n            console.log(`[${className}] Projects sorted by average score.`);\n            const topProjects = [];\n            let currentRank = 1;\n            let projectsAdded = 0;\n            for(let i = 0; i < projects.length; i++){\n                const project = projects[i];\n                if (projectsAdded < 3) {\n                    topProjects.push({\n                        ...project,\n                        standard: className,\n                        rank: currentRank\n                    });\n                    projectsAdded++;\n                } else if (project.projectAvgScore === topProjects[topProjects.length - 1].projectAvgScore) {\n                    // Handle ties for 3rd place\n                    topProjects.push({\n                        ...project,\n                        standard: className,\n                        rank: currentRank\n                    });\n                } else {\n                    break; // Stop after top 3 (and ties)\n                }\n                // Update rank for next distinct score, only if current project's score is different from the last added project's score\n                if (i < projects.length - 1 && projects[i + 1].projectAvgScore < project.projectAvgScore) {\n                    currentRank = topProjects.length + 1;\n                }\n            }\n            console.log(`[${className}] Identified ${topProjects.length} top projects.`);\n            return topProjects;\n        } catch (error) {\n            console.error(`Error getting top projects for ${className}:`, error);\n            throw new Error(`Failed to get top projects for ${className}.`);\n        }\n    }\n    async updateAdminSummary(summaryData) {\n        const adminMasterSheetId = SPREADSHEET_CONFIG.ADMIN_MASTER.id;\n        const summarySheetName = \"Summary\";\n        const summaryHeader = [\n            \"Standard\",\n            \"Rank\",\n            \"Project ID\",\n            \"Project Title\",\n            \"Theme\",\n            \"Project Avg Score\",\n            \"Student Names\"\n        ] // Added Student Names\n        ;\n        await this.ensureSheetExists(adminMasterSheetId, summarySheetName, summaryHeader);\n        // Clear existing content in Summary tab (excluding header)\n        await this.sheets.spreadsheets.values.clear({\n            spreadsheetId: adminMasterSheetId,\n            range: `${summarySheetName}!A2:G`\n        });\n        if (summaryData.length === 0) {\n            console.log(\"No summary data to append to Admin Master Sheet.\");\n            return;\n        }\n        const rowsToAppend = summaryData.map((data)=>[\n                data.standard,\n                data.rank.toString(),\n                data.projectId,\n                data.projectTitle,\n                data.theme,\n                data.projectAvgScore.toFixed(2),\n                data.studentNames\n            ]);\n        await this.sheets.spreadsheets.values.append({\n            spreadsheetId: adminMasterSheetId,\n            range: `${summarySheetName}!A2`,\n            valueInputOption: \"USER_ENTERED\",\n            resource: {\n                values: rowsToAppend\n            }\n        });\n        console.log(`âœ… Appended ${rowsToAppend.length} rows to \"Summary\" tab in Admin Master Sheet.`);\n    }\n    getClassConfig(className) {\n        return SPREADSHEET_CONFIG.CLASSES[className];\n    }\n    getSpreadsheetId(className) {\n        const classConfig = this.getClassConfig(className);\n        return classConfig?.id || \"\";\n    }\n    // New function to update a class's spreadsheet ID\n    updateClassSpreadsheetId(className, newId) {\n        if (SPREADSHEET_CONFIG.CLASSES[className]) {\n            // Update in-memory config\n            SPREADSHEET_CONFIG = {\n                ...SPREADSHEET_CONFIG,\n                CLASSES: {\n                    ...SPREADSHEET_CONFIG.CLASSES,\n                    [className]: {\n                        ...SPREADSHEET_CONFIG.CLASSES[className],\n                        id: newId\n                    }\n                }\n            };\n            // Persist to file\n            const ids = loadClassSheetIds();\n            ids[className] = newId;\n            saveClassSheetIds(ids);\n            console.log(`[Backend Simulation] Updated SPREADSHEET_CONFIG for ${className} to ID: ${newId} and persisted to file`);\n        } else {\n            console.warn(`[Backend Simulation] Class ${className} not found in SPREADSHEET_CONFIG.`);\n        }\n    }\n}\n// Export singleton instance\nconst googleSheetsService = new GoogleSheetsService();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU1OO1lBQ1pNLEdBQUcsQ0FBQzJELFVBQVUsR0FBR3lIO1lBQ2pCckwsa0JBQWtCQztZQUNsQmdDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG9EQUFvRCxFQUFFMEIsVUFBVSxRQUFRLEVBQUV5SCxNQUFNLHNCQUFzQixDQUFDO1FBQ3RILE9BQU87WUFDTHBKLFFBQVFnSCxJQUFJLENBQUMsQ0FBQywyQkFBMkIsRUFBRXJGLFVBQVUsaUNBQWlDLENBQUM7UUFDekY7SUFDRjtBQUNGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU0wSCxzQkFBc0IsSUFBSW5LLHNCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9saWIvZ29vZ2xlLXNoZWV0cy50cz82MmQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdvb2dsZUF1dGggfSBmcm9tIFwiZ29vZ2xlLWF1dGgtbGlicmFyeVwiXG5pbXBvcnQgeyBnb29nbGUgfSBmcm9tIFwiZ29vZ2xlYXBpc1wiXG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIlxuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiXG5cbmNvbnN0IENMQVNTX1NIRUVUX0lEU19QQVRIID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIFwiY29uZmlnL2NsYXNzLXNoZWV0LWlkcy5qc29uXCIpXG5cbmZ1bmN0aW9uIGxvYWRDbGFzc1NoZWV0SWRzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJhdyA9IGZzLnJlYWRGaWxlU3luYyhDTEFTU19TSEVFVF9JRFNfUEFUSCwgXCJ1dGYtOFwiKVxuICAgIHJldHVybiBKU09OLnBhcnNlKHJhdylcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2F2ZUNsYXNzU2hlZXRJZHMoaWRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gIGZzLndyaXRlRmlsZVN5bmMoQ0xBU1NfU0hFRVRfSURTX1BBVEgsIEpTT04uc3RyaW5naWZ5KGlkcywgbnVsbCwgMiksIFwidXRmLThcIilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaGVldENyZWRlbnRpYWwge1xuICB1c2VybmFtZTogc3RyaW5nXG4gIHBhc3N3b3JkOiBzdHJpbmdcbiAgcm9sZTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3R1ZGVudFByb2plY3Qge1xuICBzbm86IHN0cmluZ1xuICBzdHVkZW50TmFtZTogc3RyaW5nXG4gIGdyYWRlOiBzdHJpbmdcbiAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgcHJvamVjdElkOiBzdHJpbmdcbiAgdGhlbWU/OiBzdHJpbmcgLy8gQWRkZWQgdGhlbWUgZmllbGRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKdWRnZVNjb3JlIHtcbiAgc25vOiBzdHJpbmdcbiAgc3R1ZGVudE5hbWU6IHN0cmluZ1xuICBncmFkZTogc3RyaW5nXG4gIHByb2plY3RUaXRsZTogc3RyaW5nXG4gIHByb2plY3RJZDogc3RyaW5nXG4gIGNyZWF0aXZpdHk6IG51bWJlciB8IG51bGxcbiAgc2NpZW50aWZpY1Rob3VnaHQ6IG51bWJlciB8IG51bGxcbiAgdGVjaG5pY2FsU2tpbGxzOiBudW1iZXIgfCBudWxsXG4gIHByZXNlbnRhdGlvbjogbnVtYmVyIHwgbnVsbFxuICBzdGF0dXM/OiBzdHJpbmcgLy8gQWRkZWQgc3RhdHVzIGZpZWxkIChlLmcuLCBcIlByZXNlbnRcIiwgXCJBYnNlbnRcIilcbiAgdGhlbWVGaXQ/OiBzdHJpbmcgfCBudWxsIC8vIEFkZGVkIHRoZW1lRml0IGZpZWxkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hlZXREYXRhIHtcbiAgdmFsdWVzOiBzdHJpbmdbXVtdXG4gIHJhbmdlOiBzdHJpbmdcbiAgc3ByZWFkc2hlZXRJZDogc3RyaW5nXG59XG5cbmludGVyZmFjZSBDbGFzc0NvbmZpZyB7XG4gIGlkOiBzdHJpbmdcbiAgYmFzZVNoZWV0OiBzdHJpbmdcbiAgcmFuZ2U6IHN0cmluZ1xufVxuXG4vLyBDb25maWd1cmF0aW9uIGZvciBHb29nbGUgU2hlZXRzIEFQSVxuZXhwb3J0IGNvbnN0IEdPT0dMRV9TSEVFVFNfQ09ORklHID0ge1xuICBzZXJ2aWNlQWNjb3VudEtleVBhdGg6IHByb2Nlc3MuZW52LkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfS0VZX1BBVEggfHwgXCIuL2NvbmZpZy9zZXJ2aWNlLWFjY291bnQta2V5Lmpzb25cIixcbiAgc2NvcGVzOiBbXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL3NwcmVhZHNoZWV0c1wiXSxcbn1cblxuLy8gU3ByZWFkc2hlZXQgY29uZmlndXJhdGlvbnMgLSBjaGFuZ2VkIHRvICdsZXQnIHRvIGFsbG93IGR5bmFtaWMgdXBkYXRlcyBmb3IgZGVtb25zdHJhdGlvblxuY29uc3QgcGVyc2lzdGVkSWRzID0gbG9hZENsYXNzU2hlZXRJZHMoKVxuZXhwb3J0IGxldCBTUFJFQURTSEVFVF9DT05GSUcgPSB7XG4gIENSRURFTlRJQUxTOiB7XG4gICAgaWQ6IHByb2Nlc3MuZW52LkNSRURFTlRJQUxTX1NQUkVBRFNIRUVUX0lEIHx8IFwiMXNuay1GWmF4eVpiU3VfV3ctb1BuYW04SnhaMlJMZzNldEk1VEJrci1UMUFcIiwgLy8gUkVQTEFDRSBXSVRIIFlPVVIgQ1JFREVOVElBTFMgU0hFRVQgSURcbiAgICByYW5nZTogXCJTaGVldDEhQTpDXCIsIC8vIFVzZXJuYW1lLCBQYXNzd29yZCwgUm9sZVxuICB9LFxuICBBRE1JTl9NQVNURVI6IHtcbiAgICBpZDogcHJvY2Vzcy5lbnYuQURNSU5fTUFTVEVSX1NQUkVBRFNIRUVUX0lEIHx8IFwiMXNuay1GWmF4eVpiU3VfV3ctb1BuYW04SnhaMlJMZzNldEk1VEJrci1UMUFcIiwgLy8gTmV3OiBBZG1pbiBNYXN0ZXIgU2hlZXQgSUQsIGRlZmF1bHRzIHRvIGNyZWRlbnRpYWxzIHNoZWV0XG4gIH0sXG4gIENMQVNTRVM6IHtcbiAgICBcIkNsYXNzIDRcIjoge1xuICAgICAgaWQ6IHBlcnNpc3RlZElkc1tcIkNsYXNzIDRcIl0sIC8vIFJFUExBQ0VcbiAgICAgIGJhc2VTaGVldDogXCJCYXNlU2hlZXRcIixcbiAgICAgIHJhbmdlOiBcIlNoZWV0MSFBOkZcIiwgLy8gVXBkYXRlZCByYW5nZSB0byBpbmNsdWRlIFRoZW1lIChhc3N1bWluZyBjb2x1bW4gRilcbiAgICB9LFxuICAgIFwiQ2xhc3MgNVwiOiB7XG4gICAgICBpZDogcGVyc2lzdGVkSWRzW1wiQ2xhc3MgNVwiXSwgLy8gUkVQTEFDRVxuICAgICAgYmFzZVNoZWV0OiBcIkJhc2VTaGVldFwiLFxuICAgICAgcmFuZ2U6IFwiU2hlZXQxIUE6RlwiLCAvLyBVcGRhdGVkIHJhbmdlIHRvIGluY2x1ZGUgVGhlbWUgKGFzc3VtaW5nIGNvbHVtbiBGKVxuICAgIH0sXG4gICAgXCJDbGFzcyA2XCI6IHtcbiAgICAgIGlkOiBwZXJzaXN0ZWRJZHNbXCJDbGFzcyA2XCJdLCAvLyBSRVBMQUNFXG4gICAgICBiYXNlU2hlZXQ6IFwiQmFzZVNoZWV0XCIsXG4gICAgICByYW5nZTogXCJTaGVldDEhQTpGXCIsIC8vIFVwZGF0ZWQgcmFuZ2UgdG8gaW5jbHVkZSBUaGVtZSAoYXNzdW1pbmcgY29sdW1uIEYpXG4gICAgfSxcbiAgICBcIkNsYXNzIDdcIjoge1xuICAgICAgaWQ6IHBlcnNpc3RlZElkc1tcIkNsYXNzIDdcIl0sIC8vIFJFUExBQ0VcbiAgICAgIGJhc2VTaGVldDogXCJCYXNlU2hlZXRcIixcbiAgICAgIHJhbmdlOiBcIlNoZWV0MSFBOkZcIiwgLy8gVXBkYXRlZCByYW5nZSB0byBpbmNsdWRlIFRoZW1lIChhc3N1bWluZyBjb2x1bW4gRilcbiAgICB9LFxuICAgIFwiQ2xhc3MgOFwiOiB7XG4gICAgICBpZDogcGVyc2lzdGVkSWRzW1wiQ2xhc3MgOFwiXSwgLy8gUkVQTEFDRVxuICAgICAgYmFzZVNoZWV0OiBcIkJhc2VTaGVldFwiLFxuICAgICAgcmFuZ2U6IFwiU2hlZXQxIUE6RlwiLCAvLyBVcGRhdGVkIHJhbmdlIHRvIGluY2x1ZGUgVGhlbWUgKGFzc3VtaW5nIGNvbHVtbiBGKVxuICAgIH0sXG4gICAgXCJDbGFzcyA5XCI6IHtcbiAgICAgIGlkOiBwZXJzaXN0ZWRJZHNbXCJDbGFzcyA5XCJdLCAvLyBSRVBMQUNFXG4gICAgICBiYXNlU2hlZXQ6IFwiQmFzZVNoZWV0XCIsXG4gICAgICByYW5nZTogXCJTaGVldDEhQTpGXCIsIC8vIFVwZGF0ZWQgcmFuZ2UgdG8gaW5jbHVkZSBUaGVtZSAoYXNzdW1pbmcgY29sdW1uIEYpXG4gICAgfSxcbiAgICBcIkNsYXNzIDEwXCI6IHtcbiAgICAgIGlkOiBwZXJzaXN0ZWRJZHNbXCJDbGFzcyAxMFwiXSwgLy8gUkVQTEFDRVxuICAgICAgYmFzZVNoZWV0OiBcIkJhc2VTaGVldFwiLFxuICAgICAgcmFuZ2U6IFwiU2hlZXQxIUE6RlwiLCAvLyBVcGRhdGVkIHJhbmdlIHRvIGluY2x1ZGUgVGhlbWUgKGFzc3VtaW5nIGNvbHVtbiBGKVxuICAgIH0sXG4gICAgXCJDbGFzcyAxMVwiOiB7XG4gICAgICBpZDogcGVyc2lzdGVkSWRzW1wiQ2xhc3MgMTFcIl0sIC8vIFJFUExBQ0VcbiAgICAgIGJhc2VTaGVldDogXCJCYXNlU2hlZXRcIixcbiAgICAgIHJhbmdlOiBcIlNoZWV0MSFBOkZcIiwgLy8gVXBkYXRlZCByYW5nZSB0byBpbmNsdWRlIFRoZW1lIChhc3N1bWluZyBjb2x1bW4gRilcbiAgICB9LFxuICAgIFwiQ2xhc3MgMTJcIjoge1xuICAgICAgaWQ6IHBlcnNpc3RlZElkc1tcIkNsYXNzIDEyXCJdLCAvLyBSRVBMQUNFXG4gICAgICBiYXNlU2hlZXQ6IFwiQmFzZVNoZWV0XCIsXG4gICAgICByYW5nZTogXCJTaGVldDEhQTpGXCIsIC8vIFVwZGF0ZWQgcmFuZ2UgdG8gaW5jbHVkZSBUaGVtZSAoYXNzdW1pbmcgY29sdW1uIEYpXG4gICAgfSxcbiAgfSxcbn1cblxuZXhwb3J0IGNsYXNzIEdvb2dsZVNoZWV0c1NlcnZpY2Uge1xuICBwcml2YXRlIGF1dGg6IEdvb2dsZUF1dGhcbiAgcHJpdmF0ZSBzaGVldHM6IGFueVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEhhbmRsZSBib3RoIGZpbGUgcGF0aCBhbmQgYmFzZTY0IGVuY29kZWQga2V5IGZvciBkZXBsb3ltZW50XG4gICAgaWYgKHByb2Nlc3MuZW52LkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfS0VZX0JBU0U2NCkge1xuICAgICAgY29uc3Qga2V5RGF0YSA9IEJ1ZmZlci5mcm9tKHByb2Nlc3MuZW52LkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfS0VZX0JBU0U2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJ1dGY4XCIpXG4gICAgICBjb25zdCBrZXlQYXRoID0gXCIvdG1wL3NlcnZpY2UtYWNjb3VudC1rZXkuanNvblwiIC8vIFZlcmNlbCAvdG1wIGRpcmVjdG9yeSBpcyB3cml0YWJsZVxuICAgICAgZnMud3JpdGVGaWxlU3luYyhrZXlQYXRoLCBrZXlEYXRhKVxuICAgICAgdGhpcy5hdXRoID0gbmV3IEdvb2dsZUF1dGgoe1xuICAgICAgICBrZXlGaWxlOiBrZXlQYXRoLFxuICAgICAgICBzY29wZXM6IEdPT0dMRV9TSEVFVFNfQ09ORklHLnNjb3BlcyxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXV0aCA9IG5ldyBHb29nbGVBdXRoKHtcbiAgICAgICAga2V5RmlsZTogR09PR0xFX1NIRUVUU19DT05GSUcuc2VydmljZUFjY291bnRLZXlQYXRoLFxuICAgICAgICBzY29wZXM6IEdPT0dMRV9TSEVFVFNfQ09ORklHLnNjb3BlcyxcbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuc2hlZXRzID0gZ29vZ2xlLnNoZWV0cyh7IHZlcnNpb246IFwidjRcIiwgYXV0aDogdGhpcy5hdXRoIH0pXG4gIH1cblxuICBhc3luYyBnZXRTaGVldERhdGEoc3ByZWFkc2hlZXRJZDogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogUHJvbWlzZTxTaGVldERhdGE+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCflJcgRmV0Y2hpbmcgZGF0YSBmcm9tIEdvb2dsZSBTaGVldHM6ICR7c3ByZWFkc2hlZXRJZH0sIFJhbmdlOiAke3JhbmdlfWApXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5nZXQoe1xuICAgICAgICBzcHJlYWRzaGVldElkLFxuICAgICAgICByYW5nZSxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlczogcmVzcG9uc2UuZGF0YS52YWx1ZXMgfHwgW10sXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBzcHJlYWRzaGVldElkLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgc2hlZXQgZGF0YTpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggZGF0YSBmcm9tIHNwcmVhZHNoZWV0ICR7c3ByZWFkc2hlZXRJZH0uIFBsZWFzZSBjaGVjayBwZXJtaXNzaW9ucyBhbmQgc3ByZWFkc2hlZXQgSUQuYCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBhc3luYyBiYXRjaEdldFNoZWV0RGF0YShzcHJlYWRzaGVldElkOiBzdHJpbmcsIHJhbmdlczogc3RyaW5nW10pOiBQcm9taXNlPHsgW3JhbmdlOiBzdHJpbmddOiBzdHJpbmdbXVtdIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNoZWV0cy5zcHJlYWRzaGVldHMudmFsdWVzLmJhdGNoR2V0KHtcbiAgICAgICAgc3ByZWFkc2hlZXRJZCxcbiAgICAgICAgcmFuZ2VzLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IHJlc3VsdDogeyBbcmFuZ2U6IHN0cmluZ106IHN0cmluZ1tdW10gfSA9IHt9XG4gICAgICA7KHJlc3BvbnNlLmRhdGEudmFsdWVSYW5nZXMgfHwgW10pLmZvckVhY2goKHZhbHVlUmFuZ2U6IGFueSkgPT4ge1xuICAgICAgICByZXN1bHRbdmFsdWVSYW5nZS5yYW5nZV0gPSB2YWx1ZVJhbmdlLnZhbHVlcyB8fCBbXVxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGJhdGNoR2V0U2hlZXREYXRhOlwiLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGJhdGNoIGdldCBkYXRhIGZyb20gc3ByZWFkc2hlZXQgJHtzcHJlYWRzaGVldElkfS5gKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldENyZWRlbnRpYWxzKCk6IFByb21pc2U8U2hlZXRDcmVkZW50aWFsW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0U2hlZXREYXRhKFNQUkVBRFNIRUVUX0NPTkZJRy5DUkVERU5USUFMUy5pZCwgU1BSRUFEU0hFRVRfQ09ORklHLkNSRURFTlRJQUxTLnJhbmdlKVxuXG4gICAgICBpZiAoIWRhdGEudmFsdWVzIHx8IGRhdGEudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjcmVkZW50aWFscyBmb3VuZCBpbiB0aGUgc3ByZWFkc2hlZXRcIilcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBoZWFkZXIgcm93IGFuZCBtYXAgdG8gY3JlZGVudGlhbCBvYmplY3RzXG4gICAgICByZXR1cm4gZGF0YS52YWx1ZXNcbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5tYXAoKHJvdykgPT4gKHtcbiAgICAgICAgICB1c2VybmFtZTogcm93WzBdIHx8IFwiXCIsXG4gICAgICAgICAgcGFzc3dvcmQ6IHJvd1sxXSB8fCBcIlwiLFxuICAgICAgICAgIHJvbGU6IHJvd1syXSB8fCBcIlwiLFxuICAgICAgICB9KSlcbiAgICAgICAgLmZpbHRlcigoY3JlZCkgPT4gY3JlZC51c2VybmFtZSAmJiBjcmVkLnBhc3N3b3JkICYmIGNyZWQucm9sZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGNyZWRlbnRpYWxzOlwiLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBjcmVkZW50aWFscyBmcm9tIEdvb2dsZSBTaGVldHNcIilcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRQcm9qZWN0SWRzKGNsYXNzTmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGFzc0NvbmZpZyA9IHRoaXMuZ2V0Q2xhc3NDb25maWcoY2xhc3NOYW1lKVxuXG4gICAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29uZmlndXJhdGlvbiBmb3VuZCBmb3IgY2xhc3M6ICR7Y2xhc3NOYW1lfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldFNoZWV0RGF0YShjbGFzc0NvbmZpZy5pZCwgY2xhc3NDb25maWcucmFuZ2UpXG5cbiAgICAgIGlmICghZGF0YS52YWx1ZXMgfHwgZGF0YS52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGhlYWRlciByb3cgYW5kIGV4dHJhY3QgUHJvamVjdCBJRHMgZnJvbSBjb2x1bW4gRSAoaW5kZXggNClcbiAgICAgIGNvbnN0IHByb2plY3RJZHMgPSBkYXRhLnZhbHVlc1xuICAgICAgICAuc2xpY2UoMSkgLy8gU2tpcCBoZWFkZXIgcm93XG4gICAgICAgIC5tYXAoKHJvdykgPT4gcm93WzRdKSAvLyBDb2x1bW4gRSAoUHJvamVjdCBJRCkgaXMgYXQgaW5kZXggNFxuICAgICAgICAuZmlsdGVyKChpZCkgPT4gaWQgJiYgaWQudHJpbSgpICE9PSBcIlwiKSAvLyBSZW1vdmUgZW1wdHkgY2VsbHNcbiAgICAgICAgLm1hcCgoaWQpID0+IGlkLnRyaW0oKSkgLy8gQ2xlYW4gd2hpdGVzcGFjZVxuXG4gICAgICAvLyBSZXR1cm4gdW5pcXVlIHByb2plY3QgSURzIG9ubHlcbiAgICAgIHJldHVybiBbLi4ubmV3IFNldChwcm9qZWN0SWRzKV1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgcHJvamVjdCBJRHMgZm9yICR7Y2xhc3NOYW1lfTpgLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHByb2plY3QgSURzIGZvciAke2NsYXNzTmFtZX0gZnJvbSBHb29nbGUgU2hlZXRzYClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRTdHVkZW50c0J5UHJvamVjdElkKGNsYXNzTmFtZTogc3RyaW5nLCBwcm9qZWN0SWQ6IHN0cmluZyk6IFByb21pc2U8U3R1ZGVudFByb2plY3RbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGFzc0NvbmZpZyA9IHRoaXMuZ2V0Q2xhc3NDb25maWcoY2xhc3NOYW1lKVxuXG4gICAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29uZmlndXJhdGlvbiBmb3VuZCBmb3IgY2xhc3M6ICR7Y2xhc3NOYW1lfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldFNoZWV0RGF0YShjbGFzc0NvbmZpZy5pZCwgY2xhc3NDb25maWcucmFuZ2UpXG5cbiAgICAgIGlmICghZGF0YS52YWx1ZXMgfHwgZGF0YS52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGhlYWRlciByb3cgYW5kIGZpbHRlciBieSBQcm9qZWN0IElEXG4gICAgICBjb25zdCBzdHVkZW50cyA9IGRhdGEudmFsdWVzXG4gICAgICAgIC5zbGljZSgxKSAvLyBTa2lwIGhlYWRlciByb3dcbiAgICAgICAgLmZpbHRlcigocm93KSA9PiByb3dbNF0gJiYgcm93WzRdLnRyaW0oKSA9PT0gcHJvamVjdElkLnRyaW0oKSkgLy8gRmlsdGVyIGJ5IFByb2plY3QgSURcbiAgICAgICAgLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgIHNubzogcm93WzBdIHx8IFwiXCIsXG4gICAgICAgICAgc3R1ZGVudE5hbWU6IHJvd1sxXSB8fCBcIlwiLFxuICAgICAgICAgIGdyYWRlOiByb3dbMl0gfHwgXCJcIixcbiAgICAgICAgICBwcm9qZWN0VGl0bGU6IHJvd1szXSB8fCBcIlwiLFxuICAgICAgICAgIHByb2plY3RJZDogcm93WzRdIHx8IFwiXCIsXG4gICAgICAgICAgdGhlbWU6IHJvd1s1XSB8fCBcIlwiLCAvLyBBc3N1bWluZyBUaGVtZSBpcyBpbiBjb2x1bW4gRiAoaW5kZXggNSlcbiAgICAgICAgfSkpXG4gICAgICAgIC5maWx0ZXIoKHN0dWRlbnQpID0+IHN0dWRlbnQuc3R1ZGVudE5hbWUgJiYgc3R1ZGVudC5wcm9qZWN0SWQpXG5cbiAgICAgIHJldHVybiBzdHVkZW50c1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBzdHVkZW50cyBmb3IgcHJvamVjdCAke3Byb2plY3RJZH06YCwgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBzdHVkZW50cyBmb3IgcHJvamVjdCAke3Byb2plY3RJZH0gZnJvbSBHb29nbGUgU2hlZXRzYClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRKdWRnZVNjb3JlcyhjbGFzc05hbWU6IHN0cmluZywganVkZ2VOYW1lOiBzdHJpbmcsIHByb2plY3RJZD86IHN0cmluZyk6IFByb21pc2U8SnVkZ2VTY29yZVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsYXNzQ29uZmlnID0gdGhpcy5nZXRDbGFzc0NvbmZpZyhjbGFzc05hbWUpXG4gICAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29uZmlndXJhdGlvbiBmb3VuZCBmb3IgY2xhc3M6ICR7Y2xhc3NOYW1lfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGp1ZGdlU2hlZXROYW1lID0gYEp1ZGdlXyR7anVkZ2VOYW1lfWBcbiAgICAgIGNvbnN0IGp1ZGdlUmFuZ2UgPSBgJHtqdWRnZVNoZWV0TmFtZX0hQTpLYCAvLyBVcGRhdGVkIHJhbmdlIHRvIGluY2x1ZGUgVGhlbWUgRml0IChhc3N1bWluZyBjb2x1bW4gSylcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0U2hlZXREYXRhKGNsYXNzQ29uZmlnLmlkLCBqdWRnZVJhbmdlKVxuXG4gICAgICAgIGlmICghZGF0YS52YWx1ZXMgfHwgZGF0YS52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTa2lwIGhlYWRlciByb3cgYW5kIG9wdGlvbmFsbHkgZmlsdGVyIGJ5IFByb2plY3QgSURcbiAgICAgICAgbGV0IHNjb3JlcyA9IGRhdGEudmFsdWVzXG4gICAgICAgICAgLnNsaWNlKDEpIC8vIFNraXAgaGVhZGVyIHJvd1xuICAgICAgICAgIC5tYXAoKHJvdykgPT4gKHtcbiAgICAgICAgICAgIHNubzogcm93WzBdIHx8IFwiXCIsXG4gICAgICAgICAgICBzdHVkZW50TmFtZTogcm93WzFdIHx8IFwiXCIsXG4gICAgICAgICAgICBncmFkZTogcm93WzJdIHx8IFwiXCIsXG4gICAgICAgICAgICBwcm9qZWN0VGl0bGU6IHJvd1szXSB8fCBcIlwiLFxuICAgICAgICAgICAgcHJvamVjdElkOiByb3dbNF0gfHwgXCJcIixcbiAgICAgICAgICAgIGNyZWF0aXZpdHk6IHJvd1s1XSA/IE51bWJlci5wYXJzZUZsb2F0KHJvd1s1XSkgOiBudWxsLFxuICAgICAgICAgICAgc2NpZW50aWZpY1Rob3VnaHQ6IHJvd1s2XSA/IE51bWJlci5wYXJzZUZsb2F0KHJvd1s2XSkgOiBudWxsLFxuICAgICAgICAgICAgdGVjaG5pY2FsU2tpbGxzOiByb3dbN10gPyBOdW1iZXIucGFyc2VGbG9hdChyb3dbN10pIDogbnVsbCxcbiAgICAgICAgICAgIHByZXNlbnRhdGlvbjogcm93WzhdID8gTnVtYmVyLnBhcnNlRmxvYXQocm93WzhdKSA6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IHJvd1s5XSB8fCBcIlByZXNlbnRcIiwgLy8gQXNzdW1pbmcgU3RhdHVzIGlzIGluIGNvbHVtbiBKIChpbmRleCA5KSwgZGVmYXVsdCB0byBcIlByZXNlbnRcIlxuICAgICAgICAgICAgdGhlbWVGaXQ6IHJvd1sxMF0gfHwgbnVsbCwgLy8gQXNzdW1pbmcgVGhlbWUgRml0IGlzIGluIGNvbHVtbiBLIChpbmRleCAxMClcbiAgICAgICAgICB9KSlcblxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SXIEZldGNoZWQgJHtzY29yZXMubGVuZ3RofSBzY29yZXMgZnJvbSAke2p1ZGdlU2hlZXROYW1lfSBmb3IgY2xhc3MgJHtjbGFzc05hbWV9YClcblxuICAgICAgICAvLyBGaWx0ZXIgYnkgcHJvamVjdCBJRCBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHByb2plY3RJZCkge1xuICAgICAgICAgIHNjb3JlcyA9IHNjb3Jlcy5maWx0ZXIoKHNjb3JlKSA9PiBzY29yZS5wcm9qZWN0SWQudHJpbSgpID09PSBwcm9qZWN0SWQudHJpbSgpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3Jlc1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSnVkZ2Ugc2hlZXQgZG9lc24ndCBleGlzdCB5ZXQgb3IgaXMgZW1wdHksIHdoaWNoIGlzIGZpbmUgZm9yIGluaXRpYWwgZmV0Y2hcbiAgICAgICAgY29uc29sZS5sb2coYEp1ZGdlIHNoZWV0ICR7anVkZ2VTaGVldE5hbWV9IGRvZXNuJ3QgZXhpc3QgeWV0IG9yIGlzIGVtcHR5LmApXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBqdWRnZSBzY29yZXM6YCwgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBqdWRnZSBzY29yZXMgZnJvbSBHb29nbGUgU2hlZXRzYClcbiAgICB9XG4gIH1cblxuICBhc3luYyBzYXZlSnVkZ2VTY29yZXMoY2xhc3NOYW1lOiBzdHJpbmcsIGp1ZGdlTmFtZTogc3RyaW5nLCBzY29yZXM6IEp1ZGdlU2NvcmVbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGFzc0NvbmZpZyA9IHRoaXMuZ2V0Q2xhc3NDb25maWcoY2xhc3NOYW1lKVxuICAgICAgaWYgKCFjbGFzc0NvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbmZpZ3VyYXRpb24gZm91bmQgZm9yIGNsYXNzOiAke2NsYXNzTmFtZX1gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBqdWRnZVNoZWV0TmFtZSA9IGBKdWRnZV8ke2p1ZGdlTmFtZX1gXG4gICAgICBjb25zdCBqdWRnZUhlYWRlclJvdyA9IFtcbiAgICAgICAgXCJTLk5vLlwiLFxuICAgICAgICBcIk5hbWUgb2YgdGhlIFN0dWRlbnRcIixcbiAgICAgICAgXCJHcmFkZVwiLFxuICAgICAgICBcIlByb2plY3QgVGl0bGVcIixcbiAgICAgICAgXCJQcm9qZWN0IElEXCIsXG4gICAgICAgIFwiQ3JlYXRpdml0eSAmIEltYWdpbmF0aW9uXCIsXG4gICAgICAgIFwiU2NpZW50aWZpYyBUaG91Z2h0XCIsXG4gICAgICAgIFwiVGVjaG5pY2FsIFNraWxsc1wiLFxuICAgICAgICBcIlByZXNlbnRhdGlvblwiLFxuICAgICAgICBcIlN0YXR1c1wiLFxuICAgICAgICBcIlRoZW1lIEZpdFwiLCAvLyBBZGRlZCBUaGVtZSBGaXQgdG8gaGVhZGVyXG4gICAgICBdXG5cbiAgICAgIC8vIEVuc3VyZSBqdWRnZSBzaGVldCBleGlzdHMgYW5kIGhhcyBoZWFkZXJcbiAgICAgIGF3YWl0IHRoaXMuZW5zdXJlU2hlZXRFeGlzdHMoY2xhc3NDb25maWcuaWQsIGp1ZGdlU2hlZXROYW1lLCBqdWRnZUhlYWRlclJvdylcblxuICAgICAgLy8gUHJlcGFyZSBuZXcgc2NvcmUgcm93cyBmb3IgYXBwZW5kaW5nXG4gICAgICBjb25zdCBuZXdSb3dzID0gc2NvcmVzLm1hcCgoc2NvcmUpID0+IFtcbiAgICAgICAgc2NvcmUuc25vLFxuICAgICAgICBzY29yZS5zdHVkZW50TmFtZSxcbiAgICAgICAgc2NvcmUuZ3JhZGUsXG4gICAgICAgIHNjb3JlLnByb2plY3RUaXRsZSxcbiAgICAgICAgc2NvcmUucHJvamVjdElkLFxuICAgICAgICBzY29yZS5jcmVhdGl2aXR5Py50b1N0cmluZygpIHx8IFwiXCIsXG4gICAgICAgIHNjb3JlLnNjaWVudGlmaWNUaG91Z2h0Py50b1N0cmluZygpIHx8IFwiXCIsXG4gICAgICAgIHNjb3JlLnRlY2huaWNhbFNraWxscz8udG9TdHJpbmcoKSB8fCBcIlwiLFxuICAgICAgICBzY29yZS5wcmVzZW50YXRpb24/LnRvU3RyaW5nKCkgfHwgXCJcIixcbiAgICAgICAgc2NvcmUuc3RhdHVzIHx8IFwiUHJlc2VudFwiLCAvLyBJbmNsdWRlIHN0YXR1c1xuICAgICAgICBzY29yZS50aGVtZUZpdCB8fCBcIlwiLCAvLyBJbmNsdWRlIHRoZW1lRml0XG4gICAgICBdKVxuXG4gICAgICAvLyBBcHBlbmQgbmV3IHNjb3JlcyAobmV2ZXIgb3ZlcndyaXRlKVxuICAgICAgYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5hcHBlbmQoe1xuICAgICAgICBzcHJlYWRzaGVldElkOiBjbGFzc0NvbmZpZy5pZCxcbiAgICAgICAgcmFuZ2U6IGAke2p1ZGdlU2hlZXROYW1lfSFBOktgLCAvLyBVcGRhdGVkIHJhbmdlIGZvciBhcHBlbmRpbmdcbiAgICAgICAgdmFsdWVJbnB1dE9wdGlvbjogXCJVU0VSX0VOVEVSRURcIixcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICB2YWx1ZXM6IG5ld1Jvd3MsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIEFwcGVuZGVkICR7bmV3Um93cy5sZW5ndGh9IG5ldyBzY29yZSByb3dzIHRvICR7anVkZ2VTaGVldE5hbWV9YClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYXBwZW5kaW5nIGp1ZGdlIHNjb3JlczpgLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGFwcGVuZCBqdWRnZSBzY29yZXMgdG8gR29vZ2xlIFNoZWV0c2ApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRFeGlzdGluZ0p1ZGdlRGF0YShzcHJlYWRzaGVldElkOiBzdHJpbmcsIHNoZWV0TmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5nZXQoe1xuICAgICAgICBzcHJlYWRzaGVldElkLFxuICAgICAgICByYW5nZTogYCR7c2hlZXROYW1lfSFBOktgLCAvLyBVcGRhdGVkIHJhbmdlXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEudmFsdWVzIHx8IFtdXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFNoZWV0IGRvZXNuJ3QgZXhpc3Qgb3IgaXMgZW1wdHlcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZW5zdXJlU2hlZXRFeGlzdHMoc3ByZWFkc2hlZXRJZDogc3RyaW5nLCBzaGVldE5hbWU6IHN0cmluZywgaGVhZGVyUm93Pzogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3ByZWFkc2hlZXQgPSBhd2FpdCB0aGlzLnNoZWV0cy5zcHJlYWRzaGVldHMuZ2V0KHtcbiAgICAgICAgc3ByZWFkc2hlZXRJZDogc3ByZWFkc2hlZXRJZCxcbiAgICAgICAgZmllbGRzOiBcInNoZWV0cy5wcm9wZXJ0aWVzLnRpdGxlLHNoZWV0cy5wcm9wZXJ0aWVzLnNoZWV0SWRcIixcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHNoZWV0RXhpc3RzID0gc3ByZWFkc2hlZXQuZGF0YS5zaGVldHM/LnNvbWUoKHNoZWV0OiBhbnkpID0+IHNoZWV0LnByb3BlcnRpZXMudGl0bGUgPT09IHNoZWV0TmFtZSlcblxuICAgICAgaWYgKCFzaGVldEV4aXN0cykge1xuICAgICAgICBhd2FpdCB0aGlzLnNoZWV0cy5zcHJlYWRzaGVldHMuYmF0Y2hVcGRhdGUoe1xuICAgICAgICAgIHNwcmVhZHNoZWV0SWQ6IHNwcmVhZHNoZWV0SWQsXG4gICAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgIHJlcXVlc3RzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhZGRTaGVldDoge1xuICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc2hlZXROYW1lLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIENyZWF0ZWQgbmV3IHNoZWV0OiAke3NoZWV0TmFtZX0gaW4gc3ByZWFkc2hlZXQgJHtzcHJlYWRzaGVldElkfWApXG5cbiAgICAgICAgLy8gSWYgaGVhZGVyIHJvdyBpcyBwcm92aWRlZCwgd3JpdGUgaXRcbiAgICAgICAgaWYgKGhlYWRlclJvdyAmJiBoZWFkZXJSb3cubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc2hlZXRzLnNwcmVhZHNoZWV0cy52YWx1ZXMuYXBwZW5kKHtcbiAgICAgICAgICAgIHNwcmVhZHNoZWV0SWQ6IHNwcmVhZHNoZWV0SWQsXG4gICAgICAgICAgICByYW5nZTogYCR7c2hlZXROYW1lfSFBMWAsXG4gICAgICAgICAgICB2YWx1ZUlucHV0T3B0aW9uOiBcIlVTRVJfRU5URVJFRFwiLFxuICAgICAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgICAgdmFsdWVzOiBbaGVhZGVyUm93XSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEFkZGVkIGhlYWRlciB0byBuZXcgc2hlZXQ6ICR7c2hlZXROYW1lfWApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZW5zdXJpbmcgc2hlZXQgJHtzaGVldE5hbWV9IGV4aXN0cyBpbiAke3NwcmVhZHNoZWV0SWR9OmAsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIG9yIHZlcmlmeSBzaGVldDogJHtzaGVldE5hbWV9YClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRBbGxTaGVldFRpdGxlcyhzcHJlYWRzaGVldElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLmdldCh7XG4gICAgICAgIHNwcmVhZHNoZWV0SWQ6IHNwcmVhZHNoZWV0SWQsXG4gICAgICAgIGZpZWxkczogXCJzaGVldHMucHJvcGVydGllcy50aXRsZVwiLFxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnNoZWV0cz8ubWFwKChzaGVldDogYW55KSA9PiBzaGVldC5wcm9wZXJ0aWVzLnRpdGxlKSB8fCBbXVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBzaGVldCB0aXRsZXMgZm9yICR7c3ByZWFkc2hlZXRJZH06YCwgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBzaGVldCB0aXRsZXMgZm9yIHNwcmVhZHNoZWV0ICR7c3ByZWFkc2hlZXRJZH0uYClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRBbGxKdWRnZVNoZWV0TmFtZXMoY2xhc3NTcHJlYWRzaGVldElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgYWxsU2hlZXRUaXRsZXMgPSBhd2FpdCB0aGlzLmdldEFsbFNoZWV0VGl0bGVzKGNsYXNzU3ByZWFkc2hlZXRJZClcbiAgICByZXR1cm4gYWxsU2hlZXRUaXRsZXMuZmlsdGVyKCh0aXRsZSkgPT4gdGl0bGUuc3RhcnRzV2l0aChcIkp1ZGdlX1wiKSlcbiAgfVxuXG4gIGFzeW5jIGdldFByb2plY3REZXRhaWxzTWFwKFxuICAgIGNsYXNzTmFtZTogc3RyaW5nLFxuICApOiBQcm9taXNlPE1hcDxzdHJpbmcsIHsgdGl0bGU6IHN0cmluZzsgdGhlbWU6IHN0cmluZzsgc3R1ZGVudE5hbWVzOiBTZXQ8c3RyaW5nPiB9Pj4ge1xuICAgIGNvbnN0IGNsYXNzQ29uZmlnID0gdGhpcy5nZXRDbGFzc0NvbmZpZyhjbGFzc05hbWUpXG4gICAgaWYgKCFjbGFzc0NvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBjb25maWd1cmF0aW9uIGZvdW5kIGZvciBjbGFzczogJHtjbGFzc05hbWV9YClcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRTaGVldERhdGEoY2xhc3NDb25maWcuaWQsIGNsYXNzQ29uZmlnLnJhbmdlKSAvLyBSZWFkcyBTaGVldDEhQTpGXG5cbiAgICBjb25zdCBwcm9qZWN0TWFwID0gbmV3IE1hcDxzdHJpbmcsIHsgdGl0bGU6IHN0cmluZzsgdGhlbWU6IHN0cmluZzsgc3R1ZGVudE5hbWVzOiBTZXQ8c3RyaW5nPiB9PigpXG4gICAgaWYgKGRhdGEudmFsdWVzICYmIGRhdGEudmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFNraXAgaGVhZGVyXG4gICAgICBkYXRhLnZhbHVlcy5zbGljZSgxKS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gcm93WzRdPy50cmltKCkgLy8gQ29sdW1uIEVcbiAgICAgICAgY29uc3QgcHJvamVjdFRpdGxlID0gcm93WzNdPy50cmltKCkgLy8gQ29sdW1uIERcbiAgICAgICAgY29uc3QgdGhlbWUgPSByb3dbNV0/LnRyaW0oKSAvLyBDb2x1bW4gRlxuICAgICAgICBjb25zdCBzdHVkZW50TmFtZSA9IHJvd1sxXT8udHJpbSgpIC8vIENvbHVtbiBCXG5cbiAgICAgICAgaWYgKHByb2plY3RJZCkge1xuICAgICAgICAgIGlmICghcHJvamVjdE1hcC5oYXMocHJvamVjdElkKSkge1xuICAgICAgICAgICAgcHJvamVjdE1hcC5zZXQocHJvamVjdElkLCB7XG4gICAgICAgICAgICAgIHRpdGxlOiBwcm9qZWN0VGl0bGUgfHwgXCJcIixcbiAgICAgICAgICAgICAgdGhlbWU6IHRoZW1lIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHN0dWRlbnROYW1lczogbmV3IFNldDxzdHJpbmc+KCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3R1ZGVudE5hbWUpIHtcbiAgICAgICAgICAgIHByb2plY3RNYXAuZ2V0KHByb2plY3RJZCk/LnN0dWRlbnROYW1lcy5hZGQoc3R1ZGVudE5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcHJvamVjdE1hcFxuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc0NsYXNzU2NvcmVzKGNsYXNzTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY2xhc3NDb25maWcgPSB0aGlzLmdldENsYXNzQ29uZmlnKGNsYXNzTmFtZSlcbiAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbmZpZ3VyYXRpb24gZm91bmQgZm9yIGNsYXNzOiAke2NsYXNzTmFtZX1gKVxuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzU3ByZWFkc2hlZXRJZCA9IGNsYXNzQ29uZmlnLmlkXG4gICAgY29uc3QgcHJvamVjdERldGFpbHNNYXAgPSBhd2FpdCB0aGlzLmdldFByb2plY3REZXRhaWxzTWFwKGNsYXNzTmFtZSlcbiAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gRm91bmQgJHtwcm9qZWN0RGV0YWlsc01hcC5zaXplfSB1bmlxdWUgcHJvamVjdHMgZnJvbSBCYXNlU2hlZXQuYClcblxuICAgIGNvbnN0IGp1ZGdlU2hlZXROYW1lcyA9IGF3YWl0IHRoaXMuZ2V0QWxsSnVkZ2VTaGVldE5hbWVzKGNsYXNzU3ByZWFkc2hlZXRJZClcbiAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gRm91bmQgJHtqdWRnZVNoZWV0TmFtZXMubGVuZ3RofSBqdWRnZSBzaGVldHMuYClcblxuICAgIC8vIE1hcCB0byBzdG9yZSB0aGUgbGF0ZXN0IHNjb3JlIGZvciBlYWNoIHByb2plY3QgYnkgZWFjaCBqdWRnZVxuICAgIGNvbnN0IGxhdGVzdFByb2plY3RTY29yZXNCeUp1ZGdlID0gbmV3IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIEp1ZGdlU2NvcmU+PigpIC8vIHByb2plY3RJZCAtPiAoanVkZ2VOYW1lIC0+IGxhdGVzdFNjb3JlKVxuXG4gICAgICAgIGNvbnN0IGp1ZGdlUmFuZ2VzID0ganVkZ2VTaGVldE5hbWVzLm1hcChqdWRnZVNoZWV0TmFtZSA9PiBgJHtqdWRnZVNoZWV0TmFtZX0hQTpLYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwianVkZ2VSYW5nZU1BZGR5XCIpO1xuICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBGZXRjaGluZyBkYXRhIGZvciBqdWRnZVJhbmdlTUFkZHkgc2hlZXRzOiAke2p1ZGdlUmFuZ2VzfWApO1xuXG4gICAgY29uc3QgYmF0Y2hEYXRhID0gYXdhaXQgdGhpcy5iYXRjaEdldFNoZWV0RGF0YShjbGFzc1NwcmVhZHNoZWV0SWQsIGp1ZGdlUmFuZ2VzKTtcbiAgICBjb25zb2xlLmxvZyhcImJhdGNoRGF0YTpcIiwgSlNPTi5zdHJpbmdpZnkoYmF0Y2hEYXRhLCBudWxsLCAyKSk7XG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIEZldGNoZWRNYWRkeSBkYXRhIGZvciAke2p1ZGdlUmFuZ2VzLmxlbmd0aH0gJHtqdWRnZVJhbmdlc30gJHtiYXRjaERhdGF9IGp1ZGdlIHNoZWV0cyBpbiBiYXRjaC5gKVxuICAgIFxuICAgIGZvciAoY29uc3QganVkZ2VTaGVldE5hbWUgb2YganVkZ2VTaGVldE5hbWVzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gUHJvY2Vzc2luZyBqdWRnZSBzaGVldCBtYWRkeTogJHtqdWRnZVNoZWV0TmFtZX1gKTtcbiAgICAgIGNvbnN0IGp1ZGdlTmFtZSA9IGp1ZGdlU2hlZXROYW1lLnJlcGxhY2UoXCJKdWRnZV9cIiwgXCJcIik7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBiYXRjaERhdGFbYCR7anVkZ2VTaGVldE5hbWV9IUExOksxMDAwYF0gfHwgW107XG4gICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gRm91bmRNQWRkeXMgJHt2YWx1ZXMubGVuZ3RofSByb3dzIGluIHNoZWV0ICR7anVkZ2VTaGVldE5hbWV9IGZvciBKdWRnZSAke2p1ZGdlTmFtZX0uYCk7XG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA8PSAxKSBjb250aW51ZTsgLy8gc2tpcCBpZiBvbmx5IGhlYWRlciBvciBlbXB0eVxuICAgIFxuICAgICAgLy8gUGFyc2Ugc2NvcmVzIGFzIGluIGdldEp1ZGdlU2NvcmVzXG4gICAgICBjb25zdCBzY29yZXNGb3JKdWRnZSA9IHZhbHVlc1xuICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgIHNubzogcm93WzBdIHx8IFwiXCIsXG4gICAgICAgICAgc3R1ZGVudE5hbWU6IHJvd1sxXSB8fCBcIlwiLFxuICAgICAgICAgIGdyYWRlOiByb3dbMl0gfHwgXCJcIixcbiAgICAgICAgICBwcm9qZWN0VGl0bGU6IHJvd1szXSB8fCBcIlwiLFxuICAgICAgICAgIHByb2plY3RJZDogcm93WzRdIHx8IFwiXCIsXG4gICAgICAgICAgY3JlYXRpdml0eTogcm93WzVdID8gTnVtYmVyLnBhcnNlRmxvYXQocm93WzVdKSA6IG51bGwsXG4gICAgICAgICAgc2NpZW50aWZpY1Rob3VnaHQ6IHJvd1s2XSA/IE51bWJlci5wYXJzZUZsb2F0KHJvd1s2XSkgOiBudWxsLFxuICAgICAgICAgIHRlY2huaWNhbFNraWxsczogcm93WzddID8gTnVtYmVyLnBhcnNlRmxvYXQocm93WzddKSA6IG51bGwsXG4gICAgICAgICAgcHJlc2VudGF0aW9uOiByb3dbOF0gPyBOdW1iZXIucGFyc2VGbG9hdChyb3dbOF0pIDogbnVsbCxcbiAgICAgICAgICBzdGF0dXM6IHJvd1s5XSB8fCBcIlByZXNlbnRcIixcbiAgICAgICAgICB0aGVtZUZpdDogcm93WzEwXSB8fCBudWxsLFxuICAgICAgICB9KSlcblxuICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBGb3VuZE1hZGR5ICR7c2NvcmVzRm9ySnVkZ2UubGVuZ3RofSBzY29yZXMgZm9yIEp1ZGdlICR7anVkZ2VOYW1lfSBpbiBzaGVldCAke2p1ZGdlU2hlZXROYW1lfS5gKTtcbiAgICAgIFxuICAgIGZvciAoY29uc3Qgc2NvcmUgb2Ygc2NvcmVzRm9ySnVkZ2UpIHtcbiAgICAgICAgY29uc3QgcElkID0gc2NvcmUucHJvamVjdElkLnRyaW0oKTtcbiAgICAgICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIFByb2Nlc3Npbmcgc2NvcmUgZm9yIFByb2plY3QgJHtwSWR9IGJ5IEp1ZGdlICR7anVkZ2VOYW1lfTpgLCBzY29yZSk7XG4gICAgICAgIGlmICghbGF0ZXN0UHJvamVjdFNjb3Jlc0J5SnVkZ2UuaGFzKHBJZCkpIHtcbiAgICAgICAgICBsYXRlc3RQcm9qZWN0U2NvcmVzQnlKdWRnZS5zZXQocElkLCBuZXcgTWFwPHN0cmluZywgSnVkZ2VTY29yZT4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGF0ZXN0UHJvamVjdFNjb3Jlc0J5SnVkZ2UuZ2V0KHBJZCk/LnNldChqdWRnZU5hbWUsIHNjb3JlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIENvbGxlY3RlZCBsYXRlc3Qgc2NvcmVzIGZvciBwcm9qZWN0cyBmcm9tIGVhY2gganVkZ2UuYClcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBbJHtjbGFzc05hbWV9XSBsYXRlc3RQcm9qZWN0U2NvcmVzQnlKdWRnZSBmb3IgYSBzYW1wbGUgcHJvamVjdCAoZS5nLiwgUDQwMDEpOmAsXG4gICAgICBsYXRlc3RQcm9qZWN0U2NvcmVzQnlKdWRnZS5nZXQoXCJQNDAwMVwiKSxcbiAgICApXG5cbiAgICAvLyBBZ2dyZWdhdGUgc2NvcmVzIHBlciBwcm9qZWN0XG4gICAgY29uc3QgcHJvamVjdEFnZ3JlZ2F0ZWRTY29yZXM6IHtcbiAgICAgIFtwcm9qZWN0SWQ6IHN0cmluZ106IHtcbiAgICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgICAgdGhlbWU6IHN0cmluZ1xuICAgICAgICBjcmVhdGl2aXR5U3VtOiBudW1iZXJcbiAgICAgICAgc2NpZW50aWZpY1Rob3VnaHRTdW06IG51bWJlclxuICAgICAgICB0ZWNobmljYWxTa2lsbHNTdW06IG51bWJlclxuICAgICAgICBwcmVzZW50YXRpb25TdW06IG51bWJlclxuICAgICAgICBqdWRnZUNvdW50OiBudW1iZXIgLy8gTnVtYmVyIG9mIGp1ZGdlcyB3aG8gc2NvcmVkIHRoaXMgcHJvamVjdCBhcyBQcmVzZW50XG4gICAgICAgIGFic2VudENvdW50OiBudW1iZXIgLy8gTnVtYmVyIG9mIGp1ZGdlcyB3aG8gbWFya2VkIHRoaXMgcHJvamVjdCBBYnNlbnRcbiAgICAgICAgc3R1ZGVudE5hbWVzOiBzdHJpbmdbXSAvLyBUbyBjb2xsZWN0IGFsbCBzdHVkZW50IG5hbWVzIGZvciB0aGlzIHByb2plY3RcbiAgICAgIH1cbiAgICB9ID0ge31cblxuICAgIC8vIEluaXRpYWxpemUgcHJvamVjdEFnZ3JlZ2F0ZWRTY29yZXMgd2l0aCBkZXRhaWxzIGZyb20gQmFzZVNoZWV0XG4gICAgZm9yIChjb25zdCBbcElkLCBkZXRhaWxzXSBvZiBwcm9qZWN0RGV0YWlsc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW3BJZF0gPSB7XG4gICAgICAgIHByb2plY3RUaXRsZTogZGV0YWlscy50aXRsZSxcbiAgICAgICAgdGhlbWU6IGRldGFpbHMudGhlbWUsXG4gICAgICAgIGNyZWF0aXZpdHlTdW06IDAsXG4gICAgICAgIHNjaWVudGlmaWNUaG91Z2h0U3VtOiAwLFxuICAgICAgICB0ZWNobmljYWxTa2lsbHNTdW06IDAsXG4gICAgICAgIHByZXNlbnRhdGlvblN1bTogMCxcbiAgICAgICAganVkZ2VDb3VudDogMCxcbiAgICAgICAgYWJzZW50Q291bnQ6IDAsXG4gICAgICAgIHN0dWRlbnROYW1lczogQXJyYXkuZnJvbShkZXRhaWxzLnN0dWRlbnROYW1lcykuc29ydCgpLFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBvcHVsYXRlIGFnZ3JlZ2F0ZWQgc2NvcmVzIGZyb20ganVkZ2Ugc3VibWlzc2lvbnNcbiAgICBmb3IgKGNvbnN0IFtwSWQsIGp1ZGdlU2NvcmVzTWFwXSBvZiBsYXRlc3RQcm9qZWN0U2NvcmVzQnlKdWRnZS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBQcm9jZXNzaW5nIHNjb3JlcyBmb3IgUHJvamVjdCAke3BJZH0gZnJvbSBqdWRnZXM6YCwgQXJyYXkuZnJvbShqdWRnZVNjb3Jlc01hcC5rZXlzKCkpKVxuICAgICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIGp1ZGdlU2NvcmVzTWFwIGZvciBQcm9qZWN0ICR7cElkfSBoYXMgJHtqdWRnZVNjb3Jlc01hcC5zaXplfSBlbnRyaWVzLmApXG4gICAgICBpZiAoIXByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW3BJZF0pIHtcbiAgICAgICAgLy8gVGhpcyBwcm9qZWN0IHdhcyBzY29yZWQgYnV0IG5vdCBmb3VuZCBpbiBCYXNlU2hlZXQgKGUuZy4sIGlmIEJhc2VTaGVldCBpcyBpbmNvbXBsZXRlKVxuICAgICAgICAvLyBUcnkgdG8gZ2V0IGRldGFpbHMgZnJvbSB0aGUgZmlyc3Qgc2NvcmUgZW50cnkgZm9yIHRoaXMgcHJvamVjdFxuICAgICAgICBjb25zdCBmaXJzdFNjb3JlID0gQXJyYXkuZnJvbShqdWRnZVNjb3Jlc01hcC52YWx1ZXMoKSlbMF1cbiAgICAgICAgcHJvamVjdEFnZ3JlZ2F0ZWRTY29yZXNbcElkXSA9IHtcbiAgICAgICAgICBwcm9qZWN0VGl0bGU6IGZpcnN0U2NvcmU/LnByb2plY3RUaXRsZSB8fCBcIlwiLFxuICAgICAgICAgIHRoZW1lOiBwcm9qZWN0RGV0YWlsc01hcC5nZXQocElkKT8udGhlbWUgfHwgXCJcIiwgLy8gRmFsbGJhY2sgdG8gQmFzZVNoZWV0IHRoZW1lIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGNyZWF0aXZpdHlTdW06IDAsXG4gICAgICAgICAgc2NpZW50aWZpY1Rob3VnaHRTdW06IDAsXG4gICAgICAgICAgdGVjaG5pY2FsU2tpbGxzU3VtOiAwLFxuICAgICAgICAgIHByZXNlbnRhdGlvblN1bTogMCxcbiAgICAgICAgICBqdWRnZUNvdW50OiAwLFxuICAgICAgICAgIGFic2VudENvdW50OiAwLFxuICAgICAgICAgIHN0dWRlbnROYW1lczogW10sIC8vIENhbm5vdCByZWxpYWJseSBnZXQgYWxsIHN0dWRlbnQgbmFtZXMgaWYgbm90IGluIEJhc2VTaGVldFxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgWyR7Y2xhc3NOYW1lfV0gUHJvamVjdCAke3BJZH0gZm91bmQgaW4ganVkZ2Ugc2hlZXRzIGJ1dCBub3QgaW4gQmFzZVNoZWV0LiBTdHVkZW50IG5hbWVzIG1pZ2h0IGJlIGluY29tcGxldGUuYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbanVkZ2VOYW1lLCBzY29yZV0gb2YganVkZ2VTY29yZXNNYXAuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChzY29yZS5zdGF0dXMgPT09IFwiQWJzZW50XCIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gSnVkZ2UgJHtqdWRnZU5hbWV9IG1hcmtlZCBQcm9qZWN0ICR7cElkfSBhcyBBYnNlbnQuYClcbiAgICAgICAgICBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdLmFic2VudENvdW50KytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQcmVzZW50XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgWyR7Y2xhc3NOYW1lfV0gQWRkaW5nIHNjb3JlIGZvciBQcm9qZWN0ICR7cElkfSBieSBKdWRnZSAke2p1ZGdlTmFtZX06IENyZWF0aXZpdHk9JHtzY29yZS5jcmVhdGl2aXR5fSwgU2NpZW50aWZpY1Rob3VnaHQ9JHtzY29yZS5zY2llbnRpZmljVGhvdWdodH0sIFRlY2huaWNhbFNraWxscz0ke3Njb3JlLnRlY2huaWNhbFNraWxsc30sIFByZXNlbnRhdGlvbj0ke3Njb3JlLnByZXNlbnRhdGlvbn1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdLmp1ZGdlQ291bnQrK1xuICAgICAgICAgIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW3BJZF0uY3JlYXRpdml0eVN1bSArPSBzY29yZS5jcmVhdGl2aXR5IHx8IDBcbiAgICAgICAgICBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdLnNjaWVudGlmaWNUaG91Z2h0U3VtICs9IHNjb3JlLnNjaWVudGlmaWNUaG91Z2h0IHx8IDBcbiAgICAgICAgICBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdLnRlY2huaWNhbFNraWxsc1N1bSArPSBzY29yZS50ZWNobmljYWxTa2lsbHMgfHwgMFxuICAgICAgICAgIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW3BJZF0ucHJlc2VudGF0aW9uU3VtICs9IHNjb3JlLnByZXNlbnRhdGlvbiB8fCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIEFnZ3JlZ2F0aW9uIGNvbXBsZXRlIGZvciBwcm9qZWN0IHNjb3Jlcy5gKVxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFske2NsYXNzTmFtZX1dIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzIGZvciBhIHNhbXBsZSBwcm9qZWN0IChlLmcuLCBQNDAwMSk6YCxcbiAgICAgIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW1wiUDQwMDFcIl0sXG4gICAgKVxuXG4gICAgLy8gQ2FsY3VsYXRlIHByb2plY3QgYXZlcmFnZXMgYW5kIHByZXBhcmUgcm93cyBmb3IgXCJTY29yZVwiIHRhYlxuICAgIGNvbnN0IHNjb3JlVGFiUm93czogc3RyaW5nW11bXSA9IFtdXG4gICAgc2NvcmVUYWJSb3dzLnB1c2goW1xuICAgICAgXCJQcm9qZWN0IElEXCIsXG4gICAgICBcIlByb2plY3QgVGl0bGVcIixcbiAgICAgIFwiVGhlbWVcIixcbiAgICAgIFwiQXZnIENyZWF0aXZpdHlcIixcbiAgICAgIFwiQXZnIFNjaWVudGlmaWMgVGhvdWdodFwiLFxuICAgICAgXCJBdmcgVGVjaG5pY2FsIFNraWxsc1wiLFxuICAgICAgXCJBdmcgUHJlc2VudGF0aW9uXCIsXG4gICAgICBcIlByb2plY3QgQXZlcmFnZSBTY29yZVwiLFxuICAgICAgXCJTdHVkZW50IE5hbWVzXCIsXG4gICAgXSkgLy8gTmV3IEhlYWRlciBmb3IgU2NvcmUgdGFiXG5cbiAgICBjb25zdCBwcm9qZWN0c0ZvclNjb3JlVGFiOiBBcnJheTx7XG4gICAgICBwcm9qZWN0SWQ6IHN0cmluZ1xuICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgIHRoZW1lOiBzdHJpbmdcbiAgICAgIGF2Z0NyZWF0aXZpdHk6IG51bWJlclxuICAgICAgYXZnU2NpZW50aWZpY1Rob3VnaHQ6IG51bWJlclxuICAgICAgYXZnVGVjaG5pY2FsU2tpbGxzOiBudW1iZXJcbiAgICAgIGF2Z1ByZXNlbnRhdGlvbjogbnVtYmVyXG4gICAgICBwcm9qZWN0QXZnU2NvcmU6IG51bWJlclxuICAgICAgc3R1ZGVudE5hbWVzOiBzdHJpbmdcbiAgICB9PiA9IFtdXG5cbiAgICBmb3IgKGNvbnN0IHBJZCBpbiBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlcykge1xuICAgICAgY29uc3QgcHJvamVjdERhdGEgPSBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdXG4gICAgICBsZXQgYXZnQ3JlYXRpdml0eSA9IDBcbiAgICAgIGxldCBhdmdTY2llbnRpZmljVGhvdWdodCA9IDBcbiAgICAgIGxldCBhdmdUZWNobmljYWxTa2lsbHMgPSAwXG4gICAgICBsZXQgYXZnUHJlc2VudGF0aW9uID0gMFxuICAgICAgbGV0IHByb2plY3RBdmdTY29yZSA9IDBcblxuICAgICAgaWYgKHByb2plY3REYXRhLmp1ZGdlQ291bnQgPiAwKSB7XG4gICAgICAgIGF2Z0NyZWF0aXZpdHkgPSBwcm9qZWN0RGF0YS5jcmVhdGl2aXR5U3VtIC8gcHJvamVjdERhdGEuanVkZ2VDb3VudFxuICAgICAgICBhdmdTY2llbnRpZmljVGhvdWdodCA9IHByb2plY3REYXRhLnNjaWVudGlmaWNUaG91Z2h0U3VtIC8gcHJvamVjdERhdGEuanVkZ2VDb3VudFxuICAgICAgICBhdmdUZWNobmljYWxTa2lsbHMgPSBwcm9qZWN0RGF0YS50ZWNobmljYWxTa2lsbHNTdW0gLyBwcm9qZWN0RGF0YS5qdWRnZUNvdW50XG4gICAgICAgIGF2Z1ByZXNlbnRhdGlvbiA9IHByb2plY3REYXRhLnByZXNlbnRhdGlvblN1bSAvIHByb2plY3REYXRhLmp1ZGdlQ291bnRcbiAgICAgICAgcHJvamVjdEF2Z1Njb3JlID0gKGF2Z0NyZWF0aXZpdHkgKyBhdmdTY2llbnRpZmljVGhvdWdodCArIGF2Z1RlY2huaWNhbFNraWxscyArIGF2Z1ByZXNlbnRhdGlvbikgLyA0XG4gICAgICB9IGVsc2UgaWYgKHByb2plY3REYXRhLmFic2VudENvdW50ID4gMCAmJiBwcm9qZWN0RGF0YS5qdWRnZUNvdW50ID09PSAwKSB7XG4gICAgICAgIC8vIEFsbCBqdWRnZXMgbWFya2VkIHByb2plY3QgYWJzZW50LCBzbyBhbGwgc2NvcmVzIGFyZSAwXG4gICAgICAgIGF2Z0NyZWF0aXZpdHkgPSAwXG4gICAgICAgIGF2Z1NjaWVudGlmaWNUaG91Z2h0ID0gMFxuICAgICAgICBhdmdUZWNobmljYWxTa2lsbHMgPSAwXG4gICAgICAgIGF2Z1ByZXNlbnRhdGlvbiA9IDBcbiAgICAgICAgcHJvamVjdEF2Z1Njb3JlID0gMFxuICAgICAgfVxuICAgICAgLy8gSWYgbm8ganVkZ2VzIHNjb3JlZCB0aGUgcHJvamVjdCAoanVkZ2VDb3VudCBhbmQgYWJzZW50Q291bnQgYXJlIDApLCBhbGwgYXZlcmFnZXMgcmVtYWluIDAgKGluaXRpYWxpemVkKVxuXG4gICAgICBwcm9qZWN0c0ZvclNjb3JlVGFiLnB1c2goe1xuICAgICAgICBwcm9qZWN0SWQ6IHBJZCxcbiAgICAgICAgcHJvamVjdFRpdGxlOiBwcm9qZWN0RGF0YS5wcm9qZWN0VGl0bGUsXG4gICAgICAgIHRoZW1lOiBwcm9qZWN0RGF0YS50aGVtZSxcbiAgICAgICAgYXZnQ3JlYXRpdml0eTogYXZnQ3JlYXRpdml0eSxcbiAgICAgICAgYXZnU2NpZW50aWZpY1Rob3VnaHQ6IGF2Z1NjaWVudGlmaWNUaG91Z2h0LFxuICAgICAgICBhdmdUZWNobmljYWxTa2lsbHM6IGF2Z1RlY2huaWNhbFNraWxscyxcbiAgICAgICAgYXZnUHJlc2VudGF0aW9uOiBhdmdQcmVzZW50YXRpb24sXG4gICAgICAgIHByb2plY3RBdmdTY29yZTogcHJvamVjdEF2Z1Njb3JlLFxuICAgICAgICBzdHVkZW50TmFtZXM6IHByb2plY3REYXRhLnN0dWRlbnROYW1lcy5qb2luKFwiLCBcIiksIC8vIEpvaW4gc3R1ZGVudCBuYW1lc1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBTb3J0IHByb2plY3RzIGZvciB0aGUgU2NvcmUgdGFiIGJ5IFByb2plY3QgSUQgZm9yIGNvbnNpc3RlbnQgb3JkZXJpbmdcbiAgICBwcm9qZWN0c0ZvclNjb3JlVGFiLnNvcnQoKGEsIGIpID0+IGEucHJvamVjdElkLmxvY2FsZUNvbXBhcmUoYi5wcm9qZWN0SWQpKVxuXG4gICAgcHJvamVjdHNGb3JTY29yZVRhYi5mb3JFYWNoKChwcm9qZWN0KSA9PiB7XG4gICAgICBzY29yZVRhYlJvd3MucHVzaChbXG4gICAgICAgIHByb2plY3QucHJvamVjdElkLFxuICAgICAgICBwcm9qZWN0LnByb2plY3RUaXRsZSxcbiAgICAgICAgcHJvamVjdC50aGVtZSxcbiAgICAgICAgcHJvamVjdC5hdmdDcmVhdGl2aXR5LnRvRml4ZWQoMiksXG4gICAgICAgIHByb2plY3QuYXZnU2NpZW50aWZpY1Rob3VnaHQudG9GaXhlZCgyKSxcbiAgICAgICAgcHJvamVjdC5hdmdUZWNobmljYWxTa2lsbHMudG9GaXhlZCgyKSxcbiAgICAgICAgcHJvamVjdC5hdmdQcmVzZW50YXRpb24udG9GaXhlZCgyKSxcbiAgICAgICAgcHJvamVjdC5wcm9qZWN0QXZnU2NvcmUudG9GaXhlZCgyKSxcbiAgICAgICAgcHJvamVjdC5zdHVkZW50TmFtZXMsXG4gICAgICBdKVxuICAgIH0pXG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIFByZXBhcmVkICR7c2NvcmVUYWJSb3dzLmxlbmd0aCAtIDF9IHJvd3MgZm9yIFwiU2NvcmVcIiB0YWIgKGV4Y2x1ZGluZyBoZWFkZXIpLmApXG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIEZpbmFsIHNjb3JlVGFiUm93cyBiZWZvcmUgd3JpdGluZzpgLCBzY29yZVRhYlJvd3MpXG5cbiAgICBjb25zdCBzY29yZVNoZWV0TmFtZSA9IFwiU2NvcmVcIlxuICAgIGF3YWl0IHRoaXMuZW5zdXJlU2hlZXRFeGlzdHMoY2xhc3NTcHJlYWRzaGVldElkLCBzY29yZVNoZWV0TmFtZSwgc2NvcmVUYWJSb3dzWzBdKSAvLyBQYXNzIGhlYWRlciBmb3IgY3JlYXRpb25cblxuICAgIC8vIENsZWFyIGV4aXN0aW5nIGNvbnRlbnQgYmVmb3JlIHdyaXRpbmcgbmV3IGRhdGEgKGV4Y2x1ZGluZyBoZWFkZXIpXG4gICAgYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5jbGVhcih7XG4gICAgICBzcHJlYWRzaGVldElkOiBjbGFzc1NwcmVhZHNoZWV0SWQsXG4gICAgICByYW5nZTogYCR7c2NvcmVTaGVldE5hbWV9IUEyOklgLCAvLyBDbGVhciBmcm9tIHJvdyAyIG9ud2FyZHMsIHVwIHRvIGNvbHVtbiBJXG4gICAgfSlcblxuICAgIC8vIFdyaXRlIG5ldyBkYXRhIChpbmNsdWRpbmcgaGVhZGVyKVxuICAgIGlmIChzY29yZVRhYlJvd3MubGVuZ3RoID4gMSkge1xuICAgICAgLy8gT25seSB1cGRhdGUgaWYgdGhlcmUncyBkYXRhIGJleW9uZCB0aGUgaGVhZGVyXG4gICAgICBhd2FpdCB0aGlzLnNoZWV0cy5zcHJlYWRzaGVldHMudmFsdWVzLnVwZGF0ZSh7XG4gICAgICAgIHNwcmVhZHNoZWV0SWQ6IGNsYXNzU3ByZWFkc2hlZXRJZCxcbiAgICAgICAgcmFuZ2U6IGAke3Njb3JlU2hlZXROYW1lfSFBMWAsIC8vIFN0YXJ0IGZyb20gQTEgdG8gaW5jbHVkZSBoZWFkZXJcbiAgICAgICAgdmFsdWVJbnB1dE9wdGlvbjogXCJVU0VSX0VOVEVSRURcIixcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICB2YWx1ZXM6IHNjb3JlVGFiUm93cyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFVwZGF0ZWQgXCJTY29yZVwiIHRhYiBmb3IgJHtjbGFzc05hbWV9IHdpdGggJHtzY29yZVRhYlJvd3MubGVuZ3RoIC0gMX0gcHJvamVjdCBhdmVyYWdlIGVudHJpZXMuYClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIE5vIHByb2plY3QgYXZlcmFnZSBzY29yZXMgdG8gd3JpdGUgdG8gXCJTY29yZVwiIHRhYi5gKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFRvcFByb2plY3RzKGNsYXNzTmFtZTogc3RyaW5nKTogUHJvbWlzZTxcbiAgICBBcnJheTx7XG4gICAgICBwcm9qZWN0SWQ6IHN0cmluZ1xuICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgIHRoZW1lOiBzdHJpbmdcbiAgICAgIHByb2plY3RBdmdTY29yZTogbnVtYmVyXG4gICAgICBzdGFuZGFyZDogc3RyaW5nXG4gICAgICByYW5rOiBudW1iZXJcbiAgICAgIHN0dWRlbnROYW1lczogc3RyaW5nXG4gICAgfT5cbiAgPiB7XG4gICAgY29uc3QgY2xhc3NDb25maWcgPSB0aGlzLmdldENsYXNzQ29uZmlnKGNsYXNzTmFtZSlcbiAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbmZpZ3VyYXRpb24gZm91bmQgZm9yIGNsYXNzOiAke2NsYXNzTmFtZX1gKVxuICAgIH1cblxuICAgIGNvbnN0IHNjb3JlU2hlZXROYW1lID0gXCJTY29yZVwiXG4gICAgY29uc3Qgc2NvcmVSYW5nZSA9IGAke3Njb3JlU2hlZXROYW1lfSFBOklgIC8vIFVwZGF0ZWQgcmFuZ2UgZm9yIG5ldyBTY29yZSB0YWIgY29sdW1uc1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldFNoZWV0RGF0YShjbGFzc0NvbmZpZy5pZCwgc2NvcmVSYW5nZSlcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBSZWFkIFwiU2NvcmVcIiB0YWIgZm9yIHRvcCBwcm9qZWN0cy4gUm93cyBmZXRjaGVkOiAke2RhdGEudmFsdWVzLmxlbmd0aH0uYClcblxuICAgICAgaWYgKCFkYXRhLnZhbHVlcyB8fCBkYXRhLnZhbHVlcy5sZW5ndGggPD0gMSkge1xuICAgICAgICAvLyBObyBkYXRhIG9yIG9ubHkgaGVhZGVyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBcIlNjb3JlXCIgdGFiIGlzIGVtcHR5IG9yIG9ubHkgaGFzIGhlYWRlci4gTm8gcHJvamVjdHMgdG8gcmFuay5gKVxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvamVjdHM6IEFycmF5PHtcbiAgICAgICAgcHJvamVjdElkOiBzdHJpbmdcbiAgICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgICAgdGhlbWU6IHN0cmluZ1xuICAgICAgICBwcm9qZWN0QXZnU2NvcmU6IG51bWJlclxuICAgICAgICBzdHVkZW50TmFtZXM6IHN0cmluZ1xuICAgICAgfT4gPSBbXVxuXG4gICAgICBkYXRhLnZhbHVlcy5zbGljZSgxKS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gcm93WzBdPy50cmltKCkgLy8gUHJvamVjdCBJRCBpcyBub3cgY29sdW1uIEFcbiAgICAgICAgY29uc3QgcHJvamVjdFRpdGxlID0gcm93WzFdPy50cmltKCkgLy8gUHJvamVjdCBUaXRsZSBpcyBub3cgY29sdW1uIEJcbiAgICAgICAgY29uc3QgdGhlbWUgPSByb3dbMl0/LnRyaW0oKSAvLyBUaGVtZSBpcyBub3cgY29sdW1uIENcbiAgICAgICAgY29uc3QgcHJvamVjdEF2Z1Njb3JlID0gTnVtYmVyLnBhcnNlRmxvYXQocm93WzddKSB8fCAwIC8vIFByb2plY3QgQXZlcmFnZSBTY29yZSBpcyBub3cgY29sdW1uIEggKGluZGV4IDcpXG4gICAgICAgIGNvbnN0IHN0dWRlbnROYW1lcyA9IHJvd1s4XT8udHJpbSgpIHx8IFwiXCIgLy8gU3R1ZGVudCBOYW1lcyBpcyBub3cgY29sdW1uIEkgKGluZGV4IDgpXG5cbiAgICAgICAgaWYgKHByb2plY3RJZCkge1xuICAgICAgICAgIHByb2plY3RzLnB1c2goe1xuICAgICAgICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQsXG4gICAgICAgICAgICBwcm9qZWN0VGl0bGU6IHByb2plY3RUaXRsZSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIHByb2plY3RBdmdTY29yZTogcHJvamVjdEF2Z1Njb3JlLFxuICAgICAgICAgICAgc3R1ZGVudE5hbWVzOiBzdHVkZW50TmFtZXMsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgWyR7Y2xhc3NOYW1lfV0gU2tpcHBpbmcgcm93IGluIFwiU2NvcmVcIiB0YWIgZm9yIHRvcCBwcm9qZWN0cyBkdWUgdG8gbWlzc2luZyBQcm9qZWN0IElEOiAke3Jvdy5qb2luKFwiLCBcIil9YCxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gUGFyc2VkICR7cHJvamVjdHMubGVuZ3RofSBwcm9qZWN0cyBmcm9tIFwiU2NvcmVcIiB0YWIuYClcblxuICAgICAgLy8gU29ydCBieSBwcm9qZWN0IGF2ZXJhZ2Ugc2NvcmUgZGVzY2VuZGluZ1xuICAgICAgcHJvamVjdHMuc29ydCgoYSwgYikgPT4gYi5wcm9qZWN0QXZnU2NvcmUgLSBhLnByb2plY3RBdmdTY29yZSlcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBQcm9qZWN0cyBzb3J0ZWQgYnkgYXZlcmFnZSBzY29yZS5gKVxuXG4gICAgICBjb25zdCB0b3BQcm9qZWN0czogQXJyYXk8e1xuICAgICAgICBwcm9qZWN0SWQ6IHN0cmluZ1xuICAgICAgICBwcm9qZWN0VGl0bGU6IHN0cmluZ1xuICAgICAgICB0aGVtZTogc3RyaW5nXG4gICAgICAgIHByb2plY3RBdmdTY29yZTogbnVtYmVyXG4gICAgICAgIHN0YW5kYXJkOiBzdHJpbmdcbiAgICAgICAgcmFuazogbnVtYmVyXG4gICAgICAgIHN0dWRlbnROYW1lczogc3RyaW5nXG4gICAgICB9PiA9IFtdXG4gICAgICBsZXQgY3VycmVudFJhbmsgPSAxXG4gICAgICBsZXQgcHJvamVjdHNBZGRlZCA9IDBcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9qZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcm9qZWN0ID0gcHJvamVjdHNbaV1cbiAgICAgICAgaWYgKHByb2plY3RzQWRkZWQgPCAzKSB7XG4gICAgICAgICAgdG9wUHJvamVjdHMucHVzaCh7IC4uLnByb2plY3QsIHN0YW5kYXJkOiBjbGFzc05hbWUsIHJhbms6IGN1cnJlbnRSYW5rIH0pXG4gICAgICAgICAgcHJvamVjdHNBZGRlZCsrXG4gICAgICAgIH0gZWxzZSBpZiAocHJvamVjdC5wcm9qZWN0QXZnU2NvcmUgPT09IHRvcFByb2plY3RzW3RvcFByb2plY3RzLmxlbmd0aCAtIDFdLnByb2plY3RBdmdTY29yZSkge1xuICAgICAgICAgIC8vIEhhbmRsZSB0aWVzIGZvciAzcmQgcGxhY2VcbiAgICAgICAgICB0b3BQcm9qZWN0cy5wdXNoKHsgLi4ucHJvamVjdCwgc3RhbmRhcmQ6IGNsYXNzTmFtZSwgcmFuazogY3VycmVudFJhbmsgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhayAvLyBTdG9wIGFmdGVyIHRvcCAzIChhbmQgdGllcylcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgcmFuayBmb3IgbmV4dCBkaXN0aW5jdCBzY29yZSwgb25seSBpZiBjdXJyZW50IHByb2plY3QncyBzY29yZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbGFzdCBhZGRlZCBwcm9qZWN0J3Mgc2NvcmVcbiAgICAgICAgaWYgKGkgPCBwcm9qZWN0cy5sZW5ndGggLSAxICYmIHByb2plY3RzW2kgKyAxXS5wcm9qZWN0QXZnU2NvcmUgPCBwcm9qZWN0LnByb2plY3RBdmdTY29yZSkge1xuICAgICAgICAgIGN1cnJlbnRSYW5rID0gdG9wUHJvamVjdHMubGVuZ3RoICsgMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gSWRlbnRpZmllZCAke3RvcFByb2plY3RzLmxlbmd0aH0gdG9wIHByb2plY3RzLmApXG4gICAgICByZXR1cm4gdG9wUHJvamVjdHNcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyB0b3AgcHJvamVjdHMgZm9yICR7Y2xhc3NOYW1lfTpgLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB0b3AgcHJvamVjdHMgZm9yICR7Y2xhc3NOYW1lfS5gKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUFkbWluU3VtbWFyeShcbiAgICBzdW1tYXJ5RGF0YTogQXJyYXk8e1xuICAgICAgc3RhbmRhcmQ6IHN0cmluZ1xuICAgICAgcmFuazogbnVtYmVyXG4gICAgICBwcm9qZWN0SWQ6IHN0cmluZ1xuICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgIHRoZW1lOiBzdHJpbmdcbiAgICAgIHByb2plY3RBdmdTY29yZTogbnVtYmVyXG4gICAgICBzdHVkZW50TmFtZXM6IHN0cmluZ1xuICAgIH0+LFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBhZG1pbk1hc3RlclNoZWV0SWQgPSBTUFJFQURTSEVFVF9DT05GSUcuQURNSU5fTUFTVEVSLmlkXG4gICAgY29uc3Qgc3VtbWFyeVNoZWV0TmFtZSA9IFwiU3VtbWFyeVwiXG4gICAgY29uc3Qgc3VtbWFyeUhlYWRlciA9IFtcbiAgICAgIFwiU3RhbmRhcmRcIixcbiAgICAgIFwiUmFua1wiLFxuICAgICAgXCJQcm9qZWN0IElEXCIsXG4gICAgICBcIlByb2plY3QgVGl0bGVcIixcbiAgICAgIFwiVGhlbWVcIixcbiAgICAgIFwiUHJvamVjdCBBdmcgU2NvcmVcIixcbiAgICAgIFwiU3R1ZGVudCBOYW1lc1wiLFxuICAgIF0gLy8gQWRkZWQgU3R1ZGVudCBOYW1lc1xuXG4gICAgYXdhaXQgdGhpcy5lbnN1cmVTaGVldEV4aXN0cyhhZG1pbk1hc3RlclNoZWV0SWQsIHN1bW1hcnlTaGVldE5hbWUsIHN1bW1hcnlIZWFkZXIpXG5cbiAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50IGluIFN1bW1hcnkgdGFiIChleGNsdWRpbmcgaGVhZGVyKVxuICAgIGF3YWl0IHRoaXMuc2hlZXRzLnNwcmVhZHNoZWV0cy52YWx1ZXMuY2xlYXIoe1xuICAgICAgc3ByZWFkc2hlZXRJZDogYWRtaW5NYXN0ZXJTaGVldElkLFxuICAgICAgcmFuZ2U6IGAke3N1bW1hcnlTaGVldE5hbWV9IUEyOkdgLCAvLyBVcGRhdGVkIHJhbmdlIGZvciBjbGVhcmluZyAoQS1HIGZvciA3IGNvbHVtbnMpXG4gICAgfSlcblxuICAgIGlmIChzdW1tYXJ5RGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiTm8gc3VtbWFyeSBkYXRhIHRvIGFwcGVuZCB0byBBZG1pbiBNYXN0ZXIgU2hlZXQuXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByb3dzVG9BcHBlbmQgPSBzdW1tYXJ5RGF0YS5tYXAoKGRhdGEpID0+IFtcbiAgICAgIGRhdGEuc3RhbmRhcmQsXG4gICAgICBkYXRhLnJhbmsudG9TdHJpbmcoKSxcbiAgICAgIGRhdGEucHJvamVjdElkLFxuICAgICAgZGF0YS5wcm9qZWN0VGl0bGUsXG4gICAgICBkYXRhLnRoZW1lLFxuICAgICAgZGF0YS5wcm9qZWN0QXZnU2NvcmUudG9GaXhlZCgyKSxcbiAgICAgIGRhdGEuc3R1ZGVudE5hbWVzLCAvLyBJbmNsdWRlIHN0dWRlbnQgbmFtZXNcbiAgICBdKVxuXG4gICAgYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5hcHBlbmQoe1xuICAgICAgc3ByZWFkc2hlZXRJZDogYWRtaW5NYXN0ZXJTaGVldElkLFxuICAgICAgcmFuZ2U6IGAke3N1bW1hcnlTaGVldE5hbWV9IUEyYCwgLy8gQXBwZW5kIHN0YXJ0aW5nIGZyb20gQTIgKGFmdGVyIGhlYWRlcilcbiAgICAgIHZhbHVlSW5wdXRPcHRpb246IFwiVVNFUl9FTlRFUkVEXCIsXG4gICAgICByZXNvdXJjZToge1xuICAgICAgICB2YWx1ZXM6IHJvd3NUb0FwcGVuZCxcbiAgICAgIH0sXG4gICAgfSlcbiAgICBjb25zb2xlLmxvZyhg4pyFIEFwcGVuZGVkICR7cm93c1RvQXBwZW5kLmxlbmd0aH0gcm93cyB0byBcIlN1bW1hcnlcIiB0YWIgaW4gQWRtaW4gTWFzdGVyIFNoZWV0LmApXG4gIH1cblxuICBnZXRDbGFzc0NvbmZpZyhjbGFzc05hbWU6IHN0cmluZyk6IENsYXNzQ29uZmlnIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gU1BSRUFEU0hFRVRfQ09ORklHLkNMQVNTRVNbY2xhc3NOYW1lIGFzIGtleW9mIHR5cGVvZiBTUFJFQURTSEVFVF9DT05GSUcuQ0xBU1NFU11cbiAgfVxuXG4gIGdldFNwcmVhZHNoZWV0SWQoY2xhc3NOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNsYXNzQ29uZmlnID0gdGhpcy5nZXRDbGFzc0NvbmZpZyhjbGFzc05hbWUpXG4gICAgcmV0dXJuIGNsYXNzQ29uZmlnPy5pZCB8fCBcIlwiXG4gIH1cblxuICAvLyBOZXcgZnVuY3Rpb24gdG8gdXBkYXRlIGEgY2xhc3MncyBzcHJlYWRzaGVldCBJRFxuICB1cGRhdGVDbGFzc1NwcmVhZHNoZWV0SWQoY2xhc3NOYW1lOiBzdHJpbmcsIG5ld0lkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoU1BSRUFEU0hFRVRfQ09ORklHLkNMQVNTRVNbY2xhc3NOYW1lIGFzIGtleW9mIHR5cGVvZiBTUFJFQURTSEVFVF9DT05GSUcuQ0xBU1NFU10pIHtcbiAgICAgIC8vIFVwZGF0ZSBpbi1tZW1vcnkgY29uZmlnXG4gICAgICBTUFJFQURTSEVFVF9DT05GSUcgPSB7XG4gICAgICAgIC4uLlNQUkVBRFNIRUVUX0NPTkZJRyxcbiAgICAgICAgQ0xBU1NFUzoge1xuICAgICAgICAgIC4uLlNQUkVBRFNIRUVUX0NPTkZJRy5DTEFTU0VTLFxuICAgICAgICAgIFtjbGFzc05hbWVdOiB7XG4gICAgICAgICAgICAuLi5TUFJFQURTSEVFVF9DT05GSUcuQ0xBU1NFU1tjbGFzc05hbWUgYXMga2V5b2YgdHlwZW9mIFNQUkVBRFNIRUVUX0NPTkZJRy5DTEFTU0VTXSxcbiAgICAgICAgICAgIGlkOiBuZXdJZCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfVxuICAgICAgLy8gUGVyc2lzdCB0byBmaWxlXG4gICAgICBjb25zdCBpZHMgPSBsb2FkQ2xhc3NTaGVldElkcygpXG4gICAgICBpZHNbY2xhc3NOYW1lXSA9IG5ld0lkXG4gICAgICBzYXZlQ2xhc3NTaGVldElkcyhpZHMpXG4gICAgICBjb25zb2xlLmxvZyhgW0JhY2tlbmQgU2ltdWxhdGlvbl0gVXBkYXRlZCBTUFJFQURTSEVFVF9DT05GSUcgZm9yICR7Y2xhc3NOYW1lfSB0byBJRDogJHtuZXdJZH0gYW5kIHBlcnNpc3RlZCB0byBmaWxlYClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBbQmFja2VuZCBTaW11bGF0aW9uXSBDbGFzcyAke2NsYXNzTmFtZX0gbm90IGZvdW5kIGluIFNQUkVBRFNIRUVUX0NPTkZJRy5gKVxuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgZ29vZ2xlU2hlZXRzU2VydmljZSA9IG5ldyBHb29nbGVTaGVldHNTZXJ2aWNlKClcbiJdLCJuYW1lcyI6WyJHb29nbGVBdXRoIiwiZ29vZ2xlIiwiZnMiLCJwYXRoIiwiQ0xBU1NfU0hFRVRfSURTX1BBVEgiLCJyZXNvbHZlIiwicHJvY2VzcyIsImN3ZCIsImxvYWRDbGFzc1NoZWV0SWRzIiwicmF3IiwicmVhZEZpbGVTeW5jIiwiSlNPTiIsInBhcnNlIiwic2F2ZUNsYXNzU2hlZXRJZHMiLCJpZHMiLCJ3cml0ZUZpbGVTeW5jIiwic3RyaW5naWZ5IiwiR09PR0xFX1NIRUVUU19DT05GSUciLCJzZXJ2aWNlQWNjb3VudEtleVBhdGgiLCJlbnYiLCJHT09HTEVfU0VSVklDRV9BQ0NPVU5UX0tFWV9QQVRIIiwic2NvcGVzIiwicGVyc2lzdGVkSWRzIiwiU1BSRUFEU0hFRVRfQ09ORklHIiwiQ1JFREVOVElBTFMiLCJpZCIsIkNSRURFTlRJQUxTX1NQUkVBRFNIRUVUX0lEIiwicmFuZ2UiLCJBRE1JTl9NQVNURVIiLCJBRE1JTl9NQVNURVJfU1BSRUFEU0hFRVRfSUQiLCJDTEFTU0VTIiwiYmFzZVNoZWV0IiwiR29vZ2xlU2hlZXRzU2VydmljZSIsImNvbnN0cnVjdG9yIiwiR09PR0xFX1NFUlZJQ0VfQUNDT1VOVF9LRVlfQkFTRTY0Iiwia2V5RGF0YSIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsImtleVBhdGgiLCJhdXRoIiwia2V5RmlsZSIsInNoZWV0cyIsInZlcnNpb24iLCJnZXRTaGVldERhdGEiLCJzcHJlYWRzaGVldElkIiwiY29uc29sZSIsImxvZyIsInJlc3BvbnNlIiwic3ByZWFkc2hlZXRzIiwidmFsdWVzIiwiZ2V0IiwiZGF0YSIsImVycm9yIiwiRXJyb3IiLCJiYXRjaEdldFNoZWV0RGF0YSIsInJhbmdlcyIsImJhdGNoR2V0IiwicmVzdWx0IiwidmFsdWVSYW5nZXMiLCJmb3JFYWNoIiwidmFsdWVSYW5nZSIsImdldENyZWRlbnRpYWxzIiwibGVuZ3RoIiwic2xpY2UiLCJtYXAiLCJyb3ciLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicm9sZSIsImZpbHRlciIsImNyZWQiLCJnZXRQcm9qZWN0SWRzIiwiY2xhc3NOYW1lIiwiY2xhc3NDb25maWciLCJnZXRDbGFzc0NvbmZpZyIsInByb2plY3RJZHMiLCJ0cmltIiwiU2V0IiwiZ2V0U3R1ZGVudHNCeVByb2plY3RJZCIsInByb2plY3RJZCIsInN0dWRlbnRzIiwic25vIiwic3R1ZGVudE5hbWUiLCJncmFkZSIsInByb2plY3RUaXRsZSIsInRoZW1lIiwic3R1ZGVudCIsImdldEp1ZGdlU2NvcmVzIiwianVkZ2VOYW1lIiwianVkZ2VTaGVldE5hbWUiLCJqdWRnZVJhbmdlIiwic2NvcmVzIiwiY3JlYXRpdml0eSIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJzY2llbnRpZmljVGhvdWdodCIsInRlY2huaWNhbFNraWxscyIsInByZXNlbnRhdGlvbiIsInN0YXR1cyIsInRoZW1lRml0Iiwic2NvcmUiLCJzYXZlSnVkZ2VTY29yZXMiLCJqdWRnZUhlYWRlclJvdyIsImVuc3VyZVNoZWV0RXhpc3RzIiwibmV3Um93cyIsImFwcGVuZCIsInZhbHVlSW5wdXRPcHRpb24iLCJyZXNvdXJjZSIsImdldEV4aXN0aW5nSnVkZ2VEYXRhIiwic2hlZXROYW1lIiwiaGVhZGVyUm93Iiwic3ByZWFkc2hlZXQiLCJmaWVsZHMiLCJzaGVldEV4aXN0cyIsInNvbWUiLCJzaGVldCIsInByb3BlcnRpZXMiLCJ0aXRsZSIsImJhdGNoVXBkYXRlIiwicmVxdWVzdHMiLCJhZGRTaGVldCIsImdldEFsbFNoZWV0VGl0bGVzIiwiZ2V0QWxsSnVkZ2VTaGVldE5hbWVzIiwiY2xhc3NTcHJlYWRzaGVldElkIiwiYWxsU2hlZXRUaXRsZXMiLCJzdGFydHNXaXRoIiwiZ2V0UHJvamVjdERldGFpbHNNYXAiLCJwcm9qZWN0TWFwIiwiTWFwIiwiaGFzIiwic2V0Iiwic3R1ZGVudE5hbWVzIiwiYWRkIiwicHJvY2Vzc0NsYXNzU2NvcmVzIiwicHJvamVjdERldGFpbHNNYXAiLCJzaXplIiwianVkZ2VTaGVldE5hbWVzIiwibGF0ZXN0UHJvamVjdFNjb3Jlc0J5SnVkZ2UiLCJqdWRnZVJhbmdlcyIsImJhdGNoRGF0YSIsInJlcGxhY2UiLCJzY29yZXNGb3JKdWRnZSIsInBJZCIsInByb2plY3RBZ2dyZWdhdGVkU2NvcmVzIiwiZGV0YWlscyIsImVudHJpZXMiLCJjcmVhdGl2aXR5U3VtIiwic2NpZW50aWZpY1Rob3VnaHRTdW0iLCJ0ZWNobmljYWxTa2lsbHNTdW0iLCJwcmVzZW50YXRpb25TdW0iLCJqdWRnZUNvdW50IiwiYWJzZW50Q291bnQiLCJBcnJheSIsInNvcnQiLCJqdWRnZVNjb3Jlc01hcCIsImtleXMiLCJmaXJzdFNjb3JlIiwid2FybiIsInNjb3JlVGFiUm93cyIsInB1c2giLCJwcm9qZWN0c0ZvclNjb3JlVGFiIiwicHJvamVjdERhdGEiLCJhdmdDcmVhdGl2aXR5IiwiYXZnU2NpZW50aWZpY1Rob3VnaHQiLCJhdmdUZWNobmljYWxTa2lsbHMiLCJhdmdQcmVzZW50YXRpb24iLCJwcm9qZWN0QXZnU2NvcmUiLCJqb2luIiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwicHJvamVjdCIsInRvRml4ZWQiLCJzY29yZVNoZWV0TmFtZSIsImNsZWFyIiwidXBkYXRlIiwiZ2V0VG9wUHJvamVjdHMiLCJzY29yZVJhbmdlIiwicHJvamVjdHMiLCJ0b3BQcm9qZWN0cyIsImN1cnJlbnRSYW5rIiwicHJvamVjdHNBZGRlZCIsImkiLCJzdGFuZGFyZCIsInJhbmsiLCJ1cGRhdGVBZG1pblN1bW1hcnkiLCJzdW1tYXJ5RGF0YSIsImFkbWluTWFzdGVyU2hlZXRJZCIsInN1bW1hcnlTaGVldE5hbWUiLCJzdW1tYXJ5SGVhZGVyIiwicm93c1RvQXBwZW5kIiwiZ2V0U3ByZWFkc2hlZXRJZCIsInVwZGF0ZUNsYXNzU3ByZWFkc2hlZXRJZCIsIm5ld0lkIiwiZ29vZ2xlU2hlZXRzU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/google-sheets.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/googleapis","vendor-chunks/google-auth-library","vendor-chunks/bignumber.js","vendor-chunks/googleapis-common","vendor-chunks/gaxios","vendor-chunks/qs","vendor-chunks/json-bigint","vendor-chunks/gtoken","vendor-chunks/google-logging-utils","vendor-chunks/gcp-metadata","vendor-chunks/object-inspect","vendor-chunks/get-intrinsic","vendor-chunks/jws","vendor-chunks/jwa","vendor-chunks/url-template","vendor-chunks/ecdsa-sig-formatter","vendor-chunks/base64-js","vendor-chunks/side-channel-list","vendor-chunks/extend","vendor-chunks/side-channel-weakmap","vendor-chunks/has-symbols","vendor-chunks/function-bind","vendor-chunks/side-channel-map","vendor-chunks/safe-buffer","vendor-chunks/side-channel","vendor-chunks/get-proto","vendor-chunks/call-bind-apply-helpers","vendor-chunks/buffer-equal-constant-time","vendor-chunks/dunder-proto","vendor-chunks/math-intrinsics","vendor-chunks/call-bound","vendor-chunks/es-errors","vendor-chunks/gopd","vendor-chunks/es-define-property","vendor-chunks/hasown","vendor-chunks/es-object-atoms"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fadmin%2Fprocess-scores%2Froute&page=%2Fapi%2Fadmin%2Fprocess-scores%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fadmin%2Fprocess-scores%2Froute.ts&appDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();