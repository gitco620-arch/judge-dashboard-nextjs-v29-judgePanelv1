"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/auth/route";
exports.ids = ["app/api/auth/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "http2":
/*!************************!*\
  !*** external "http2" ***!
  \************************/
/***/ ((module) => {

module.exports = require("http2");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("process");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "node:buffer":
/*!******************************!*\
  !*** external "node:buffer" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:buffer");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("node:fs");

/***/ }),

/***/ "node:http":
/*!****************************!*\
  !*** external "node:http" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:http");

/***/ }),

/***/ "node:https":
/*!*****************************!*\
  !*** external "node:https" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node:https");

/***/ }),

/***/ "node:net":
/*!***************************!*\
  !*** external "node:net" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("node:net");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:path");

/***/ }),

/***/ "node:process":
/*!*******************************!*\
  !*** external "node:process" ***!
  \*******************************/
/***/ ((module) => {

module.exports = require("node:process");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("node:stream/web");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("node:url");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:util");

/***/ }),

/***/ "node:zlib":
/*!****************************!*\
  !*** external "node:zlib" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fauth%2Froute&page=%2Fapi%2Fauth%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fauth%2Froute.ts&appDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fauth%2Froute&page=%2Fapi%2Fauth%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fauth%2Froute.ts&appDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_arunm_Downloads_judge_dashboard_nextjs_v29_judgePanelv1_app_api_auth_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/auth/route.ts */ \"(rsc)/./app/api/auth/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/auth/route\",\n        pathname: \"/api/auth\",\n        filename: \"route\",\n        bundlePath: \"app/api/auth/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\arunm\\\\Downloads\\\\judge-dashboard-nextjs-v29-judgePanelv1\\\\app\\\\api\\\\auth\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_arunm_Downloads_judge_dashboard_nextjs_v29_judgePanelv1_app_api_auth_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/auth/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZhdXRoJTJGcm91dGUmcGFnZT0lMkZhcGklMkZhdXRoJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGYXV0aCUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNhcnVubSU1Q0Rvd25sb2FkcyU1Q2p1ZGdlLWRhc2hib2FyZC1uZXh0anMtdjI5LWp1ZGdlUGFuZWx2MSU1Q2FwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9QyUzQSU1Q1VzZXJzJTVDYXJ1bm0lNUNEb3dubG9hZHMlNUNqdWRnZS1kYXNoYm9hcmQtbmV4dGpzLXYyOS1qdWRnZVBhbmVsdjEmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQzhDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8/ZmViNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFxhcnVubVxcXFxEb3dubG9hZHNcXFxcanVkZ2UtZGFzaGJvYXJkLW5leHRqcy12MjktanVkZ2VQYW5lbHYxXFxcXGFwcFxcXFxhcGlcXFxcYXV0aFxcXFxyb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvYXV0aC9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2F1dGhcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL2F1dGgvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxhcnVubVxcXFxEb3dubG9hZHNcXFxcanVkZ2UtZGFzaGJvYXJkLW5leHRqcy12MjktanVkZ2VQYW5lbHYxXFxcXGFwcFxcXFxhcGlcXFxcYXV0aFxcXFxyb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvYXV0aC9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fauth%2Froute&page=%2Fapi%2Fauth%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fauth%2Froute.ts&appDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/auth/route.ts":
/*!*******************************!*\
  !*** ./app/api/auth/route.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_google_sheets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/google-sheets */ \"(rsc)/./lib/google-sheets.ts\");\n\n\nasync function POST(request) {\n    console.log(\"API /api/auth called\");\n    try {\n        const { username, password } = await request.json();\n        if (!username || !password) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Username and password are required\"\n            }, {\n                status: 400\n            });\n        }\n        const sheetsService = new _lib_google_sheets__WEBPACK_IMPORTED_MODULE_1__.GoogleSheetsService();\n        const credentials = await sheetsService.getCredentials();\n        const user = credentials.find((cred)=>cred.username === username && cred.password === password);\n        if (user) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: true,\n                user: {\n                    username: user.username,\n                    role: user.role\n                }\n            });\n        } else {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Invalid username or password\"\n            }, {\n                status: 401\n            });\n        }\n    } catch (error) {\n        console.error(\"Authentication API error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error during authentication\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2F1dGgvcm91dGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBDO0FBQ2U7QUFFbEQsZUFBZUUsS0FBS0MsT0FBZ0I7SUFDekNDLFFBQVFDLEdBQUcsQ0FBQztJQUNaLElBQUk7UUFDRixNQUFNLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFLEdBQUcsTUFBTUosUUFBUUssSUFBSTtRQUVqRCxJQUFJLENBQUNGLFlBQVksQ0FBQ0MsVUFBVTtZQUMxQixPQUFPUCxxREFBWUEsQ0FBQ1EsSUFBSSxDQUFDO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQXFDLEdBQUc7Z0JBQUVDLFFBQVE7WUFBSTtRQUMxRztRQUVBLE1BQU1DLGdCQUFnQixJQUFJWCxtRUFBbUJBO1FBQzdDLE1BQU1ZLGNBQWMsTUFBTUQsY0FBY0UsY0FBYztRQUV0RCxNQUFNQyxPQUFPRixZQUFZRyxJQUFJLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS1gsUUFBUSxLQUFLQSxZQUFZVyxLQUFLVixRQUFRLEtBQUtBO1FBRXhGLElBQUlRLE1BQU07WUFDUixPQUFPZixxREFBWUEsQ0FBQ1EsSUFBSSxDQUFDO2dCQUFFQyxTQUFTO2dCQUFNTSxNQUFNO29CQUFFVCxVQUFVUyxLQUFLVCxRQUFRO29CQUFFWSxNQUFNSCxLQUFLRyxJQUFJO2dCQUFDO1lBQUU7UUFDL0YsT0FBTztZQUNMLE9BQU9sQixxREFBWUEsQ0FBQ1EsSUFBSSxDQUFDO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQStCLEdBQUc7Z0JBQUVDLFFBQVE7WUFBSTtRQUNwRztJQUNGLEVBQUUsT0FBT0QsT0FBTztRQUNkTixRQUFRTSxLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxPQUFPVixxREFBWUEsQ0FBQ1EsSUFBSSxDQUFDO1lBQUVDLFNBQVM7WUFBT0MsT0FBTztRQUFxQyxHQUFHO1lBQUVDLFFBQVE7UUFBSTtJQUMxRztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL2FwcC9hcGkvYXV0aC9yb3V0ZS50cz85ZWIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L3NlcnZlclwiXG5pbXBvcnQgeyBHb29nbGVTaGVldHNTZXJ2aWNlIH0gZnJvbSBcIkAvbGliL2dvb2dsZS1zaGVldHNcIlxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBSZXF1ZXN0KSB7XG4gIGNvbnNvbGUubG9nKFwiQVBJIC9hcGkvYXV0aCBjYWxsZWRcIik7XG4gIHRyeSB7XG4gICAgY29uc3QgeyB1c2VybmFtZSwgcGFzc3dvcmQgfSA9IGF3YWl0IHJlcXVlc3QuanNvbigpXG5cbiAgICBpZiAoIXVzZXJuYW1lIHx8ICFwYXNzd29yZCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIlVzZXJuYW1lIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWRcIiB9LCB7IHN0YXR1czogNDAwIH0pXG4gICAgfVxuXG4gICAgY29uc3Qgc2hlZXRzU2VydmljZSA9IG5ldyBHb29nbGVTaGVldHNTZXJ2aWNlKClcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGF3YWl0IHNoZWV0c1NlcnZpY2UuZ2V0Q3JlZGVudGlhbHMoKVxuXG4gICAgY29uc3QgdXNlciA9IGNyZWRlbnRpYWxzLmZpbmQoKGNyZWQpID0+IGNyZWQudXNlcm5hbWUgPT09IHVzZXJuYW1lICYmIGNyZWQucGFzc3dvcmQgPT09IHBhc3N3b3JkKVxuXG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IHN1Y2Nlc3M6IHRydWUsIHVzZXI6IHsgdXNlcm5hbWU6IHVzZXIudXNlcm5hbWUsIHJvbGU6IHVzZXIucm9sZSB9IH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnZhbGlkIHVzZXJuYW1lIG9yIHBhc3N3b3JkXCIgfSwgeyBzdGF0dXM6IDQwMSB9KVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQXV0aGVudGljYXRpb24gQVBJIGVycm9yOlwiLCBlcnJvcilcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiU2VydmVyIGVycm9yIGR1cmluZyBhdXRoZW50aWNhdGlvblwiIH0sIHsgc3RhdHVzOiA1MDAgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsIkdvb2dsZVNoZWV0c1NlcnZpY2UiLCJQT1NUIiwicmVxdWVzdCIsImNvbnNvbGUiLCJsb2ciLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwianNvbiIsInN1Y2Nlc3MiLCJlcnJvciIsInN0YXR1cyIsInNoZWV0c1NlcnZpY2UiLCJjcmVkZW50aWFscyIsImdldENyZWRlbnRpYWxzIiwidXNlciIsImZpbmQiLCJjcmVkIiwicm9sZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/auth/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/google-sheets.ts":
/*!******************************!*\
  !*** ./lib/google-sheets.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GOOGLE_SHEETS_CONFIG: () => (/* binding */ GOOGLE_SHEETS_CONFIG),\n/* harmony export */   GoogleSheetsService: () => (/* binding */ GoogleSheetsService),\n/* harmony export */   SPREADSHEET_CONFIG: () => (/* binding */ SPREADSHEET_CONFIG),\n/* harmony export */   googleSheetsService: () => (/* binding */ googleSheetsService)\n/* harmony export */ });\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var googleapis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! googleapis */ \"(rsc)/./node_modules/googleapis/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\nconst CLASS_SHEET_IDS_PATH = path__WEBPACK_IMPORTED_MODULE_2__.resolve(process.cwd(), \"lib/class-sheet-ids.json\");\nfunction loadClassSheetIds() {\n    try {\n        const raw = fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(CLASS_SHEET_IDS_PATH, \"utf-8\");\n        return JSON.parse(raw);\n    } catch  {\n        return {};\n    }\n}\nfunction saveClassSheetIds(ids) {\n    fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(CLASS_SHEET_IDS_PATH, JSON.stringify(ids, null, 2), \"utf-8\");\n}\n// Configuration for Google Sheets API\nconst GOOGLE_SHEETS_CONFIG = {\n    scopes: [\n        \"https://www.googleapis.com/auth/spreadsheets\"\n    ]\n};\n// Spreadsheet configurations - changed to 'let' to allow dynamic updates for demonstration\nconst persistedIds = loadClassSheetIds();\nlet SPREADSHEET_CONFIG = {\n    CREDENTIALS: {\n        id: process.env.CREDENTIALS_SPREADSHEET_ID || \"1juP3Eg24GYgOmFcxpNMfbUSXK4m7xTqzlN-Cw9ndYQc\",\n        range: \"Sheet1!A:C\"\n    },\n    ADMIN_MASTER: {\n        id: process.env.ADMIN_MASTER_SPREADSHEET_ID || \"1snk-FZaxyZbSu_Ww-oPnam8JxZ2RLg3etI5TBkr-T1A\"\n    },\n    CLASSES: {\n        \"Class 4\": {\n            id: persistedIds[\"Class 4\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 5\": {\n            id: persistedIds[\"Class 5\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 6\": {\n            id: persistedIds[\"Class 6\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 7\": {\n            id: persistedIds[\"Class 7\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 8\": {\n            id: persistedIds[\"Class 8\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 9\": {\n            id: persistedIds[\"Class 9\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 10\": {\n            id: persistedIds[\"Class 10\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 11\": {\n            id: persistedIds[\"Class 11\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        },\n        \"Class 12\": {\n            id: persistedIds[\"Class 12\"],\n            baseSheet: \"BaseSheet\",\n            range: \"Sheet1!A:F\"\n        }\n    }\n};\nclass GoogleSheetsService {\n    constructor(){\n        try {\n            const base64Key = process.env.GOOGLE_SERVICE_ACCOUNT_KEY_BASE64;\n            if (!base64Key) {\n                throw new Error(\"GOOGLE_SERVICE_ACCOUNT_KEY_BASE64 environment variable is not set. Please configure your service account key as a Base64 encoded string.\");\n            }\n            // Decode and write to a temp file in the OS temp directory\n            const keyData = Buffer.from(base64Key, \"base64\").toString(\"utf8\");\n            const tmpDir = os__WEBPACK_IMPORTED_MODULE_3__.tmpdir();\n            const keyPath = path__WEBPACK_IMPORTED_MODULE_2__.join(tmpDir, \"service-account-key.json\");\n            fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(keyPath, keyData);\n            this.auth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth({\n                keyFile: keyPath,\n                scopes: GOOGLE_SHEETS_CONFIG.scopes\n            });\n            this.sheets = googleapis__WEBPACK_IMPORTED_MODULE_4__.google.sheets({\n                version: \"v4\",\n                auth: this.auth\n            });\n            console.log(\"\\uD83D\\uDD17 Google Sheets API initialized with service account key from Base64.\");\n        } catch (err) {\n            console.error(\"âŒ Error initializing Google Sheets API:\", err);\n            throw err;\n        }\n    }\n    async getSheetData(spreadsheetId, range) {\n        try {\n            console.log(`ðŸ”— Fetching data from Google Sheets: ${spreadsheetId}, Range: ${range}`);\n            const response = await this.sheets.spreadsheets.values.get({\n                spreadsheetId,\n                range\n            });\n            return {\n                values: response.data.values || [],\n                range,\n                spreadsheetId\n            };\n        } catch (error) {\n            console.error(\"Error fetching sheet data:\", error);\n            throw new Error(`Failed to fetch data from spreadsheet ${spreadsheetId}. Please check permissions and spreadsheet ID.`);\n        }\n    }\n    async batchGetSheetData(spreadsheetId, ranges) {\n        try {\n            const response = await this.sheets.spreadsheets.values.batchGet({\n                spreadsheetId,\n                ranges\n            });\n            const result = {};\n            (response.data.valueRanges || []).forEach((valueRange)=>{\n                result[valueRange.range] = valueRange.values || [];\n            });\n            return result;\n        } catch (error) {\n            console.error(\"Error in batchGetSheetData:\", error);\n            throw new Error(`Failed to batch get data from spreadsheet ${spreadsheetId}.`);\n        }\n    }\n    async getCredentials() {\n        try {\n            const data = await this.getSheetData(SPREADSHEET_CONFIG.CREDENTIALS.id, SPREADSHEET_CONFIG.CREDENTIALS.range);\n            if (!data.values || data.values.length === 0) {\n                throw new Error(\"No credentials found in the spreadsheet\");\n            }\n            // Skip header row and map to credential objects\n            return data.values.slice(1).map((row)=>({\n                    username: row[0] || \"\",\n                    password: row[1] || \"\",\n                    role: row[2] || \"\"\n                })).filter((cred)=>cred.username && cred.password && cred.role);\n        } catch (error) {\n            console.error(\"Error fetching credentials:\", error);\n            throw new Error(\"Failed to fetch credentials from Google Sheets\");\n        }\n    }\n    async getProjectIds(className) {\n        try {\n            const classConfig = this.getClassConfig(className);\n            if (!classConfig) {\n                throw new Error(`No configuration found for class: ${className}`);\n            }\n            const data = await this.getSheetData(classConfig.id, classConfig.range);\n            if (!data.values || data.values.length === 0) {\n                return [];\n            }\n            // Skip header row and extract Project IDs from column E (index 4)\n            const projectIds = data.values.slice(1) // Skip header row\n            .map((row)=>row[4]) // Column E (Project ID) is at index 4\n            .filter((id)=>id && id.trim() !== \"\") // Remove empty cells\n            .map((id)=>id.trim()) // Clean whitespace\n            ;\n            // Return unique project IDs only\n            return [\n                ...new Set(projectIds)\n            ];\n        } catch (error) {\n            console.error(`Error fetching project IDs for ${className}:`, error);\n            throw new Error(`Failed to fetch project IDs for ${className} from Google Sheets`);\n        }\n    }\n    async getStudentsByProjectId(className, projectId) {\n        try {\n            const classConfig = this.getClassConfig(className);\n            if (!classConfig) {\n                throw new Error(`No configuration found for class: ${className}`);\n            }\n            const data = await this.getSheetData(classConfig.id, classConfig.range);\n            if (!data.values || data.values.length === 0) {\n                return [];\n            }\n            // Skip header row and filter by Project ID\n            const students = data.values.slice(1) // Skip header row\n            .filter((row)=>row[4] && row[4].trim() === projectId.trim()) // Filter by Project ID\n            .map((row)=>({\n                    sno: row[0] || \"\",\n                    studentName: row[1] || \"\",\n                    grade: row[2] || \"\",\n                    projectTitle: row[3] || \"\",\n                    projectId: row[4] || \"\",\n                    theme: row[5] || \"\"\n                })).filter((student)=>student.studentName && student.projectId);\n            return students;\n        } catch (error) {\n            console.error(`Error fetching students for project ${projectId}:`, error);\n            throw new Error(`Failed to fetch students for project ${projectId} from Google Sheets`);\n        }\n    }\n    async getJudgeScores(className, judgeName, projectId) {\n        try {\n            const classConfig = this.getClassConfig(className);\n            if (!classConfig) {\n                throw new Error(`No configuration found for class: ${className}`);\n            }\n            const judgeSheetName = `Judge_${judgeName}`;\n            const judgeRange = `${judgeSheetName}!A:K` // Updated range to include Theme Fit (assuming column K)\n            ;\n            try {\n                const data = await this.getSheetData(classConfig.id, judgeRange);\n                if (!data.values || data.values.length === 0) {\n                    return [];\n                }\n                // Skip header row and optionally filter by Project ID\n                let scores = data.values.slice(1) // Skip header row\n                .map((row)=>({\n                        sno: row[0] || \"\",\n                        studentName: row[1] || \"\",\n                        grade: row[2] || \"\",\n                        projectTitle: row[3] || \"\",\n                        projectId: row[4] || \"\",\n                        creativity: row[5] ? Number.parseFloat(row[5]) : null,\n                        scientificThought: row[6] ? Number.parseFloat(row[6]) : null,\n                        technicalSkills: row[7] ? Number.parseFloat(row[7]) : null,\n                        presentation: row[8] ? Number.parseFloat(row[8]) : null,\n                        status: row[9] || \"Present\",\n                        themeFit: row[10] || null\n                    }));\n                console.log(`ðŸ”— Fetched ${scores.length} scores from ${judgeSheetName} for class ${className}`);\n                // Filter by project ID if specified\n                if (projectId) {\n                    scores = scores.filter((score)=>score.projectId.trim() === projectId.trim());\n                }\n                return scores;\n            } catch (error) {\n                // Judge sheet doesn't exist yet or is empty, which is fine for initial fetch\n                console.log(`Judge sheet ${judgeSheetName} doesn't exist yet or is empty.`);\n                return [];\n            }\n        } catch (error) {\n            console.error(`Error fetching judge scores:`, error);\n            throw new Error(`Failed to fetch judge scores from Google Sheets`);\n        }\n    }\n    async saveJudgeScores(className, judgeName, scores) {\n        try {\n            const classConfig = this.getClassConfig(className);\n            if (!classConfig) {\n                throw new Error(`No configuration found for class: ${className}`);\n            }\n            const judgeSheetName = `Judge_${judgeName}`;\n            const judgeHeaderRow = [\n                \"S.No.\",\n                \"Name of the Student\",\n                \"Grade\",\n                \"Project Title\",\n                \"Project ID\",\n                \"Creativity & Imagination\",\n                \"Scientific Thought\",\n                \"Technical Skills\",\n                \"Presentation\",\n                \"Status\",\n                \"Theme Fit\"\n            ];\n            // Ensure judge sheet exists and has header\n            await this.ensureSheetExists(classConfig.id, judgeSheetName, judgeHeaderRow);\n            // Prepare new score rows for appending\n            const newRows = scores.map((score)=>[\n                    score.sno,\n                    score.studentName,\n                    score.grade,\n                    score.projectTitle,\n                    score.projectId,\n                    score.creativity?.toString() || \"\",\n                    score.scientificThought?.toString() || \"\",\n                    score.technicalSkills?.toString() || \"\",\n                    score.presentation?.toString() || \"\",\n                    score.status || \"Present\",\n                    score.themeFit || \"\"\n                ]);\n            // Append new scores (never overwrite)\n            await this.sheets.spreadsheets.values.append({\n                spreadsheetId: classConfig.id,\n                range: `${judgeSheetName}!A:K`,\n                valueInputOption: \"USER_ENTERED\",\n                resource: {\n                    values: newRows\n                }\n            });\n            console.log(`âœ… Appended ${newRows.length} new score rows to ${judgeSheetName}`);\n        } catch (error) {\n            console.error(`Error appending judge scores:`, error);\n            throw new Error(`Failed to append judge scores to Google Sheets`);\n        }\n    }\n    async getExistingJudgeData(spreadsheetId, sheetName) {\n        try {\n            const response = await this.sheets.spreadsheets.values.get({\n                spreadsheetId,\n                range: `${sheetName}!A:K`\n            });\n            return response.data.values || [];\n        } catch (error) {\n            // Sheet doesn't exist or is empty\n            return [];\n        }\n    }\n    async ensureSheetExists(spreadsheetId, sheetName, headerRow) {\n        try {\n            const spreadsheet = await this.sheets.spreadsheets.get({\n                spreadsheetId: spreadsheetId,\n                fields: \"sheets.properties.title,sheets.properties.sheetId\"\n            });\n            const sheetExists = spreadsheet.data.sheets?.some((sheet)=>sheet.properties.title === sheetName);\n            if (!sheetExists) {\n                await this.sheets.spreadsheets.batchUpdate({\n                    spreadsheetId: spreadsheetId,\n                    resource: {\n                        requests: [\n                            {\n                                addSheet: {\n                                    properties: {\n                                        title: sheetName\n                                    }\n                                }\n                            }\n                        ]\n                    }\n                });\n                console.log(`âœ… Created new sheet: ${sheetName} in spreadsheet ${spreadsheetId}`);\n                // If header row is provided, write it\n                if (headerRow && headerRow.length > 0) {\n                    await this.sheets.spreadsheets.values.append({\n                        spreadsheetId: spreadsheetId,\n                        range: `${sheetName}!A1`,\n                        valueInputOption: \"USER_ENTERED\",\n                        resource: {\n                            values: [\n                                headerRow\n                            ]\n                        }\n                    });\n                    console.log(`âœ… Added header to new sheet: ${sheetName}`);\n                }\n            }\n        } catch (error) {\n            console.error(`Error ensuring sheet ${sheetName} exists in ${spreadsheetId}:`, error);\n            throw new Error(`Failed to create or verify sheet: ${sheetName}`);\n        }\n    }\n    async getAllSheetTitles(spreadsheetId) {\n        try {\n            const response = await this.sheets.spreadsheets.get({\n                spreadsheetId: spreadsheetId,\n                fields: \"sheets.properties.title\"\n            });\n            return response.data.sheets?.map((sheet)=>sheet.properties.title) || [];\n        } catch (error) {\n            console.error(`Error fetching sheet titles for ${spreadsheetId}:`, error);\n            throw new Error(`Failed to fetch sheet titles for spreadsheet ${spreadsheetId}.`);\n        }\n    }\n    async getAllJudgeSheetNames(classSpreadsheetId) {\n        const allSheetTitles = await this.getAllSheetTitles(classSpreadsheetId);\n        return allSheetTitles.filter((title)=>title.startsWith(\"Judge_\"));\n    }\n    async getProjectDetailsMap(className) {\n        const classConfig = this.getClassConfig(className);\n        if (!classConfig) {\n            throw new Error(`No configuration found for class: ${className}`);\n        }\n        const data = await this.getSheetData(classConfig.id, classConfig.range) // Reads Sheet1!A:F\n        ;\n        const projectMap = new Map();\n        if (data.values && data.values.length > 1) {\n            // Skip header\n            data.values.slice(1).forEach((row)=>{\n                const projectId = row[4]?.trim() // Column E\n                ;\n                const projectTitle = row[3]?.trim() // Column D\n                ;\n                const theme = row[5]?.trim() // Column F\n                ;\n                const studentName = row[1]?.trim() // Column B\n                ;\n                if (projectId) {\n                    if (!projectMap.has(projectId)) {\n                        projectMap.set(projectId, {\n                            title: projectTitle || \"\",\n                            theme: theme || \"\",\n                            studentNames: new Set()\n                        });\n                    }\n                    if (studentName) {\n                        projectMap.get(projectId)?.studentNames.add(studentName);\n                    }\n                }\n            });\n        }\n        return projectMap;\n    }\n    async processClassScores(className) {\n        const classConfig = this.getClassConfig(className);\n        if (!classConfig) {\n            throw new Error(`No configuration found for class: ${className}`);\n        }\n        const classSpreadsheetId = classConfig.id;\n        const projectDetailsMap = await this.getProjectDetailsMap(className);\n        console.log(`[${className}] Found ${projectDetailsMap.size} unique projects from BaseSheet.`);\n        const judgeSheetNames = await this.getAllJudgeSheetNames(classSpreadsheetId);\n        console.log(`[${className}] Found ${judgeSheetNames.length} judge sheets.`);\n        // Map to store the latest score for each project by each judge\n        const latestProjectScoresByJudge = new Map() // projectId -> (judgeName -> latestScore)\n        ;\n        const judgeRanges = judgeSheetNames.map((judgeSheetName)=>`${judgeSheetName}!A:K`);\n        console.log(\"judgeRangeMAddy\");\n        console.log(`[${className}] Fetching data for judgeRangeMAddy sheets: ${judgeRanges}`);\n        const batchData = await this.batchGetSheetData(classSpreadsheetId, judgeRanges);\n        console.log(\"batchData:\", JSON.stringify(batchData, null, 2));\n        console.log(`[${className}] FetchedMaddy data for ${judgeRanges.length} ${judgeRanges} ${batchData} judge sheets in batch.`);\n        for (const judgeSheetName of judgeSheetNames){\n            console.log(`[${className}] Processing judge sheet maddy: ${judgeSheetName}`);\n            const judgeName = judgeSheetName.replace(\"Judge_\", \"\");\n            const values = batchData[`${judgeSheetName}!A1:K1000`] || [];\n            console.log(`[${className}] FoundMAddys ${values.length} rows in sheet ${judgeSheetName} for Judge ${judgeName}.`);\n            if (values.length <= 1) continue; // skip if only header or empty\n            // Parse scores as in getJudgeScores\n            const scoresForJudge = values.slice(1).map((row)=>({\n                    sno: row[0] || \"\",\n                    studentName: row[1] || \"\",\n                    grade: row[2] || \"\",\n                    projectTitle: row[3] || \"\",\n                    projectId: row[4] || \"\",\n                    creativity: row[5] ? Number.parseFloat(row[5]) : null,\n                    scientificThought: row[6] ? Number.parseFloat(row[6]) : null,\n                    technicalSkills: row[7] ? Number.parseFloat(row[7]) : null,\n                    presentation: row[8] ? Number.parseFloat(row[8]) : null,\n                    status: row[9] || \"Present\",\n                    themeFit: row[10] || null\n                }));\n            console.log(`[${className}] FoundMaddy ${scoresForJudge.length} scores for Judge ${judgeName} in sheet ${judgeSheetName}.`);\n            for (const score of scoresForJudge){\n                const pId = score.projectId.trim();\n                console.log(`[${className}] Processing score for Project ${pId} by Judge ${judgeName}:`, score);\n                if (!latestProjectScoresByJudge.has(pId)) {\n                    latestProjectScoresByJudge.set(pId, new Map());\n                }\n                latestProjectScoresByJudge.get(pId)?.set(judgeName, score);\n            }\n        }\n        console.log(`[${className}] Collected latest scores for projects from each judge.`);\n        console.log(`[${className}] latestProjectScoresByJudge for a sample project (e.g., P4001):`, latestProjectScoresByJudge.get(\"P4001\"));\n        // Aggregate scores per project\n        const projectAggregatedScores = {};\n        // Initialize projectAggregatedScores with details from BaseSheet\n        for (const [pId, details] of projectDetailsMap.entries()){\n            projectAggregatedScores[pId] = {\n                projectTitle: details.title,\n                theme: details.theme,\n                creativitySum: 0,\n                scientificThoughtSum: 0,\n                technicalSkillsSum: 0,\n                presentationSum: 0,\n                judgeCount: 0,\n                absentCount: 0,\n                studentNames: Array.from(details.studentNames).sort()\n            };\n        }\n        // Populate aggregated scores from judge submissions\n        for (const [pId, judgeScoresMap] of latestProjectScoresByJudge.entries()){\n            console.log(`[${className}] Processing scores for Project ${pId} from judges:`, Array.from(judgeScoresMap.keys()));\n            console.log(`[${className}] judgeScoresMap for Project ${pId} has ${judgeScoresMap.size} entries.`);\n            if (!projectAggregatedScores[pId]) {\n                // This project was scored but not found in BaseSheet (e.g., if BaseSheet is incomplete)\n                // Try to get details from the first score entry for this project\n                const firstScore = Array.from(judgeScoresMap.values())[0];\n                projectAggregatedScores[pId] = {\n                    projectTitle: firstScore?.projectTitle || \"\",\n                    theme: projectDetailsMap.get(pId)?.theme || \"\",\n                    creativitySum: 0,\n                    scientificThoughtSum: 0,\n                    technicalSkillsSum: 0,\n                    presentationSum: 0,\n                    judgeCount: 0,\n                    absentCount: 0,\n                    studentNames: []\n                };\n                console.warn(`[${className}] Project ${pId} found in judge sheets but not in BaseSheet. Student names might be incomplete.`);\n            }\n            for (const [judgeName, score] of judgeScoresMap.entries()){\n                if (score.status === \"Absent\") {\n                    console.log(`[${className}] Judge ${judgeName} marked Project ${pId} as Absent.`);\n                    projectAggregatedScores[pId].absentCount++;\n                } else {\n                    // Present\n                    console.log(`[${className}] Adding score for Project ${pId} by Judge ${judgeName}: Creativity=${score.creativity}, ScientificThought=${score.scientificThought}, TechnicalSkills=${score.technicalSkills}, Presentation=${score.presentation}`);\n                    projectAggregatedScores[pId].judgeCount++;\n                    projectAggregatedScores[pId].creativitySum += score.creativity || 0;\n                    projectAggregatedScores[pId].scientificThoughtSum += score.scientificThought || 0;\n                    projectAggregatedScores[pId].technicalSkillsSum += score.technicalSkills || 0;\n                    projectAggregatedScores[pId].presentationSum += score.presentation || 0;\n                }\n            }\n        }\n        console.log(`[${className}] Aggregation complete for project scores.`);\n        console.log(`[${className}] projectAggregatedScores for a sample project (e.g., P4001):`, projectAggregatedScores[\"P4001\"]);\n        // Calculate project averages and prepare rows for \"Score\" tab\n        const scoreTabRows = [];\n        scoreTabRows.push([\n            \"Project ID\",\n            \"Project Title\",\n            \"Theme\",\n            \"Avg Creativity\",\n            \"Avg Scientific Thought\",\n            \"Avg Technical Skills\",\n            \"Avg Presentation\",\n            \"Project Average Score\",\n            \"Student Names\"\n        ]) // New Header for Score tab\n        ;\n        const projectsForScoreTab = [];\n        for(const pId in projectAggregatedScores){\n            const projectData = projectAggregatedScores[pId];\n            let avgCreativity = 0;\n            let avgScientificThought = 0;\n            let avgTechnicalSkills = 0;\n            let avgPresentation = 0;\n            let projectAvgScore = 0;\n            if (projectData.judgeCount > 0) {\n                avgCreativity = projectData.creativitySum / projectData.judgeCount;\n                avgScientificThought = projectData.scientificThoughtSum / projectData.judgeCount;\n                avgTechnicalSkills = projectData.technicalSkillsSum / projectData.judgeCount;\n                avgPresentation = projectData.presentationSum / projectData.judgeCount;\n                projectAvgScore = (avgCreativity + avgScientificThought + avgTechnicalSkills + avgPresentation) / 4;\n            } else if (projectData.absentCount > 0 && projectData.judgeCount === 0) {\n                // All judges marked project absent, so all scores are 0\n                avgCreativity = 0;\n                avgScientificThought = 0;\n                avgTechnicalSkills = 0;\n                avgPresentation = 0;\n                projectAvgScore = 0;\n            }\n            // If no judges scored the project (judgeCount and absentCount are 0), all averages remain 0 (initialized)\n            projectsForScoreTab.push({\n                projectId: pId,\n                projectTitle: projectData.projectTitle,\n                theme: projectData.theme,\n                avgCreativity: avgCreativity,\n                avgScientificThought: avgScientificThought,\n                avgTechnicalSkills: avgTechnicalSkills,\n                avgPresentation: avgPresentation,\n                projectAvgScore: projectAvgScore,\n                studentNames: projectData.studentNames.join(\", \")\n            });\n        }\n        // Sort projects for the Score tab by Project ID for consistent ordering\n        projectsForScoreTab.sort((a, b)=>a.projectId.localeCompare(b.projectId));\n        projectsForScoreTab.forEach((project)=>{\n            scoreTabRows.push([\n                project.projectId,\n                project.projectTitle,\n                project.theme,\n                project.avgCreativity.toFixed(2),\n                project.avgScientificThought.toFixed(2),\n                project.avgTechnicalSkills.toFixed(2),\n                project.avgPresentation.toFixed(2),\n                project.projectAvgScore.toFixed(2),\n                project.studentNames\n            ]);\n        });\n        console.log(`[${className}] Prepared ${scoreTabRows.length - 1} rows for \"Score\" tab (excluding header).`);\n        console.log(`[${className}] Final scoreTabRows before writing:`, scoreTabRows);\n        const scoreSheetName = \"Score\";\n        await this.ensureSheetExists(classSpreadsheetId, scoreSheetName, scoreTabRows[0]) // Pass header for creation\n        ;\n        // Clear existing content before writing new data (excluding header)\n        await this.sheets.spreadsheets.values.clear({\n            spreadsheetId: classSpreadsheetId,\n            range: `${scoreSheetName}!A2:I`\n        });\n        // Write new data (including header)\n        if (scoreTabRows.length > 1) {\n            // Only update if there's data beyond the header\n            await this.sheets.spreadsheets.values.update({\n                spreadsheetId: classSpreadsheetId,\n                range: `${scoreSheetName}!A1`,\n                valueInputOption: \"USER_ENTERED\",\n                resource: {\n                    values: scoreTabRows\n                }\n            });\n            console.log(`âœ… Updated \"Score\" tab for ${className} with ${scoreTabRows.length - 1} project average entries.`);\n        } else {\n            console.log(`[${className}] No project average scores to write to \"Score\" tab.`);\n        }\n    }\n    async getTopProjects(className) {\n        const classConfig = this.getClassConfig(className);\n        if (!classConfig) {\n            throw new Error(`No configuration found for class: ${className}`);\n        }\n        const scoreSheetName = \"Score\";\n        const scoreRange = `${scoreSheetName}!A:I` // Updated range for new Score tab columns\n        ;\n        try {\n            const data = await this.getSheetData(classConfig.id, scoreRange);\n            console.log(`[${className}] Read \"Score\" tab for top projects. Rows fetched: ${data.values.length}.`);\n            if (!data.values || data.values.length <= 1) {\n                // No data or only header\n                console.log(`[${className}] \"Score\" tab is empty or only has header. No projects to rank.`);\n                return [];\n            }\n            const projects = [];\n            data.values.slice(1).forEach((row)=>{\n                const projectId = row[0]?.trim() // Project ID is now column A\n                ;\n                const projectTitle = row[1]?.trim() // Project Title is now column B\n                ;\n                const theme = row[2]?.trim() // Theme is now column C\n                ;\n                const projectAvgScore = Number.parseFloat(row[7]) || 0 // Project Average Score is now column H (index 7)\n                ;\n                const studentNames = row[8]?.trim() || \"\" // Student Names is now column I (index 8)\n                ;\n                if (projectId) {\n                    projects.push({\n                        projectId: projectId,\n                        projectTitle: projectTitle,\n                        theme: theme,\n                        projectAvgScore: projectAvgScore,\n                        studentNames: studentNames\n                    });\n                } else {\n                    console.warn(`[${className}] Skipping row in \"Score\" tab for top projects due to missing Project ID: ${row.join(\", \")}`);\n                }\n            });\n            console.log(`[${className}] Parsed ${projects.length} projects from \"Score\" tab.`);\n            // Sort by project average score descending\n            projects.sort((a, b)=>b.projectAvgScore - a.projectAvgScore);\n            console.log(`[${className}] Projects sorted by average score.`);\n            const topProjects = [];\n            let currentRank = 1;\n            let projectsAdded = 0;\n            for(let i = 0; i < projects.length; i++){\n                const project = projects[i];\n                if (projectsAdded < 3) {\n                    topProjects.push({\n                        ...project,\n                        standard: className,\n                        rank: currentRank\n                    });\n                    projectsAdded++;\n                } else if (project.projectAvgScore === topProjects[topProjects.length - 1].projectAvgScore) {\n                    // Handle ties for 3rd place\n                    topProjects.push({\n                        ...project,\n                        standard: className,\n                        rank: currentRank\n                    });\n                } else {\n                    break; // Stop after top 3 (and ties)\n                }\n                // Update rank for next distinct score, only if current project's score is different from the last added project's score\n                if (i < projects.length - 1 && projects[i + 1].projectAvgScore < project.projectAvgScore) {\n                    currentRank = topProjects.length + 1;\n                }\n            }\n            console.log(`[${className}] Identified ${topProjects.length} top projects.`);\n            return topProjects;\n        } catch (error) {\n            console.error(`Error getting top projects for ${className}:`, error);\n            throw new Error(`Failed to get top projects for ${className}.`);\n        }\n    }\n    async updateAdminSummary(summaryData) {\n        const adminMasterSheetId = SPREADSHEET_CONFIG.ADMIN_MASTER.id;\n        const summarySheetName = \"Summary\";\n        const summaryHeader = [\n            \"Standard\",\n            \"Rank\",\n            \"Project ID\",\n            \"Project Title\",\n            \"Theme\",\n            \"Project Avg Score\",\n            \"Student Names\"\n        ] // Added Student Names\n        ;\n        await this.ensureSheetExists(adminMasterSheetId, summarySheetName, summaryHeader);\n        // Clear existing content in Summary tab (excluding header)\n        await this.sheets.spreadsheets.values.clear({\n            spreadsheetId: adminMasterSheetId,\n            range: `${summarySheetName}!A2:G`\n        });\n        if (summaryData.length === 0) {\n            console.log(\"No summary data to append to Admin Master Sheet.\");\n            return;\n        }\n        const rowsToAppend = summaryData.map((data)=>[\n                data.standard,\n                data.rank.toString(),\n                data.projectId,\n                data.projectTitle,\n                data.theme,\n                data.projectAvgScore.toFixed(2),\n                data.studentNames\n            ]);\n        await this.sheets.spreadsheets.values.append({\n            spreadsheetId: adminMasterSheetId,\n            range: `${summarySheetName}!A2`,\n            valueInputOption: \"USER_ENTERED\",\n            resource: {\n                values: rowsToAppend\n            }\n        });\n        console.log(`âœ… Appended ${rowsToAppend.length} rows to \"Summary\" tab in Admin Master Sheet.`);\n    }\n    getClassConfig(className) {\n        return SPREADSHEET_CONFIG.CLASSES[className];\n    }\n    getSpreadsheetId(className) {\n        const classConfig = this.getClassConfig(className);\n        return classConfig?.id || \"\";\n    }\n    // New function to update a class's spreadsheet ID\n    updateClassSpreadsheetId(className, newId) {\n        if (SPREADSHEET_CONFIG.CLASSES[className]) {\n            // Update in-memory config\n            SPREADSHEET_CONFIG = {\n                ...SPREADSHEET_CONFIG,\n                CLASSES: {\n                    ...SPREADSHEET_CONFIG.CLASSES,\n                    [className]: {\n                        ...SPREADSHEET_CONFIG.CLASSES[className],\n                        id: newId\n                    }\n                }\n            };\n            // Persist to file\n            const ids = loadClassSheetIds();\n            ids[className] = newId;\n            saveClassSheetIds(ids);\n            console.log(`[Backend Simulation] Updated SPREADSHEET_CONFIG for ${className} to ID: ${newId} and persisted to file`);\n        } else {\n            console.warn(`[Backend Simulation] Class ${className} not found in SPREADSHEET_CONFIG.`);\n        }\n    }\n}\n// Export singleton instance\nconst googleSheetsService = new GoogleSheetsService();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvZ29vZ2xlLXNoZWV0cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDYjtBQUNYO0FBQ0k7QUFDSjtBQUV4QixNQUFNSyx1QkFBdUJGLHlDQUFZLENBQUNJLFFBQVFDLEdBQUcsSUFBSTtBQUV6RCxTQUFTQztJQUNQLElBQUk7UUFDRixNQUFNQyxNQUFNUiw0Q0FBZSxDQUFDRyxzQkFBc0I7UUFDbEQsT0FBT08sS0FBS0MsS0FBSyxDQUFDSDtJQUNwQixFQUFFLE9BQU07UUFDTixPQUFPLENBQUM7SUFDVjtBQUNGO0FBRUEsU0FBU0ksa0JBQWtCQyxHQUEyQjtJQUNwRGIsNkNBQWdCLENBQUNHLHNCQUFzQk8sS0FBS0ssU0FBUyxDQUFDRixLQUFLLE1BQU0sSUFBSTtBQUN2RTtBQTJDQSxzQ0FBc0M7QUFDL0IsTUFBTUcsdUJBQXVCO0lBQ2xDQyxRQUFRO1FBQUM7S0FBK0M7QUFDMUQsRUFBQztBQUVELDJGQUEyRjtBQUMzRixNQUFNQyxlQUFlWDtBQUNkLElBQUlZLHFCQUFxQjtJQUM5QkMsYUFBYTtRQUNYQyxJQUFJaEIsUUFBUWlCLEdBQUcsQ0FBQ0MsMEJBQTBCLElBQUk7UUFDOUNDLE9BQU87SUFDVDtJQUNBQyxjQUFjO1FBQ1pKLElBQUloQixRQUFRaUIsR0FBRyxDQUFDSSwyQkFBMkIsSUFBSTtJQUNqRDtJQUNBQyxTQUFTO1FBQ1AsV0FBVztZQUNUTixJQUFJSCxZQUFZLENBQUMsVUFBVTtZQUMzQlUsV0FBVztZQUNYSixPQUFPO1FBQ1Q7UUFDQSxXQUFXO1lBQ1RILElBQUlILFlBQVksQ0FBQyxVQUFVO1lBQzNCVSxXQUFXO1lBQ1hKLE9BQU87UUFDVDtRQUNBLFdBQVc7WUFDVEgsSUFBSUgsWUFBWSxDQUFDLFVBQVU7WUFDM0JVLFdBQVc7WUFDWEosT0FBTztRQUNUO1FBQ0EsV0FBVztZQUNUSCxJQUFJSCxZQUFZLENBQUMsVUFBVTtZQUMzQlUsV0FBVztZQUNYSixPQUFPO1FBQ1Q7UUFDQSxXQUFXO1lBQ1RILElBQUlILFlBQVksQ0FBQyxVQUFVO1lBQzNCVSxXQUFXO1lBQ1hKLE9BQU87UUFDVDtRQUNBLFdBQVc7WUFDVEgsSUFBSUgsWUFBWSxDQUFDLFVBQVU7WUFDM0JVLFdBQVc7WUFDWEosT0FBTztRQUNUO1FBQ0EsWUFBWTtZQUNWSCxJQUFJSCxZQUFZLENBQUMsV0FBVztZQUM1QlUsV0FBVztZQUNYSixPQUFPO1FBQ1Q7UUFDQSxZQUFZO1lBQ1ZILElBQUlILFlBQVksQ0FBQyxXQUFXO1lBQzVCVSxXQUFXO1lBQ1hKLE9BQU87UUFDVDtRQUNBLFlBQVk7WUFDVkgsSUFBSUgsWUFBWSxDQUFDLFdBQVc7WUFDNUJVLFdBQVc7WUFDWEosT0FBTztRQUNUO0lBQ0Y7QUFDRixFQUFDO0FBRU0sTUFBTUs7SUFJWEMsYUFBYztRQUNaLElBQUk7WUFDRixNQUFNQyxZQUFZMUIsUUFBUWlCLEdBQUcsQ0FBQ1UsaUNBQWlDO1lBQy9ELElBQUksQ0FBQ0QsV0FBVztnQkFDZCxNQUFNLElBQUlFLE1BQ1I7WUFFSjtZQUNBLDJEQUEyRDtZQUMzRCxNQUFNQyxVQUFVQyxPQUFPQyxJQUFJLENBQUNMLFdBQVcsVUFBVU0sUUFBUSxDQUFDO1lBQzFELE1BQU1DLFNBQVNwQyxzQ0FBUztZQUN4QixNQUFNc0MsVUFBVXZDLHNDQUFTLENBQUNxQyxRQUFRO1lBQ2xDdEMsNkNBQWdCLENBQUN3QyxTQUFTTjtZQUUxQixJQUFJLENBQUNRLElBQUksR0FBRyxJQUFJNUMsMkRBQVVBLENBQUM7Z0JBQ3pCNkMsU0FBU0g7Z0JBQ1R2QixRQUFRRCxxQkFBcUJDLE1BQU07WUFDckM7WUFDQSxJQUFJLENBQUMyQixNQUFNLEdBQUc3Qyw4Q0FBTUEsQ0FBQzZDLE1BQU0sQ0FBQztnQkFBRUMsU0FBUztnQkFBTUgsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFBQztZQUM3REksUUFBUUMsR0FBRyxDQUFDO1FBQ2QsRUFBRSxPQUFPQyxLQUFLO1lBQ1pGLFFBQVFHLEtBQUssQ0FBQywyQ0FBMkNEO1lBQ3pELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU1FLGFBQWFDLGFBQXFCLEVBQUUzQixLQUFhLEVBQXNCO1FBQzNFLElBQUk7WUFDRnNCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHFDQUFxQyxFQUFFSSxjQUFjLFNBQVMsRUFBRTNCLE1BQU0sQ0FBQztZQUVwRixNQUFNNEIsV0FBVyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxZQUFZLENBQUNDLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDO2dCQUN6REo7Z0JBQ0EzQjtZQUNGO1lBRUEsT0FBTztnQkFDTDhCLFFBQVFGLFNBQVNJLElBQUksQ0FBQ0YsTUFBTSxJQUFJLEVBQUU7Z0JBQ2xDOUI7Z0JBQ0EyQjtZQUNGO1FBQ0YsRUFBRSxPQUFPRixPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyw4QkFBOEJBO1lBQzVDLE1BQU0sSUFBSWhCLE1BQ1IsQ0FBQyxzQ0FBc0MsRUFBRWtCLGNBQWMsOENBQThDLENBQUM7UUFFMUc7SUFDRjtJQUVBLE1BQU1NLGtCQUFrQk4sYUFBcUIsRUFBRU8sTUFBZ0IsRUFBNEM7UUFDekcsSUFBSTtZQUNGLE1BQU1OLFdBQVcsTUFBTSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1MsWUFBWSxDQUFDQyxNQUFNLENBQUNLLFFBQVEsQ0FBQztnQkFDOURSO2dCQUNBTztZQUNGO1lBQ0EsTUFBTUUsU0FBMEMsQ0FBQztZQUMvQ1IsQ0FBQUEsU0FBU0ksSUFBSSxDQUFDSyxXQUFXLElBQUksRUFBRSxFQUFFQyxPQUFPLENBQUMsQ0FBQ0M7Z0JBQzFDSCxNQUFNLENBQUNHLFdBQVd2QyxLQUFLLENBQUMsR0FBR3VDLFdBQVdULE1BQU0sSUFBSSxFQUFFO1lBQ3BEO1lBQ0EsT0FBT007UUFDVCxFQUFFLE9BQU9YLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLCtCQUErQkE7WUFDN0MsTUFBTSxJQUFJaEIsTUFBTSxDQUFDLDBDQUEwQyxFQUFFa0IsY0FBYyxDQUFDLENBQUM7UUFDL0U7SUFDRjtJQUVBLE1BQU1hLGlCQUE2QztRQUNqRCxJQUFJO1lBQ0YsTUFBTVIsT0FBTyxNQUFNLElBQUksQ0FBQ04sWUFBWSxDQUFDL0IsbUJBQW1CQyxXQUFXLENBQUNDLEVBQUUsRUFBRUYsbUJBQW1CQyxXQUFXLENBQUNJLEtBQUs7WUFFNUcsSUFBSSxDQUFDZ0MsS0FBS0YsTUFBTSxJQUFJRSxLQUFLRixNQUFNLENBQUNXLE1BQU0sS0FBSyxHQUFHO2dCQUM1QyxNQUFNLElBQUloQyxNQUFNO1lBQ2xCO1lBRUEsZ0RBQWdEO1lBQ2hELE9BQU91QixLQUFLRixNQUFNLENBQ2ZZLEtBQUssQ0FBQyxHQUNOQyxHQUFHLENBQUMsQ0FBQ0MsTUFBUztvQkFDYkMsVUFBVUQsR0FBRyxDQUFDLEVBQUUsSUFBSTtvQkFDcEJFLFVBQVVGLEdBQUcsQ0FBQyxFQUFFLElBQUk7b0JBQ3BCRyxNQUFNSCxHQUFHLENBQUMsRUFBRSxJQUFJO2dCQUNsQixJQUNDSSxNQUFNLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS0osUUFBUSxJQUFJSSxLQUFLSCxRQUFRLElBQUlHLEtBQUtGLElBQUk7UUFDakUsRUFBRSxPQUFPdEIsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsK0JBQStCQTtZQUM3QyxNQUFNLElBQUloQixNQUFNO1FBQ2xCO0lBQ0Y7SUFFQSxNQUFNeUMsY0FBY0MsU0FBaUIsRUFBcUI7UUFDeEQsSUFBSTtZQUNGLE1BQU1DLGNBQWMsSUFBSSxDQUFDQyxjQUFjLENBQUNGO1lBRXhDLElBQUksQ0FBQ0MsYUFBYTtnQkFDaEIsTUFBTSxJQUFJM0MsTUFBTSxDQUFDLGtDQUFrQyxFQUFFMEMsVUFBVSxDQUFDO1lBQ2xFO1lBRUEsTUFBTW5CLE9BQU8sTUFBTSxJQUFJLENBQUNOLFlBQVksQ0FBQzBCLFlBQVl2RCxFQUFFLEVBQUV1RCxZQUFZcEQsS0FBSztZQUV0RSxJQUFJLENBQUNnQyxLQUFLRixNQUFNLElBQUlFLEtBQUtGLE1BQU0sQ0FBQ1csTUFBTSxLQUFLLEdBQUc7Z0JBQzVDLE9BQU8sRUFBRTtZQUNYO1lBRUEsa0VBQWtFO1lBQ2xFLE1BQU1hLGFBQWF0QixLQUFLRixNQUFNLENBQzNCWSxLQUFLLENBQUMsR0FBRyxrQkFBa0I7YUFDM0JDLEdBQUcsQ0FBQyxDQUFDQyxNQUFRQSxHQUFHLENBQUMsRUFBRSxFQUFFLHNDQUFzQzthQUMzREksTUFBTSxDQUFDLENBQUNuRCxLQUFPQSxNQUFNQSxHQUFHMEQsSUFBSSxPQUFPLElBQUkscUJBQXFCO2FBQzVEWixHQUFHLENBQUMsQ0FBQzlDLEtBQU9BLEdBQUcwRCxJQUFJLElBQUksbUJBQW1COztZQUU3QyxpQ0FBaUM7WUFDakMsT0FBTzttQkFBSSxJQUFJQyxJQUFJRjthQUFZO1FBQ2pDLEVBQUUsT0FBTzdCLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLENBQUMsK0JBQStCLEVBQUUwQixVQUFVLENBQUMsQ0FBQyxFQUFFMUI7WUFDOUQsTUFBTSxJQUFJaEIsTUFBTSxDQUFDLGdDQUFnQyxFQUFFMEMsVUFBVSxtQkFBbUIsQ0FBQztRQUNuRjtJQUNGO0lBRUEsTUFBTU0sdUJBQXVCTixTQUFpQixFQUFFTyxTQUFpQixFQUE2QjtRQUM1RixJQUFJO1lBQ0YsTUFBTU4sY0FBYyxJQUFJLENBQUNDLGNBQWMsQ0FBQ0Y7WUFFeEMsSUFBSSxDQUFDQyxhQUFhO2dCQUNoQixNQUFNLElBQUkzQyxNQUFNLENBQUMsa0NBQWtDLEVBQUUwQyxVQUFVLENBQUM7WUFDbEU7WUFFQSxNQUFNbkIsT0FBTyxNQUFNLElBQUksQ0FBQ04sWUFBWSxDQUFDMEIsWUFBWXZELEVBQUUsRUFBRXVELFlBQVlwRCxLQUFLO1lBRXRFLElBQUksQ0FBQ2dDLEtBQUtGLE1BQU0sSUFBSUUsS0FBS0YsTUFBTSxDQUFDVyxNQUFNLEtBQUssR0FBRztnQkFDNUMsT0FBTyxFQUFFO1lBQ1g7WUFFQSwyQ0FBMkM7WUFDM0MsTUFBTWtCLFdBQVczQixLQUFLRixNQUFNLENBQ3pCWSxLQUFLLENBQUMsR0FBRyxrQkFBa0I7YUFDM0JNLE1BQU0sQ0FBQyxDQUFDSixNQUFRQSxHQUFHLENBQUMsRUFBRSxJQUFJQSxHQUFHLENBQUMsRUFBRSxDQUFDVyxJQUFJLE9BQU9HLFVBQVVILElBQUksSUFBSSx1QkFBdUI7YUFDckZaLEdBQUcsQ0FBQyxDQUFDQyxNQUFTO29CQUNiZ0IsS0FBS2hCLEdBQUcsQ0FBQyxFQUFFLElBQUk7b0JBQ2ZpQixhQUFhakIsR0FBRyxDQUFDLEVBQUUsSUFBSTtvQkFDdkJrQixPQUFPbEIsR0FBRyxDQUFDLEVBQUUsSUFBSTtvQkFDakJtQixjQUFjbkIsR0FBRyxDQUFDLEVBQUUsSUFBSTtvQkFDeEJjLFdBQVdkLEdBQUcsQ0FBQyxFQUFFLElBQUk7b0JBQ3JCb0IsT0FBT3BCLEdBQUcsQ0FBQyxFQUFFLElBQUk7Z0JBQ25CLElBQ0NJLE1BQU0sQ0FBQyxDQUFDaUIsVUFBWUEsUUFBUUosV0FBVyxJQUFJSSxRQUFRUCxTQUFTO1lBRS9ELE9BQU9DO1FBQ1QsRUFBRSxPQUFPbEMsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsQ0FBQyxvQ0FBb0MsRUFBRWlDLFVBQVUsQ0FBQyxDQUFDLEVBQUVqQztZQUNuRSxNQUFNLElBQUloQixNQUFNLENBQUMscUNBQXFDLEVBQUVpRCxVQUFVLG1CQUFtQixDQUFDO1FBQ3hGO0lBQ0Y7SUFFQSxNQUFNUSxlQUFlZixTQUFpQixFQUFFZ0IsU0FBaUIsRUFBRVQsU0FBa0IsRUFBeUI7UUFDcEcsSUFBSTtZQUNGLE1BQU1OLGNBQWMsSUFBSSxDQUFDQyxjQUFjLENBQUNGO1lBQ3hDLElBQUksQ0FBQ0MsYUFBYTtnQkFDaEIsTUFBTSxJQUFJM0MsTUFBTSxDQUFDLGtDQUFrQyxFQUFFMEMsVUFBVSxDQUFDO1lBQ2xFO1lBRUEsTUFBTWlCLGlCQUFpQixDQUFDLE1BQU0sRUFBRUQsVUFBVSxDQUFDO1lBQzNDLE1BQU1FLGFBQWEsQ0FBQyxFQUFFRCxlQUFlLElBQUksQ0FBQyxDQUFDLHlEQUF5RDs7WUFFcEcsSUFBSTtnQkFDRixNQUFNcEMsT0FBTyxNQUFNLElBQUksQ0FBQ04sWUFBWSxDQUFDMEIsWUFBWXZELEVBQUUsRUFBRXdFO2dCQUVyRCxJQUFJLENBQUNyQyxLQUFLRixNQUFNLElBQUlFLEtBQUtGLE1BQU0sQ0FBQ1csTUFBTSxLQUFLLEdBQUc7b0JBQzVDLE9BQU8sRUFBRTtnQkFDWDtnQkFFQSxzREFBc0Q7Z0JBQ3RELElBQUk2QixTQUFTdEMsS0FBS0YsTUFBTSxDQUNyQlksS0FBSyxDQUFDLEdBQUcsa0JBQWtCO2lCQUMzQkMsR0FBRyxDQUFDLENBQUNDLE1BQVM7d0JBQ2JnQixLQUFLaEIsR0FBRyxDQUFDLEVBQUUsSUFBSTt3QkFDZmlCLGFBQWFqQixHQUFHLENBQUMsRUFBRSxJQUFJO3dCQUN2QmtCLE9BQU9sQixHQUFHLENBQUMsRUFBRSxJQUFJO3dCQUNqQm1CLGNBQWNuQixHQUFHLENBQUMsRUFBRSxJQUFJO3dCQUN4QmMsV0FBV2QsR0FBRyxDQUFDLEVBQUUsSUFBSTt3QkFDckIyQixZQUFZM0IsR0FBRyxDQUFDLEVBQUUsR0FBRzRCLE9BQU9DLFVBQVUsQ0FBQzdCLEdBQUcsQ0FBQyxFQUFFLElBQUk7d0JBQ2pEOEIsbUJBQW1COUIsR0FBRyxDQUFDLEVBQUUsR0FBRzRCLE9BQU9DLFVBQVUsQ0FBQzdCLEdBQUcsQ0FBQyxFQUFFLElBQUk7d0JBQ3hEK0IsaUJBQWlCL0IsR0FBRyxDQUFDLEVBQUUsR0FBRzRCLE9BQU9DLFVBQVUsQ0FBQzdCLEdBQUcsQ0FBQyxFQUFFLElBQUk7d0JBQ3REZ0MsY0FBY2hDLEdBQUcsQ0FBQyxFQUFFLEdBQUc0QixPQUFPQyxVQUFVLENBQUM3QixHQUFHLENBQUMsRUFBRSxJQUFJO3dCQUNuRGlDLFFBQVFqQyxHQUFHLENBQUMsRUFBRSxJQUFJO3dCQUNsQmtDLFVBQVVsQyxHQUFHLENBQUMsR0FBRyxJQUFJO29CQUN2QjtnQkFFQXRCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRStDLE9BQU83QixNQUFNLENBQUMsYUFBYSxFQUFFMkIsZUFBZSxXQUFXLEVBQUVqQixVQUFVLENBQUM7Z0JBRWhHLG9DQUFvQztnQkFDcEMsSUFBSU8sV0FBVztvQkFDYlksU0FBU0EsT0FBT3RCLE1BQU0sQ0FBQyxDQUFDK0IsUUFBVUEsTUFBTXJCLFNBQVMsQ0FBQ0gsSUFBSSxPQUFPRyxVQUFVSCxJQUFJO2dCQUM3RTtnQkFFQSxPQUFPZTtZQUNULEVBQUUsT0FBTzdDLE9BQU87Z0JBQ2QsNkVBQTZFO2dCQUM3RUgsUUFBUUMsR0FBRyxDQUFDLENBQUMsWUFBWSxFQUFFNkMsZUFBZSwrQkFBK0IsQ0FBQztnQkFDMUUsT0FBTyxFQUFFO1lBQ1g7UUFDRixFQUFFLE9BQU8zQyxPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyxDQUFDLDRCQUE0QixDQUFDLEVBQUVBO1lBQzlDLE1BQU0sSUFBSWhCLE1BQU0sQ0FBQywrQ0FBK0MsQ0FBQztRQUNuRTtJQUNGO0lBRUEsTUFBTXVFLGdCQUFnQjdCLFNBQWlCLEVBQUVnQixTQUFpQixFQUFFRyxNQUFvQixFQUFpQjtRQUMvRixJQUFJO1lBQ0YsTUFBTWxCLGNBQWMsSUFBSSxDQUFDQyxjQUFjLENBQUNGO1lBQ3hDLElBQUksQ0FBQ0MsYUFBYTtnQkFDaEIsTUFBTSxJQUFJM0MsTUFBTSxDQUFDLGtDQUFrQyxFQUFFMEMsVUFBVSxDQUFDO1lBQ2xFO1lBRUEsTUFBTWlCLGlCQUFpQixDQUFDLE1BQU0sRUFBRUQsVUFBVSxDQUFDO1lBQzNDLE1BQU1jLGlCQUFpQjtnQkFDckI7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRDtZQUVELDJDQUEyQztZQUMzQyxNQUFNLElBQUksQ0FBQ0MsaUJBQWlCLENBQUM5QixZQUFZdkQsRUFBRSxFQUFFdUUsZ0JBQWdCYTtZQUU3RCx1Q0FBdUM7WUFDdkMsTUFBTUUsVUFBVWIsT0FBTzNCLEdBQUcsQ0FBQyxDQUFDb0MsUUFBVTtvQkFDcENBLE1BQU1uQixHQUFHO29CQUNUbUIsTUFBTWxCLFdBQVc7b0JBQ2pCa0IsTUFBTWpCLEtBQUs7b0JBQ1hpQixNQUFNaEIsWUFBWTtvQkFDbEJnQixNQUFNckIsU0FBUztvQkFDZnFCLE1BQU1SLFVBQVUsRUFBRTFELGNBQWM7b0JBQ2hDa0UsTUFBTUwsaUJBQWlCLEVBQUU3RCxjQUFjO29CQUN2Q2tFLE1BQU1KLGVBQWUsRUFBRTlELGNBQWM7b0JBQ3JDa0UsTUFBTUgsWUFBWSxFQUFFL0QsY0FBYztvQkFDbENrRSxNQUFNRixNQUFNLElBQUk7b0JBQ2hCRSxNQUFNRCxRQUFRLElBQUk7aUJBQ25CO1lBRUQsc0NBQXNDO1lBQ3RDLE1BQU0sSUFBSSxDQUFDMUQsTUFBTSxDQUFDUyxZQUFZLENBQUNDLE1BQU0sQ0FBQ3NELE1BQU0sQ0FBQztnQkFDM0N6RCxlQUFleUIsWUFBWXZELEVBQUU7Z0JBQzdCRyxPQUFPLENBQUMsRUFBRW9FLGVBQWUsSUFBSSxDQUFDO2dCQUM5QmlCLGtCQUFrQjtnQkFDbEJDLFVBQVU7b0JBQ1J4RCxRQUFRcUQ7Z0JBQ1Y7WUFDRjtZQUVBN0QsUUFBUUMsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFNEQsUUFBUTFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRTJCLGVBQWUsQ0FBQztRQUNoRixFQUFFLE9BQU8zQyxPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyxDQUFDLDZCQUE2QixDQUFDLEVBQUVBO1lBQy9DLE1BQU0sSUFBSWhCLE1BQU0sQ0FBQyw4Q0FBOEMsQ0FBQztRQUNsRTtJQUNGO0lBRUEsTUFBYzhFLHFCQUFxQjVELGFBQXFCLEVBQUU2RCxTQUFpQixFQUF1QjtRQUNoRyxJQUFJO1lBQ0YsTUFBTTVELFdBQVcsTUFBTSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1MsWUFBWSxDQUFDQyxNQUFNLENBQUNDLEdBQUcsQ0FBQztnQkFDekRKO2dCQUNBM0IsT0FBTyxDQUFDLEVBQUV3RixVQUFVLElBQUksQ0FBQztZQUMzQjtZQUNBLE9BQU81RCxTQUFTSSxJQUFJLENBQUNGLE1BQU0sSUFBSSxFQUFFO1FBQ25DLEVBQUUsT0FBT0wsT0FBTztZQUNkLGtDQUFrQztZQUNsQyxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsTUFBY3lELGtCQUFrQnZELGFBQXFCLEVBQUU2RCxTQUFpQixFQUFFQyxTQUFvQixFQUFpQjtRQUM3RyxJQUFJO1lBQ0YsTUFBTUMsY0FBYyxNQUFNLElBQUksQ0FBQ3RFLE1BQU0sQ0FBQ1MsWUFBWSxDQUFDRSxHQUFHLENBQUM7Z0JBQ3JESixlQUFlQTtnQkFDZmdFLFFBQVE7WUFDVjtZQUVBLE1BQU1DLGNBQWNGLFlBQVkxRCxJQUFJLENBQUNaLE1BQU0sRUFBRXlFLEtBQUssQ0FBQ0MsUUFBZUEsTUFBTUMsVUFBVSxDQUFDQyxLQUFLLEtBQUtSO1lBRTdGLElBQUksQ0FBQ0ksYUFBYTtnQkFDaEIsTUFBTSxJQUFJLENBQUN4RSxNQUFNLENBQUNTLFlBQVksQ0FBQ29FLFdBQVcsQ0FBQztvQkFDekN0RSxlQUFlQTtvQkFDZjJELFVBQVU7d0JBQ1JZLFVBQVU7NEJBQ1I7Z0NBQ0VDLFVBQVU7b0NBQ1JKLFlBQVk7d0NBQ1ZDLE9BQU9SO29DQUNUO2dDQUNGOzRCQUNGO3lCQUNEO29CQUNIO2dCQUNGO2dCQUNBbEUsUUFBUUMsR0FBRyxDQUFDLENBQUMscUJBQXFCLEVBQUVpRSxVQUFVLGdCQUFnQixFQUFFN0QsY0FBYyxDQUFDO2dCQUUvRSxzQ0FBc0M7Z0JBQ3RDLElBQUk4RCxhQUFhQSxVQUFVaEQsTUFBTSxHQUFHLEdBQUc7b0JBQ3JDLE1BQU0sSUFBSSxDQUFDckIsTUFBTSxDQUFDUyxZQUFZLENBQUNDLE1BQU0sQ0FBQ3NELE1BQU0sQ0FBQzt3QkFDM0N6RCxlQUFlQTt3QkFDZjNCLE9BQU8sQ0FBQyxFQUFFd0YsVUFBVSxHQUFHLENBQUM7d0JBQ3hCSCxrQkFBa0I7d0JBQ2xCQyxVQUFVOzRCQUNSeEQsUUFBUTtnQ0FBQzJEOzZCQUFVO3dCQUNyQjtvQkFDRjtvQkFDQW5FLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDZCQUE2QixFQUFFaUUsVUFBVSxDQUFDO2dCQUN6RDtZQUNGO1FBQ0YsRUFBRSxPQUFPL0QsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsQ0FBQyxxQkFBcUIsRUFBRStELFVBQVUsV0FBVyxFQUFFN0QsY0FBYyxDQUFDLENBQUMsRUFBRUY7WUFDL0UsTUFBTSxJQUFJaEIsTUFBTSxDQUFDLGtDQUFrQyxFQUFFK0UsVUFBVSxDQUFDO1FBQ2xFO0lBQ0Y7SUFFQSxNQUFNWSxrQkFBa0J6RSxhQUFxQixFQUFxQjtRQUNoRSxJQUFJO1lBQ0YsTUFBTUMsV0FBVyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxZQUFZLENBQUNFLEdBQUcsQ0FBQztnQkFDbERKLGVBQWVBO2dCQUNmZ0UsUUFBUTtZQUNWO1lBQ0EsT0FBTy9ELFNBQVNJLElBQUksQ0FBQ1osTUFBTSxFQUFFdUIsSUFBSSxDQUFDbUQsUUFBZUEsTUFBTUMsVUFBVSxDQUFDQyxLQUFLLEtBQUssRUFBRTtRQUNoRixFQUFFLE9BQU92RSxPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyxDQUFDLGdDQUFnQyxFQUFFRSxjQUFjLENBQUMsQ0FBQyxFQUFFRjtZQUNuRSxNQUFNLElBQUloQixNQUFNLENBQUMsNkNBQTZDLEVBQUVrQixjQUFjLENBQUMsQ0FBQztRQUNsRjtJQUNGO0lBRUEsTUFBTTBFLHNCQUFzQkMsa0JBQTBCLEVBQXFCO1FBQ3pFLE1BQU1DLGlCQUFpQixNQUFNLElBQUksQ0FBQ0gsaUJBQWlCLENBQUNFO1FBQ3BELE9BQU9DLGVBQWV2RCxNQUFNLENBQUMsQ0FBQ2dELFFBQVVBLE1BQU1RLFVBQVUsQ0FBQztJQUMzRDtJQUVBLE1BQU1DLHFCQUNKdEQsU0FBaUIsRUFDa0U7UUFDbkYsTUFBTUMsY0FBYyxJQUFJLENBQUNDLGNBQWMsQ0FBQ0Y7UUFDeEMsSUFBSSxDQUFDQyxhQUFhO1lBQ2hCLE1BQU0sSUFBSTNDLE1BQU0sQ0FBQyxrQ0FBa0MsRUFBRTBDLFVBQVUsQ0FBQztRQUNsRTtRQUVBLE1BQU1uQixPQUFPLE1BQU0sSUFBSSxDQUFDTixZQUFZLENBQUMwQixZQUFZdkQsRUFBRSxFQUFFdUQsWUFBWXBELEtBQUssRUFBRSxtQkFBbUI7O1FBRTNGLE1BQU0wRyxhQUFhLElBQUlDO1FBQ3ZCLElBQUkzRSxLQUFLRixNQUFNLElBQUlFLEtBQUtGLE1BQU0sQ0FBQ1csTUFBTSxHQUFHLEdBQUc7WUFDekMsY0FBYztZQUNkVCxLQUFLRixNQUFNLENBQUNZLEtBQUssQ0FBQyxHQUFHSixPQUFPLENBQUMsQ0FBQ007Z0JBQzVCLE1BQU1jLFlBQVlkLEdBQUcsQ0FBQyxFQUFFLEVBQUVXLE9BQU8sV0FBVzs7Z0JBQzVDLE1BQU1RLGVBQWVuQixHQUFHLENBQUMsRUFBRSxFQUFFVyxPQUFPLFdBQVc7O2dCQUMvQyxNQUFNUyxRQUFRcEIsR0FBRyxDQUFDLEVBQUUsRUFBRVcsT0FBTyxXQUFXOztnQkFDeEMsTUFBTU0sY0FBY2pCLEdBQUcsQ0FBQyxFQUFFLEVBQUVXLE9BQU8sV0FBVzs7Z0JBRTlDLElBQUlHLFdBQVc7b0JBQ2IsSUFBSSxDQUFDZ0QsV0FBV0UsR0FBRyxDQUFDbEQsWUFBWTt3QkFDOUJnRCxXQUFXRyxHQUFHLENBQUNuRCxXQUFXOzRCQUN4QnNDLE9BQU9qQyxnQkFBZ0I7NEJBQ3ZCQyxPQUFPQSxTQUFTOzRCQUNoQjhDLGNBQWMsSUFBSXREO3dCQUNwQjtvQkFDRjtvQkFDQSxJQUFJSyxhQUFhO3dCQUNmNkMsV0FBVzNFLEdBQUcsQ0FBQzJCLFlBQVlvRCxhQUFhQyxJQUFJbEQ7b0JBQzlDO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLE9BQU82QztJQUNUO0lBRUEsTUFBTU0sbUJBQW1CN0QsU0FBaUIsRUFBaUI7UUFDekQsTUFBTUMsY0FBYyxJQUFJLENBQUNDLGNBQWMsQ0FBQ0Y7UUFDeEMsSUFBSSxDQUFDQyxhQUFhO1lBQ2hCLE1BQU0sSUFBSTNDLE1BQU0sQ0FBQyxrQ0FBa0MsRUFBRTBDLFVBQVUsQ0FBQztRQUNsRTtRQUVBLE1BQU1tRCxxQkFBcUJsRCxZQUFZdkQsRUFBRTtRQUN6QyxNQUFNb0gsb0JBQW9CLE1BQU0sSUFBSSxDQUFDUixvQkFBb0IsQ0FBQ3REO1FBQzFEN0IsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFNEIsVUFBVSxRQUFRLEVBQUU4RCxrQkFBa0JDLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQztRQUU1RixNQUFNQyxrQkFBa0IsTUFBTSxJQUFJLENBQUNkLHFCQUFxQixDQUFDQztRQUN6RGhGLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTRCLFVBQVUsUUFBUSxFQUFFZ0UsZ0JBQWdCMUUsTUFBTSxDQUFDLGNBQWMsQ0FBQztRQUUxRSwrREFBK0Q7UUFDL0QsTUFBTTJFLDZCQUE2QixJQUFJVCxNQUF1QywwQ0FBMEM7O1FBRXBILE1BQU1VLGNBQWNGLGdCQUFnQnhFLEdBQUcsQ0FBQ3lCLENBQUFBLGlCQUFrQixDQUFDLEVBQUVBLGVBQWUsSUFBSSxDQUFDO1FBQ2pGOUMsUUFBUUMsR0FBRyxDQUFDO1FBQ2hCRCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU0QixVQUFVLDRDQUE0QyxFQUFFa0UsWUFBWSxDQUFDO1FBRXJGLE1BQU1DLFlBQVksTUFBTSxJQUFJLENBQUNyRixpQkFBaUIsQ0FBQ3FFLG9CQUFvQmU7UUFDbkUvRixRQUFRQyxHQUFHLENBQUMsY0FBY3JDLEtBQUtLLFNBQVMsQ0FBQytILFdBQVcsTUFBTTtRQUMxRGhHLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTRCLFVBQVUsd0JBQXdCLEVBQUVrRSxZQUFZNUUsTUFBTSxDQUFDLENBQUMsRUFBRTRFLFlBQVksQ0FBQyxFQUFFQyxVQUFVLHVCQUF1QixDQUFDO1FBRTNILEtBQUssTUFBTWxELGtCQUFrQitDLGdCQUFpQjtZQUM1QzdGLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTRCLFVBQVUsZ0NBQWdDLEVBQUVpQixlQUFlLENBQUM7WUFDNUUsTUFBTUQsWUFBWUMsZUFBZW1ELE9BQU8sQ0FBQyxVQUFVO1lBQ25ELE1BQU16RixTQUFTd0YsU0FBUyxDQUFDLENBQUMsRUFBRWxELGVBQWUsU0FBUyxDQUFDLENBQUMsSUFBSSxFQUFFO1lBQzVEOUMsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFNEIsVUFBVSxjQUFjLEVBQUVyQixPQUFPVyxNQUFNLENBQUMsZUFBZSxFQUFFMkIsZUFBZSxXQUFXLEVBQUVELFVBQVUsQ0FBQyxDQUFDO1lBQ2pILElBQUlyQyxPQUFPVyxNQUFNLElBQUksR0FBRyxVQUFVLCtCQUErQjtZQUVqRSxvQ0FBb0M7WUFDcEMsTUFBTStFLGlCQUFpQjFGLE9BQ3BCWSxLQUFLLENBQUMsR0FDTkMsR0FBRyxDQUFDLENBQUNDLE1BQVM7b0JBQ2JnQixLQUFLaEIsR0FBRyxDQUFDLEVBQUUsSUFBSTtvQkFDZmlCLGFBQWFqQixHQUFHLENBQUMsRUFBRSxJQUFJO29CQUN2QmtCLE9BQU9sQixHQUFHLENBQUMsRUFBRSxJQUFJO29CQUNqQm1CLGNBQWNuQixHQUFHLENBQUMsRUFBRSxJQUFJO29CQUN4QmMsV0FBV2QsR0FBRyxDQUFDLEVBQUUsSUFBSTtvQkFDckIyQixZQUFZM0IsR0FBRyxDQUFDLEVBQUUsR0FBRzRCLE9BQU9DLFVBQVUsQ0FBQzdCLEdBQUcsQ0FBQyxFQUFFLElBQUk7b0JBQ2pEOEIsbUJBQW1COUIsR0FBRyxDQUFDLEVBQUUsR0FBRzRCLE9BQU9DLFVBQVUsQ0FBQzdCLEdBQUcsQ0FBQyxFQUFFLElBQUk7b0JBQ3hEK0IsaUJBQWlCL0IsR0FBRyxDQUFDLEVBQUUsR0FBRzRCLE9BQU9DLFVBQVUsQ0FBQzdCLEdBQUcsQ0FBQyxFQUFFLElBQUk7b0JBQ3REZ0MsY0FBY2hDLEdBQUcsQ0FBQyxFQUFFLEdBQUc0QixPQUFPQyxVQUFVLENBQUM3QixHQUFHLENBQUMsRUFBRSxJQUFJO29CQUNuRGlDLFFBQVFqQyxHQUFHLENBQUMsRUFBRSxJQUFJO29CQUNsQmtDLFVBQVVsQyxHQUFHLENBQUMsR0FBRyxJQUFJO2dCQUN2QjtZQUVKdEIsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFNEIsVUFBVSxhQUFhLEVBQUVxRSxlQUFlL0UsTUFBTSxDQUFDLGtCQUFrQixFQUFFMEIsVUFBVSxVQUFVLEVBQUVDLGVBQWUsQ0FBQyxDQUFDO1lBRTFILEtBQUssTUFBTVcsU0FBU3lDLGVBQWdCO2dCQUNoQyxNQUFNQyxNQUFNMUMsTUFBTXJCLFNBQVMsQ0FBQ0gsSUFBSTtnQkFDaENqQyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU0QixVQUFVLCtCQUErQixFQUFFc0UsSUFBSSxVQUFVLEVBQUV0RCxVQUFVLENBQUMsQ0FBQyxFQUFFWTtnQkFDekYsSUFBSSxDQUFDcUMsMkJBQTJCUixHQUFHLENBQUNhLE1BQU07b0JBQ3hDTCwyQkFBMkJQLEdBQUcsQ0FBQ1ksS0FBSyxJQUFJZDtnQkFDMUM7Z0JBQ0FTLDJCQUEyQnJGLEdBQUcsQ0FBQzBGLE1BQU1aLElBQUkxQyxXQUFXWTtZQUN0RDtRQUNGO1FBQ0F6RCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU0QixVQUFVLHVEQUF1RCxDQUFDO1FBQ2xGN0IsUUFBUUMsR0FBRyxDQUNULENBQUMsQ0FBQyxFQUFFNEIsVUFBVSxnRUFBZ0UsQ0FBQyxFQUMvRWlFLDJCQUEyQnJGLEdBQUcsQ0FBQztRQUdqQywrQkFBK0I7UUFDL0IsTUFBTTJGLDBCQVlGLENBQUM7UUFFTCxpRUFBaUU7UUFDakUsS0FBSyxNQUFNLENBQUNELEtBQUtFLFFBQVEsSUFBSVYsa0JBQWtCVyxPQUFPLEdBQUk7WUFDeERGLHVCQUF1QixDQUFDRCxJQUFJLEdBQUc7Z0JBQzdCMUQsY0FBYzRELFFBQVEzQixLQUFLO2dCQUMzQmhDLE9BQU8yRCxRQUFRM0QsS0FBSztnQkFDcEI2RCxlQUFlO2dCQUNmQyxzQkFBc0I7Z0JBQ3RCQyxvQkFBb0I7Z0JBQ3BCQyxpQkFBaUI7Z0JBQ2pCQyxZQUFZO2dCQUNaQyxhQUFhO2dCQUNicEIsY0FBY3FCLE1BQU12SCxJQUFJLENBQUMrRyxRQUFRYixZQUFZLEVBQUVzQixJQUFJO1lBQ3JEO1FBQ0Y7UUFFQSxvREFBb0Q7UUFDcEQsS0FBSyxNQUFNLENBQUNYLEtBQUtZLGVBQWUsSUFBSWpCLDJCQUEyQlEsT0FBTyxHQUFJO1lBQ3hFdEcsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFNEIsVUFBVSxnQ0FBZ0MsRUFBRXNFLElBQUksYUFBYSxDQUFDLEVBQUVVLE1BQU12SCxJQUFJLENBQUN5SCxlQUFlQyxJQUFJO1lBQzlHaEgsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFNEIsVUFBVSw2QkFBNkIsRUFBRXNFLElBQUksS0FBSyxFQUFFWSxlQUFlbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUNsRyxJQUFJLENBQUNRLHVCQUF1QixDQUFDRCxJQUFJLEVBQUU7Z0JBQ2pDLHdGQUF3RjtnQkFDeEYsaUVBQWlFO2dCQUNqRSxNQUFNYyxhQUFhSixNQUFNdkgsSUFBSSxDQUFDeUgsZUFBZXZHLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ3pENEYsdUJBQXVCLENBQUNELElBQUksR0FBRztvQkFDN0IxRCxjQUFjd0UsWUFBWXhFLGdCQUFnQjtvQkFDMUNDLE9BQU9pRCxrQkFBa0JsRixHQUFHLENBQUMwRixNQUFNekQsU0FBUztvQkFDNUM2RCxlQUFlO29CQUNmQyxzQkFBc0I7b0JBQ3RCQyxvQkFBb0I7b0JBQ3BCQyxpQkFBaUI7b0JBQ2pCQyxZQUFZO29CQUNaQyxhQUFhO29CQUNicEIsY0FBYyxFQUFFO2dCQUNsQjtnQkFDQXhGLFFBQVFrSCxJQUFJLENBQ1YsQ0FBQyxDQUFDLEVBQUVyRixVQUFVLFVBQVUsRUFBRXNFLElBQUksK0VBQStFLENBQUM7WUFFbEg7WUFDQSxLQUFLLE1BQU0sQ0FBQ3RELFdBQVdZLE1BQU0sSUFBSXNELGVBQWVULE9BQU8sR0FBSTtnQkFDekQsSUFBSTdDLE1BQU1GLE1BQU0sS0FBSyxVQUFVO29CQUM3QnZELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTRCLFVBQVUsUUFBUSxFQUFFZ0IsVUFBVSxnQkFBZ0IsRUFBRXNELElBQUksV0FBVyxDQUFDO29CQUNoRkMsdUJBQXVCLENBQUNELElBQUksQ0FBQ1MsV0FBVztnQkFDMUMsT0FBTztvQkFDTCxVQUFVO29CQUNWNUcsUUFBUUMsR0FBRyxDQUNULENBQUMsQ0FBQyxFQUFFNEIsVUFBVSwyQkFBMkIsRUFBRXNFLElBQUksVUFBVSxFQUFFdEQsVUFBVSxhQUFhLEVBQUVZLE1BQU1SLFVBQVUsQ0FBQyxvQkFBb0IsRUFBRVEsTUFBTUwsaUJBQWlCLENBQUMsa0JBQWtCLEVBQUVLLE1BQU1KLGVBQWUsQ0FBQyxlQUFlLEVBQUVJLE1BQU1ILFlBQVksQ0FBQyxDQUFDO29CQUVwTzhDLHVCQUF1QixDQUFDRCxJQUFJLENBQUNRLFVBQVU7b0JBQ3ZDUCx1QkFBdUIsQ0FBQ0QsSUFBSSxDQUFDSSxhQUFhLElBQUk5QyxNQUFNUixVQUFVLElBQUk7b0JBQ2xFbUQsdUJBQXVCLENBQUNELElBQUksQ0FBQ0ssb0JBQW9CLElBQUkvQyxNQUFNTCxpQkFBaUIsSUFBSTtvQkFDaEZnRCx1QkFBdUIsQ0FBQ0QsSUFBSSxDQUFDTSxrQkFBa0IsSUFBSWhELE1BQU1KLGVBQWUsSUFBSTtvQkFDNUUrQyx1QkFBdUIsQ0FBQ0QsSUFBSSxDQUFDTyxlQUFlLElBQUlqRCxNQUFNSCxZQUFZLElBQUk7Z0JBQ3hFO1lBQ0Y7UUFDRjtRQUNBdEQsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFNEIsVUFBVSwwQ0FBMEMsQ0FBQztRQUNyRTdCLFFBQVFDLEdBQUcsQ0FDVCxDQUFDLENBQUMsRUFBRTRCLFVBQVUsNkRBQTZELENBQUMsRUFDNUV1RSx1QkFBdUIsQ0FBQyxRQUFRO1FBR2xDLDhEQUE4RDtRQUM5RCxNQUFNZSxlQUEyQixFQUFFO1FBQ25DQSxhQUFhQyxJQUFJLENBQUM7WUFDaEI7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0QsRUFBRSwyQkFBMkI7O1FBRTlCLE1BQU1DLHNCQVVELEVBQUU7UUFFUCxJQUFLLE1BQU1sQixPQUFPQyx3QkFBeUI7WUFDekMsTUFBTWtCLGNBQWNsQix1QkFBdUIsQ0FBQ0QsSUFBSTtZQUNoRCxJQUFJb0IsZ0JBQWdCO1lBQ3BCLElBQUlDLHVCQUF1QjtZQUMzQixJQUFJQyxxQkFBcUI7WUFDekIsSUFBSUMsa0JBQWtCO1lBQ3RCLElBQUlDLGtCQUFrQjtZQUV0QixJQUFJTCxZQUFZWCxVQUFVLEdBQUcsR0FBRztnQkFDOUJZLGdCQUFnQkQsWUFBWWYsYUFBYSxHQUFHZSxZQUFZWCxVQUFVO2dCQUNsRWEsdUJBQXVCRixZQUFZZCxvQkFBb0IsR0FBR2MsWUFBWVgsVUFBVTtnQkFDaEZjLHFCQUFxQkgsWUFBWWIsa0JBQWtCLEdBQUdhLFlBQVlYLFVBQVU7Z0JBQzVFZSxrQkFBa0JKLFlBQVlaLGVBQWUsR0FBR1ksWUFBWVgsVUFBVTtnQkFDdEVnQixrQkFBa0IsQ0FBQ0osZ0JBQWdCQyx1QkFBdUJDLHFCQUFxQkMsZUFBYyxJQUFLO1lBQ3BHLE9BQU8sSUFBSUosWUFBWVYsV0FBVyxHQUFHLEtBQUtVLFlBQVlYLFVBQVUsS0FBSyxHQUFHO2dCQUN0RSx3REFBd0Q7Z0JBQ3hEWSxnQkFBZ0I7Z0JBQ2hCQyx1QkFBdUI7Z0JBQ3ZCQyxxQkFBcUI7Z0JBQ3JCQyxrQkFBa0I7Z0JBQ2xCQyxrQkFBa0I7WUFDcEI7WUFDQSwwR0FBMEc7WUFFMUdOLG9CQUFvQkQsSUFBSSxDQUFDO2dCQUN2QmhGLFdBQVcrRDtnQkFDWDFELGNBQWM2RSxZQUFZN0UsWUFBWTtnQkFDdENDLE9BQU80RSxZQUFZNUUsS0FBSztnQkFDeEI2RSxlQUFlQTtnQkFDZkMsc0JBQXNCQTtnQkFDdEJDLG9CQUFvQkE7Z0JBQ3BCQyxpQkFBaUJBO2dCQUNqQkMsaUJBQWlCQTtnQkFDakJuQyxjQUFjOEIsWUFBWTlCLFlBQVksQ0FBQzdGLElBQUksQ0FBQztZQUM5QztRQUNGO1FBRUEsd0VBQXdFO1FBQ3hFMEgsb0JBQW9CUCxJQUFJLENBQUMsQ0FBQ2MsR0FBR0MsSUFBTUQsRUFBRXhGLFNBQVMsQ0FBQzBGLGFBQWEsQ0FBQ0QsRUFBRXpGLFNBQVM7UUFFeEVpRixvQkFBb0JyRyxPQUFPLENBQUMsQ0FBQytHO1lBQzNCWixhQUFhQyxJQUFJLENBQUM7Z0JBQ2hCVyxRQUFRM0YsU0FBUztnQkFDakIyRixRQUFRdEYsWUFBWTtnQkFDcEJzRixRQUFRckYsS0FBSztnQkFDYnFGLFFBQVFSLGFBQWEsQ0FBQ1MsT0FBTyxDQUFDO2dCQUM5QkQsUUFBUVAsb0JBQW9CLENBQUNRLE9BQU8sQ0FBQztnQkFDckNELFFBQVFOLGtCQUFrQixDQUFDTyxPQUFPLENBQUM7Z0JBQ25DRCxRQUFRTCxlQUFlLENBQUNNLE9BQU8sQ0FBQztnQkFDaENELFFBQVFKLGVBQWUsQ0FBQ0ssT0FBTyxDQUFDO2dCQUNoQ0QsUUFBUXZDLFlBQVk7YUFDckI7UUFDSDtRQUNBeEYsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFNEIsVUFBVSxXQUFXLEVBQUVzRixhQUFhaEcsTUFBTSxHQUFHLEVBQUUseUNBQXlDLENBQUM7UUFDekduQixRQUFRQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU0QixVQUFVLG9DQUFvQyxDQUFDLEVBQUVzRjtRQUVqRSxNQUFNYyxpQkFBaUI7UUFDdkIsTUFBTSxJQUFJLENBQUNyRSxpQkFBaUIsQ0FBQ29CLG9CQUFvQmlELGdCQUFnQmQsWUFBWSxDQUFDLEVBQUUsRUFBRSwyQkFBMkI7O1FBRTdHLG9FQUFvRTtRQUNwRSxNQUFNLElBQUksQ0FBQ3JILE1BQU0sQ0FBQ1MsWUFBWSxDQUFDQyxNQUFNLENBQUMwSCxLQUFLLENBQUM7WUFDMUM3SCxlQUFlMkU7WUFDZnRHLE9BQU8sQ0FBQyxFQUFFdUosZUFBZSxLQUFLLENBQUM7UUFDakM7UUFFQSxvQ0FBb0M7UUFDcEMsSUFBSWQsYUFBYWhHLE1BQU0sR0FBRyxHQUFHO1lBQzNCLGdEQUFnRDtZQUNoRCxNQUFNLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQ1MsWUFBWSxDQUFDQyxNQUFNLENBQUMySCxNQUFNLENBQUM7Z0JBQzNDOUgsZUFBZTJFO2dCQUNmdEcsT0FBTyxDQUFDLEVBQUV1SixlQUFlLEdBQUcsQ0FBQztnQkFDN0JsRSxrQkFBa0I7Z0JBQ2xCQyxVQUFVO29CQUNSeEQsUUFBUTJHO2dCQUNWO1lBQ0Y7WUFDQW5ILFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDBCQUEwQixFQUFFNEIsVUFBVSxNQUFNLEVBQUVzRixhQUFhaEcsTUFBTSxHQUFHLEVBQUUseUJBQXlCLENBQUM7UUFDL0csT0FBTztZQUNMbkIsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFNEIsVUFBVSxvREFBb0QsQ0FBQztRQUNqRjtJQUNGO0lBRUEsTUFBTXVHLGVBQWV2RyxTQUFpQixFQVVwQztRQUNBLE1BQU1DLGNBQWMsSUFBSSxDQUFDQyxjQUFjLENBQUNGO1FBQ3hDLElBQUksQ0FBQ0MsYUFBYTtZQUNoQixNQUFNLElBQUkzQyxNQUFNLENBQUMsa0NBQWtDLEVBQUUwQyxVQUFVLENBQUM7UUFDbEU7UUFFQSxNQUFNb0csaUJBQWlCO1FBQ3ZCLE1BQU1JLGFBQWEsQ0FBQyxFQUFFSixlQUFlLElBQUksQ0FBQyxDQUFDLDBDQUEwQzs7UUFFckYsSUFBSTtZQUNGLE1BQU12SCxPQUFPLE1BQU0sSUFBSSxDQUFDTixZQUFZLENBQUMwQixZQUFZdkQsRUFBRSxFQUFFOEo7WUFDckRySSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU0QixVQUFVLG1EQUFtRCxFQUFFbkIsS0FBS0YsTUFBTSxDQUFDVyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBRXBHLElBQUksQ0FBQ1QsS0FBS0YsTUFBTSxJQUFJRSxLQUFLRixNQUFNLENBQUNXLE1BQU0sSUFBSSxHQUFHO2dCQUMzQyx5QkFBeUI7Z0JBQ3pCbkIsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFNEIsVUFBVSwrREFBK0QsQ0FBQztnQkFDMUYsT0FBTyxFQUFFO1lBQ1g7WUFFQSxNQUFNeUcsV0FNRCxFQUFFO1lBRVA1SCxLQUFLRixNQUFNLENBQUNZLEtBQUssQ0FBQyxHQUFHSixPQUFPLENBQUMsQ0FBQ007Z0JBQzVCLE1BQU1jLFlBQVlkLEdBQUcsQ0FBQyxFQUFFLEVBQUVXLE9BQU8sNkJBQTZCOztnQkFDOUQsTUFBTVEsZUFBZW5CLEdBQUcsQ0FBQyxFQUFFLEVBQUVXLE9BQU8sZ0NBQWdDOztnQkFDcEUsTUFBTVMsUUFBUXBCLEdBQUcsQ0FBQyxFQUFFLEVBQUVXLE9BQU8sd0JBQXdCOztnQkFDckQsTUFBTTBGLGtCQUFrQnpFLE9BQU9DLFVBQVUsQ0FBQzdCLEdBQUcsQ0FBQyxFQUFFLEtBQUssRUFBRSxrREFBa0Q7O2dCQUN6RyxNQUFNa0UsZUFBZWxFLEdBQUcsQ0FBQyxFQUFFLEVBQUVXLFVBQVUsR0FBRywwQ0FBMEM7O2dCQUVwRixJQUFJRyxXQUFXO29CQUNia0csU0FBU2xCLElBQUksQ0FBQzt3QkFDWmhGLFdBQVdBO3dCQUNYSyxjQUFjQTt3QkFDZEMsT0FBT0E7d0JBQ1BpRixpQkFBaUJBO3dCQUNqQm5DLGNBQWNBO29CQUNoQjtnQkFDRixPQUFPO29CQUNMeEYsUUFBUWtILElBQUksQ0FDVixDQUFDLENBQUMsRUFBRXJGLFVBQVUsMEVBQTBFLEVBQUVQLElBQUkzQixJQUFJLENBQUMsTUFBTSxDQUFDO2dCQUU5RztZQUNGO1lBQ0FLLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTRCLFVBQVUsU0FBUyxFQUFFeUcsU0FBU25ILE1BQU0sQ0FBQywyQkFBMkIsQ0FBQztZQUVqRiwyQ0FBMkM7WUFDM0NtSCxTQUFTeEIsSUFBSSxDQUFDLENBQUNjLEdBQUdDLElBQU1BLEVBQUVGLGVBQWUsR0FBR0MsRUFBRUQsZUFBZTtZQUM3RDNILFFBQVFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTRCLFVBQVUsbUNBQW1DLENBQUM7WUFFOUQsTUFBTTBHLGNBUUQsRUFBRTtZQUNQLElBQUlDLGNBQWM7WUFDbEIsSUFBSUMsZ0JBQWdCO1lBRXBCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixTQUFTbkgsTUFBTSxFQUFFdUgsSUFBSztnQkFDeEMsTUFBTVgsVUFBVU8sUUFBUSxDQUFDSSxFQUFFO2dCQUMzQixJQUFJRCxnQkFBZ0IsR0FBRztvQkFDckJGLFlBQVluQixJQUFJLENBQUM7d0JBQUUsR0FBR1csT0FBTzt3QkFBRVksVUFBVTlHO3dCQUFXK0csTUFBTUo7b0JBQVk7b0JBQ3RFQztnQkFDRixPQUFPLElBQUlWLFFBQVFKLGVBQWUsS0FBS1ksV0FBVyxDQUFDQSxZQUFZcEgsTUFBTSxHQUFHLEVBQUUsQ0FBQ3dHLGVBQWUsRUFBRTtvQkFDMUYsNEJBQTRCO29CQUM1QlksWUFBWW5CLElBQUksQ0FBQzt3QkFBRSxHQUFHVyxPQUFPO3dCQUFFWSxVQUFVOUc7d0JBQVcrRyxNQUFNSjtvQkFBWTtnQkFDeEUsT0FBTztvQkFDTCxPQUFNLDhCQUE4QjtnQkFDdEM7Z0JBQ0Esd0hBQXdIO2dCQUN4SCxJQUFJRSxJQUFJSixTQUFTbkgsTUFBTSxHQUFHLEtBQUttSCxRQUFRLENBQUNJLElBQUksRUFBRSxDQUFDZixlQUFlLEdBQUdJLFFBQVFKLGVBQWUsRUFBRTtvQkFDeEZhLGNBQWNELFlBQVlwSCxNQUFNLEdBQUc7Z0JBQ3JDO1lBQ0Y7WUFDQW5CLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTRCLFVBQVUsYUFBYSxFQUFFMEcsWUFBWXBILE1BQU0sQ0FBQyxjQUFjLENBQUM7WUFDM0UsT0FBT29IO1FBQ1QsRUFBRSxPQUFPcEksT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsQ0FBQywrQkFBK0IsRUFBRTBCLFVBQVUsQ0FBQyxDQUFDLEVBQUUxQjtZQUM5RCxNQUFNLElBQUloQixNQUFNLENBQUMsK0JBQStCLEVBQUUwQyxVQUFVLENBQUMsQ0FBQztRQUNoRTtJQUNGO0lBRUEsTUFBTWdILG1CQUNKQyxXQVFFLEVBQ2E7UUFDZixNQUFNQyxxQkFBcUIxSyxtQkFBbUJNLFlBQVksQ0FBQ0osRUFBRTtRQUM3RCxNQUFNeUssbUJBQW1CO1FBQ3pCLE1BQU1DLGdCQUFnQjtZQUNwQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNELENBQUMsc0JBQXNCOztRQUV4QixNQUFNLElBQUksQ0FBQ3JGLGlCQUFpQixDQUFDbUYsb0JBQW9CQyxrQkFBa0JDO1FBRW5FLDJEQUEyRDtRQUMzRCxNQUFNLElBQUksQ0FBQ25KLE1BQU0sQ0FBQ1MsWUFBWSxDQUFDQyxNQUFNLENBQUMwSCxLQUFLLENBQUM7WUFDMUM3SCxlQUFlMEk7WUFDZnJLLE9BQU8sQ0FBQyxFQUFFc0ssaUJBQWlCLEtBQUssQ0FBQztRQUNuQztRQUVBLElBQUlGLFlBQVkzSCxNQUFNLEtBQUssR0FBRztZQUM1Qm5CLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQSxNQUFNaUosZUFBZUosWUFBWXpILEdBQUcsQ0FBQyxDQUFDWCxPQUFTO2dCQUM3Q0EsS0FBS2lJLFFBQVE7Z0JBQ2JqSSxLQUFLa0ksSUFBSSxDQUFDckosUUFBUTtnQkFDbEJtQixLQUFLMEIsU0FBUztnQkFDZDFCLEtBQUsrQixZQUFZO2dCQUNqQi9CLEtBQUtnQyxLQUFLO2dCQUNWaEMsS0FBS2lILGVBQWUsQ0FBQ0ssT0FBTyxDQUFDO2dCQUM3QnRILEtBQUs4RSxZQUFZO2FBQ2xCO1FBRUQsTUFBTSxJQUFJLENBQUMxRixNQUFNLENBQUNTLFlBQVksQ0FBQ0MsTUFBTSxDQUFDc0QsTUFBTSxDQUFDO1lBQzNDekQsZUFBZTBJO1lBQ2ZySyxPQUFPLENBQUMsRUFBRXNLLGlCQUFpQixHQUFHLENBQUM7WUFDL0JqRixrQkFBa0I7WUFDbEJDLFVBQVU7Z0JBQ1J4RCxRQUFRMEk7WUFDVjtRQUNGO1FBQ0FsSixRQUFRQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUVpSixhQUFhL0gsTUFBTSxDQUFDLDZDQUE2QyxDQUFDO0lBQzlGO0lBRUFZLGVBQWVGLFNBQWlCLEVBQTJCO1FBQ3pELE9BQU94RCxtQkFBbUJRLE9BQU8sQ0FBQ2dELFVBQXFEO0lBQ3pGO0lBRUFzSCxpQkFBaUJ0SCxTQUFpQixFQUFVO1FBQzFDLE1BQU1DLGNBQWMsSUFBSSxDQUFDQyxjQUFjLENBQUNGO1FBQ3hDLE9BQU9DLGFBQWF2RCxNQUFNO0lBQzVCO0lBRUEsa0RBQWtEO0lBQ2xENksseUJBQXlCdkgsU0FBaUIsRUFBRXdILEtBQWEsRUFBUTtRQUMvRCxJQUFJaEwsbUJBQW1CUSxPQUFPLENBQUNnRCxVQUFxRCxFQUFFO1lBQ3BGLDBCQUEwQjtZQUMxQnhELHFCQUFxQjtnQkFDbkIsR0FBR0Esa0JBQWtCO2dCQUNyQlEsU0FBUztvQkFDUCxHQUFHUixtQkFBbUJRLE9BQU87b0JBQzdCLENBQUNnRCxVQUFVLEVBQUU7d0JBQ1gsR0FBR3hELG1CQUFtQlEsT0FBTyxDQUFDZ0QsVUFBcUQ7d0JBQ25GdEQsSUFBSThLO29CQUNOO2dCQUNGO1lBQ0Y7WUFDQSxrQkFBa0I7WUFDbEIsTUFBTXRMLE1BQU1OO1lBQ1pNLEdBQUcsQ0FBQzhELFVBQVUsR0FBR3dIO1lBQ2pCdkwsa0JBQWtCQztZQUNsQmlDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG9EQUFvRCxFQUFFNEIsVUFBVSxRQUFRLEVBQUV3SCxNQUFNLHNCQUFzQixDQUFDO1FBQ3RILE9BQU87WUFDTHJKLFFBQVFrSCxJQUFJLENBQUMsQ0FBQywyQkFBMkIsRUFBRXJGLFVBQVUsaUNBQWlDLENBQUM7UUFDekY7SUFDRjtBQUNGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU15SCxzQkFBc0IsSUFBSXZLLHNCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9saWIvZ29vZ2xlLXNoZWV0cy50cz82MmQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdvb2dsZUF1dGggfSBmcm9tIFwiZ29vZ2xlLWF1dGgtbGlicmFyeVwiXG5pbXBvcnQgeyBnb29nbGUgfSBmcm9tIFwiZ29vZ2xlYXBpc1wiXG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIlxuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiXG5pbXBvcnQgKiBhcyBvcyBmcm9tIFwib3NcIlxuXG5jb25zdCBDTEFTU19TSEVFVF9JRFNfUEFUSCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBcImxpYi9jbGFzcy1zaGVldC1pZHMuanNvblwiKVxuXG5mdW5jdGlvbiBsb2FkQ2xhc3NTaGVldElkcygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBmcy5yZWFkRmlsZVN5bmMoQ0xBU1NfU0hFRVRfSURTX1BBVEgsIFwidXRmLThcIilcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVDbGFzc1NoZWV0SWRzKGlkczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBmcy53cml0ZUZpbGVTeW5jKENMQVNTX1NIRUVUX0lEU19QQVRILCBKU09OLnN0cmluZ2lmeShpZHMsIG51bGwsIDIpLCBcInV0Zi04XCIpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hlZXRDcmVkZW50aWFsIHtcbiAgdXNlcm5hbWU6IHN0cmluZ1xuICBwYXNzd29yZDogc3RyaW5nXG4gIHJvbGU6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0dWRlbnRQcm9qZWN0IHtcbiAgc25vOiBzdHJpbmdcbiAgc3R1ZGVudE5hbWU6IHN0cmluZ1xuICBncmFkZTogc3RyaW5nXG4gIHByb2plY3RUaXRsZTogc3RyaW5nXG4gIHByb2plY3RJZDogc3RyaW5nXG4gIHRoZW1lPzogc3RyaW5nIC8vIEFkZGVkIHRoZW1lIGZpZWxkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSnVkZ2VTY29yZSB7XG4gIHNubzogc3RyaW5nXG4gIHN0dWRlbnROYW1lOiBzdHJpbmdcbiAgZ3JhZGU6IHN0cmluZ1xuICBwcm9qZWN0VGl0bGU6IHN0cmluZ1xuICBwcm9qZWN0SWQ6IHN0cmluZ1xuICBjcmVhdGl2aXR5OiBudW1iZXIgfCBudWxsXG4gIHNjaWVudGlmaWNUaG91Z2h0OiBudW1iZXIgfCBudWxsXG4gIHRlY2huaWNhbFNraWxsczogbnVtYmVyIHwgbnVsbFxuICBwcmVzZW50YXRpb246IG51bWJlciB8IG51bGxcbiAgc3RhdHVzPzogc3RyaW5nIC8vIEFkZGVkIHN0YXR1cyBmaWVsZCAoZS5nLiwgXCJQcmVzZW50XCIsIFwiQWJzZW50XCIpXG4gIHRoZW1lRml0Pzogc3RyaW5nIHwgbnVsbCAvLyBBZGRlZCB0aGVtZUZpdCBmaWVsZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNoZWV0RGF0YSB7XG4gIHZhbHVlczogc3RyaW5nW11bXVxuICByYW5nZTogc3RyaW5nXG4gIHNwcmVhZHNoZWV0SWQ6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgQ2xhc3NDb25maWcge1xuICBpZDogc3RyaW5nXG4gIGJhc2VTaGVldDogc3RyaW5nXG4gIHJhbmdlOiBzdHJpbmdcbn1cblxuLy8gQ29uZmlndXJhdGlvbiBmb3IgR29vZ2xlIFNoZWV0cyBBUElcbmV4cG9ydCBjb25zdCBHT09HTEVfU0hFRVRTX0NPTkZJRyA9IHtcbiAgc2NvcGVzOiBbXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL3NwcmVhZHNoZWV0c1wiXSxcbn1cblxuLy8gU3ByZWFkc2hlZXQgY29uZmlndXJhdGlvbnMgLSBjaGFuZ2VkIHRvICdsZXQnIHRvIGFsbG93IGR5bmFtaWMgdXBkYXRlcyBmb3IgZGVtb25zdHJhdGlvblxuY29uc3QgcGVyc2lzdGVkSWRzID0gbG9hZENsYXNzU2hlZXRJZHMoKVxuZXhwb3J0IGxldCBTUFJFQURTSEVFVF9DT05GSUcgPSB7XG4gIENSRURFTlRJQUxTOiB7XG4gICAgaWQ6IHByb2Nlc3MuZW52LkNSRURFTlRJQUxTX1NQUkVBRFNIRUVUX0lEIHx8IFwiMWp1UDNFZzI0R1lnT21GY3hwTk1mYlVTWEs0bTd4VHF6bE4tQ3c5bmRZUWNcIiwgLy8gUkVQTEFDRSBXSVRIIFlPVVIgQ1JFREVOVElBTFMgU0hFRVQgSURcbiAgICByYW5nZTogXCJTaGVldDEhQTpDXCIsIC8vIFVzZXJuYW1lLCBQYXNzd29yZCwgUm9sZVxuICB9LFxuICBBRE1JTl9NQVNURVI6IHtcbiAgICBpZDogcHJvY2Vzcy5lbnYuQURNSU5fTUFTVEVSX1NQUkVBRFNIRUVUX0lEIHx8IFwiMXNuay1GWmF4eVpiU3VfV3ctb1BuYW04SnhaMlJMZzNldEk1VEJrci1UMUFcIiwgLy8gTmV3OiBBZG1pbiBNYXN0ZXIgU2hlZXQgSUQsIGRlZmF1bHRzIHRvIGNyZWRlbnRpYWxzIHNoZWV0XG4gIH0sXG4gIENMQVNTRVM6IHtcbiAgICBcIkNsYXNzIDRcIjoge1xuICAgICAgaWQ6IHBlcnNpc3RlZElkc1tcIkNsYXNzIDRcIl0sIC8vIFJFUExBQ0VcbiAgICAgIGJhc2VTaGVldDogXCJCYXNlU2hlZXRcIixcbiAgICAgIHJhbmdlOiBcIlNoZWV0MSFBOkZcIiwgLy8gVXBkYXRlZCByYW5nZSB0byBpbmNsdWRlIFRoZW1lIChhc3N1bWluZyBjb2x1bW4gRilcbiAgICB9LFxuICAgIFwiQ2xhc3MgNVwiOiB7XG4gICAgICBpZDogcGVyc2lzdGVkSWRzW1wiQ2xhc3MgNVwiXSwgLy8gUkVQTEFDRVxuICAgICAgYmFzZVNoZWV0OiBcIkJhc2VTaGVldFwiLFxuICAgICAgcmFuZ2U6IFwiU2hlZXQxIUE6RlwiLCAvLyBVcGRhdGVkIHJhbmdlIHRvIGluY2x1ZGUgVGhlbWUgKGFzc3VtaW5nIGNvbHVtbiBGKVxuICAgIH0sXG4gICAgXCJDbGFzcyA2XCI6IHtcbiAgICAgIGlkOiBwZXJzaXN0ZWRJZHNbXCJDbGFzcyA2XCJdLCAvLyBSRVBMQUNFXG4gICAgICBiYXNlU2hlZXQ6IFwiQmFzZVNoZWV0XCIsXG4gICAgICByYW5nZTogXCJTaGVldDEhQTpGXCIsIC8vIFVwZGF0ZWQgcmFuZ2UgdG8gaW5jbHVkZSBUaGVtZSAoYXNzdW1pbmcgY29sdW1uIEYpXG4gICAgfSxcbiAgICBcIkNsYXNzIDdcIjoge1xuICAgICAgaWQ6IHBlcnNpc3RlZElkc1tcIkNsYXNzIDdcIl0sIC8vIFJFUExBQ0VcbiAgICAgIGJhc2VTaGVldDogXCJCYXNlU2hlZXRcIixcbiAgICAgIHJhbmdlOiBcIlNoZWV0MSFBOkZcIiwgLy8gVXBkYXRlZCByYW5nZSB0byBpbmNsdWRlIFRoZW1lIChhc3N1bWluZyBjb2x1bW4gRilcbiAgICB9LFxuICAgIFwiQ2xhc3MgOFwiOiB7XG4gICAgICBpZDogcGVyc2lzdGVkSWRzW1wiQ2xhc3MgOFwiXSwgLy8gUkVQTEFDRVxuICAgICAgYmFzZVNoZWV0OiBcIkJhc2VTaGVldFwiLFxuICAgICAgcmFuZ2U6IFwiU2hlZXQxIUE6RlwiLCAvLyBVcGRhdGVkIHJhbmdlIHRvIGluY2x1ZGUgVGhlbWUgKGFzc3VtaW5nIGNvbHVtbiBGKVxuICAgIH0sXG4gICAgXCJDbGFzcyA5XCI6IHtcbiAgICAgIGlkOiBwZXJzaXN0ZWRJZHNbXCJDbGFzcyA5XCJdLCAvLyBSRVBMQUNFXG4gICAgICBiYXNlU2hlZXQ6IFwiQmFzZVNoZWV0XCIsXG4gICAgICByYW5nZTogXCJTaGVldDEhQTpGXCIsIC8vIFVwZGF0ZWQgcmFuZ2UgdG8gaW5jbHVkZSBUaGVtZSAoYXNzdW1pbmcgY29sdW1uIEYpXG4gICAgfSxcbiAgICBcIkNsYXNzIDEwXCI6IHtcbiAgICAgIGlkOiBwZXJzaXN0ZWRJZHNbXCJDbGFzcyAxMFwiXSwgLy8gUkVQTEFDRVxuICAgICAgYmFzZVNoZWV0OiBcIkJhc2VTaGVldFwiLFxuICAgICAgcmFuZ2U6IFwiU2hlZXQxIUE6RlwiLCAvLyBVcGRhdGVkIHJhbmdlIHRvIGluY2x1ZGUgVGhlbWUgKGFzc3VtaW5nIGNvbHVtbiBGKVxuICAgIH0sXG4gICAgXCJDbGFzcyAxMVwiOiB7XG4gICAgICBpZDogcGVyc2lzdGVkSWRzW1wiQ2xhc3MgMTFcIl0sIC8vIFJFUExBQ0VcbiAgICAgIGJhc2VTaGVldDogXCJCYXNlU2hlZXRcIixcbiAgICAgIHJhbmdlOiBcIlNoZWV0MSFBOkZcIiwgLy8gVXBkYXRlZCByYW5nZSB0byBpbmNsdWRlIFRoZW1lIChhc3N1bWluZyBjb2x1bW4gRilcbiAgICB9LFxuICAgIFwiQ2xhc3MgMTJcIjoge1xuICAgICAgaWQ6IHBlcnNpc3RlZElkc1tcIkNsYXNzIDEyXCJdLCAvLyBSRVBMQUNFXG4gICAgICBiYXNlU2hlZXQ6IFwiQmFzZVNoZWV0XCIsXG4gICAgICByYW5nZTogXCJTaGVldDEhQTpGXCIsIC8vIFVwZGF0ZWQgcmFuZ2UgdG8gaW5jbHVkZSBUaGVtZSAoYXNzdW1pbmcgY29sdW1uIEYpXG4gICAgfSxcbiAgfSxcbn1cblxuZXhwb3J0IGNsYXNzIEdvb2dsZVNoZWV0c1NlcnZpY2Uge1xuICBwcml2YXRlIGF1dGg6IEdvb2dsZUF1dGhcbiAgcHJpdmF0ZSBzaGVldHM6IGFueVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBiYXNlNjRLZXkgPSBwcm9jZXNzLmVudi5HT09HTEVfU0VSVklDRV9BQ0NPVU5UX0tFWV9CQVNFNjQ7XG4gICAgICBpZiAoIWJhc2U2NEtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJHT09HTEVfU0VSVklDRV9BQ0NPVU5UX0tFWV9CQVNFNjQgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldC4gUGxlYXNlIGNvbmZpZ3VyZSB5b3VyIHNlcnZpY2UgYWNjb3VudCBrZXkgYXMgYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIERlY29kZSBhbmQgd3JpdGUgdG8gYSB0ZW1wIGZpbGUgaW4gdGhlIE9TIHRlbXAgZGlyZWN0b3J5XG4gICAgICBjb25zdCBrZXlEYXRhID0gQnVmZmVyLmZyb20oYmFzZTY0S2V5LCBcImJhc2U2NFwiKS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICBjb25zdCB0bXBEaXIgPSBvcy50bXBkaXIoKTtcbiAgICAgIGNvbnN0IGtleVBhdGggPSBwYXRoLmpvaW4odG1wRGlyLCBcInNlcnZpY2UtYWNjb3VudC1rZXkuanNvblwiKTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoa2V5UGF0aCwga2V5RGF0YSk7XG5cbiAgICAgIHRoaXMuYXV0aCA9IG5ldyBHb29nbGVBdXRoKHtcbiAgICAgICAga2V5RmlsZToga2V5UGF0aCxcbiAgICAgICAgc2NvcGVzOiBHT09HTEVfU0hFRVRTX0NPTkZJRy5zY29wZXMsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2hlZXRzID0gZ29vZ2xlLnNoZWV0cyh7IHZlcnNpb246IFwidjRcIiwgYXV0aDogdGhpcy5hdXRoIH0pO1xuICAgICAgY29uc29sZS5sb2coXCLwn5SXIEdvb2dsZSBTaGVldHMgQVBJIGluaXRpYWxpemVkIHdpdGggc2VydmljZSBhY2NvdW50IGtleSBmcm9tIEJhc2U2NC5cIik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIGluaXRpYWxpemluZyBHb29nbGUgU2hlZXRzIEFQSTpcIiwgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRTaGVldERhdGEoc3ByZWFkc2hlZXRJZDogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogUHJvbWlzZTxTaGVldERhdGE+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCflJcgRmV0Y2hpbmcgZGF0YSBmcm9tIEdvb2dsZSBTaGVldHM6ICR7c3ByZWFkc2hlZXRJZH0sIFJhbmdlOiAke3JhbmdlfWApXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5nZXQoe1xuICAgICAgICBzcHJlYWRzaGVldElkLFxuICAgICAgICByYW5nZSxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlczogcmVzcG9uc2UuZGF0YS52YWx1ZXMgfHwgW10sXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBzcHJlYWRzaGVldElkLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgc2hlZXQgZGF0YTpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggZGF0YSBmcm9tIHNwcmVhZHNoZWV0ICR7c3ByZWFkc2hlZXRJZH0uIFBsZWFzZSBjaGVjayBwZXJtaXNzaW9ucyBhbmQgc3ByZWFkc2hlZXQgSUQuYCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBhc3luYyBiYXRjaEdldFNoZWV0RGF0YShzcHJlYWRzaGVldElkOiBzdHJpbmcsIHJhbmdlczogc3RyaW5nW10pOiBQcm9taXNlPHsgW3JhbmdlOiBzdHJpbmddOiBzdHJpbmdbXVtdIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNoZWV0cy5zcHJlYWRzaGVldHMudmFsdWVzLmJhdGNoR2V0KHtcbiAgICAgICAgc3ByZWFkc2hlZXRJZCxcbiAgICAgICAgcmFuZ2VzLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IHJlc3VsdDogeyBbcmFuZ2U6IHN0cmluZ106IHN0cmluZ1tdW10gfSA9IHt9XG4gICAgICA7KHJlc3BvbnNlLmRhdGEudmFsdWVSYW5nZXMgfHwgW10pLmZvckVhY2goKHZhbHVlUmFuZ2U6IGFueSkgPT4ge1xuICAgICAgICByZXN1bHRbdmFsdWVSYW5nZS5yYW5nZV0gPSB2YWx1ZVJhbmdlLnZhbHVlcyB8fCBbXVxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGJhdGNoR2V0U2hlZXREYXRhOlwiLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGJhdGNoIGdldCBkYXRhIGZyb20gc3ByZWFkc2hlZXQgJHtzcHJlYWRzaGVldElkfS5gKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldENyZWRlbnRpYWxzKCk6IFByb21pc2U8U2hlZXRDcmVkZW50aWFsW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0U2hlZXREYXRhKFNQUkVBRFNIRUVUX0NPTkZJRy5DUkVERU5USUFMUy5pZCwgU1BSRUFEU0hFRVRfQ09ORklHLkNSRURFTlRJQUxTLnJhbmdlKVxuXG4gICAgICBpZiAoIWRhdGEudmFsdWVzIHx8IGRhdGEudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjcmVkZW50aWFscyBmb3VuZCBpbiB0aGUgc3ByZWFkc2hlZXRcIilcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBoZWFkZXIgcm93IGFuZCBtYXAgdG8gY3JlZGVudGlhbCBvYmplY3RzXG4gICAgICByZXR1cm4gZGF0YS52YWx1ZXNcbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5tYXAoKHJvdykgPT4gKHtcbiAgICAgICAgICB1c2VybmFtZTogcm93WzBdIHx8IFwiXCIsXG4gICAgICAgICAgcGFzc3dvcmQ6IHJvd1sxXSB8fCBcIlwiLFxuICAgICAgICAgIHJvbGU6IHJvd1syXSB8fCBcIlwiLFxuICAgICAgICB9KSlcbiAgICAgICAgLmZpbHRlcigoY3JlZCkgPT4gY3JlZC51c2VybmFtZSAmJiBjcmVkLnBhc3N3b3JkICYmIGNyZWQucm9sZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGNyZWRlbnRpYWxzOlwiLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBjcmVkZW50aWFscyBmcm9tIEdvb2dsZSBTaGVldHNcIilcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRQcm9qZWN0SWRzKGNsYXNzTmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGFzc0NvbmZpZyA9IHRoaXMuZ2V0Q2xhc3NDb25maWcoY2xhc3NOYW1lKVxuXG4gICAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29uZmlndXJhdGlvbiBmb3VuZCBmb3IgY2xhc3M6ICR7Y2xhc3NOYW1lfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldFNoZWV0RGF0YShjbGFzc0NvbmZpZy5pZCwgY2xhc3NDb25maWcucmFuZ2UpXG5cbiAgICAgIGlmICghZGF0YS52YWx1ZXMgfHwgZGF0YS52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGhlYWRlciByb3cgYW5kIGV4dHJhY3QgUHJvamVjdCBJRHMgZnJvbSBjb2x1bW4gRSAoaW5kZXggNClcbiAgICAgIGNvbnN0IHByb2plY3RJZHMgPSBkYXRhLnZhbHVlc1xuICAgICAgICAuc2xpY2UoMSkgLy8gU2tpcCBoZWFkZXIgcm93XG4gICAgICAgIC5tYXAoKHJvdykgPT4gcm93WzRdKSAvLyBDb2x1bW4gRSAoUHJvamVjdCBJRCkgaXMgYXQgaW5kZXggNFxuICAgICAgICAuZmlsdGVyKChpZCkgPT4gaWQgJiYgaWQudHJpbSgpICE9PSBcIlwiKSAvLyBSZW1vdmUgZW1wdHkgY2VsbHNcbiAgICAgICAgLm1hcCgoaWQpID0+IGlkLnRyaW0oKSkgLy8gQ2xlYW4gd2hpdGVzcGFjZVxuXG4gICAgICAvLyBSZXR1cm4gdW5pcXVlIHByb2plY3QgSURzIG9ubHlcbiAgICAgIHJldHVybiBbLi4ubmV3IFNldChwcm9qZWN0SWRzKV1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgcHJvamVjdCBJRHMgZm9yICR7Y2xhc3NOYW1lfTpgLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHByb2plY3QgSURzIGZvciAke2NsYXNzTmFtZX0gZnJvbSBHb29nbGUgU2hlZXRzYClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRTdHVkZW50c0J5UHJvamVjdElkKGNsYXNzTmFtZTogc3RyaW5nLCBwcm9qZWN0SWQ6IHN0cmluZyk6IFByb21pc2U8U3R1ZGVudFByb2plY3RbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGFzc0NvbmZpZyA9IHRoaXMuZ2V0Q2xhc3NDb25maWcoY2xhc3NOYW1lKVxuXG4gICAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29uZmlndXJhdGlvbiBmb3VuZCBmb3IgY2xhc3M6ICR7Y2xhc3NOYW1lfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldFNoZWV0RGF0YShjbGFzc0NvbmZpZy5pZCwgY2xhc3NDb25maWcucmFuZ2UpXG5cbiAgICAgIGlmICghZGF0YS52YWx1ZXMgfHwgZGF0YS52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGhlYWRlciByb3cgYW5kIGZpbHRlciBieSBQcm9qZWN0IElEXG4gICAgICBjb25zdCBzdHVkZW50cyA9IGRhdGEudmFsdWVzXG4gICAgICAgIC5zbGljZSgxKSAvLyBTa2lwIGhlYWRlciByb3dcbiAgICAgICAgLmZpbHRlcigocm93KSA9PiByb3dbNF0gJiYgcm93WzRdLnRyaW0oKSA9PT0gcHJvamVjdElkLnRyaW0oKSkgLy8gRmlsdGVyIGJ5IFByb2plY3QgSURcbiAgICAgICAgLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgIHNubzogcm93WzBdIHx8IFwiXCIsXG4gICAgICAgICAgc3R1ZGVudE5hbWU6IHJvd1sxXSB8fCBcIlwiLFxuICAgICAgICAgIGdyYWRlOiByb3dbMl0gfHwgXCJcIixcbiAgICAgICAgICBwcm9qZWN0VGl0bGU6IHJvd1szXSB8fCBcIlwiLFxuICAgICAgICAgIHByb2plY3RJZDogcm93WzRdIHx8IFwiXCIsXG4gICAgICAgICAgdGhlbWU6IHJvd1s1XSB8fCBcIlwiLCAvLyBBc3N1bWluZyBUaGVtZSBpcyBpbiBjb2x1bW4gRiAoaW5kZXggNSlcbiAgICAgICAgfSkpXG4gICAgICAgIC5maWx0ZXIoKHN0dWRlbnQpID0+IHN0dWRlbnQuc3R1ZGVudE5hbWUgJiYgc3R1ZGVudC5wcm9qZWN0SWQpXG5cbiAgICAgIHJldHVybiBzdHVkZW50c1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBzdHVkZW50cyBmb3IgcHJvamVjdCAke3Byb2plY3RJZH06YCwgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBzdHVkZW50cyBmb3IgcHJvamVjdCAke3Byb2plY3RJZH0gZnJvbSBHb29nbGUgU2hlZXRzYClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRKdWRnZVNjb3JlcyhjbGFzc05hbWU6IHN0cmluZywganVkZ2VOYW1lOiBzdHJpbmcsIHByb2plY3RJZD86IHN0cmluZyk6IFByb21pc2U8SnVkZ2VTY29yZVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsYXNzQ29uZmlnID0gdGhpcy5nZXRDbGFzc0NvbmZpZyhjbGFzc05hbWUpXG4gICAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29uZmlndXJhdGlvbiBmb3VuZCBmb3IgY2xhc3M6ICR7Y2xhc3NOYW1lfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGp1ZGdlU2hlZXROYW1lID0gYEp1ZGdlXyR7anVkZ2VOYW1lfWBcbiAgICAgIGNvbnN0IGp1ZGdlUmFuZ2UgPSBgJHtqdWRnZVNoZWV0TmFtZX0hQTpLYCAvLyBVcGRhdGVkIHJhbmdlIHRvIGluY2x1ZGUgVGhlbWUgRml0IChhc3N1bWluZyBjb2x1bW4gSylcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0U2hlZXREYXRhKGNsYXNzQ29uZmlnLmlkLCBqdWRnZVJhbmdlKVxuXG4gICAgICAgIGlmICghZGF0YS52YWx1ZXMgfHwgZGF0YS52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTa2lwIGhlYWRlciByb3cgYW5kIG9wdGlvbmFsbHkgZmlsdGVyIGJ5IFByb2plY3QgSURcbiAgICAgICAgbGV0IHNjb3JlcyA9IGRhdGEudmFsdWVzXG4gICAgICAgICAgLnNsaWNlKDEpIC8vIFNraXAgaGVhZGVyIHJvd1xuICAgICAgICAgIC5tYXAoKHJvdykgPT4gKHtcbiAgICAgICAgICAgIHNubzogcm93WzBdIHx8IFwiXCIsXG4gICAgICAgICAgICBzdHVkZW50TmFtZTogcm93WzFdIHx8IFwiXCIsXG4gICAgICAgICAgICBncmFkZTogcm93WzJdIHx8IFwiXCIsXG4gICAgICAgICAgICBwcm9qZWN0VGl0bGU6IHJvd1szXSB8fCBcIlwiLFxuICAgICAgICAgICAgcHJvamVjdElkOiByb3dbNF0gfHwgXCJcIixcbiAgICAgICAgICAgIGNyZWF0aXZpdHk6IHJvd1s1XSA/IE51bWJlci5wYXJzZUZsb2F0KHJvd1s1XSkgOiBudWxsLFxuICAgICAgICAgICAgc2NpZW50aWZpY1Rob3VnaHQ6IHJvd1s2XSA/IE51bWJlci5wYXJzZUZsb2F0KHJvd1s2XSkgOiBudWxsLFxuICAgICAgICAgICAgdGVjaG5pY2FsU2tpbGxzOiByb3dbN10gPyBOdW1iZXIucGFyc2VGbG9hdChyb3dbN10pIDogbnVsbCxcbiAgICAgICAgICAgIHByZXNlbnRhdGlvbjogcm93WzhdID8gTnVtYmVyLnBhcnNlRmxvYXQocm93WzhdKSA6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IHJvd1s5XSB8fCBcIlByZXNlbnRcIiwgLy8gQXNzdW1pbmcgU3RhdHVzIGlzIGluIGNvbHVtbiBKIChpbmRleCA5KSwgZGVmYXVsdCB0byBcIlByZXNlbnRcIlxuICAgICAgICAgICAgdGhlbWVGaXQ6IHJvd1sxMF0gfHwgbnVsbCwgLy8gQXNzdW1pbmcgVGhlbWUgRml0IGlzIGluIGNvbHVtbiBLIChpbmRleCAxMClcbiAgICAgICAgICB9KSlcblxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SXIEZldGNoZWQgJHtzY29yZXMubGVuZ3RofSBzY29yZXMgZnJvbSAke2p1ZGdlU2hlZXROYW1lfSBmb3IgY2xhc3MgJHtjbGFzc05hbWV9YClcblxuICAgICAgICAvLyBGaWx0ZXIgYnkgcHJvamVjdCBJRCBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHByb2plY3RJZCkge1xuICAgICAgICAgIHNjb3JlcyA9IHNjb3Jlcy5maWx0ZXIoKHNjb3JlKSA9PiBzY29yZS5wcm9qZWN0SWQudHJpbSgpID09PSBwcm9qZWN0SWQudHJpbSgpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3Jlc1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSnVkZ2Ugc2hlZXQgZG9lc24ndCBleGlzdCB5ZXQgb3IgaXMgZW1wdHksIHdoaWNoIGlzIGZpbmUgZm9yIGluaXRpYWwgZmV0Y2hcbiAgICAgICAgY29uc29sZS5sb2coYEp1ZGdlIHNoZWV0ICR7anVkZ2VTaGVldE5hbWV9IGRvZXNuJ3QgZXhpc3QgeWV0IG9yIGlzIGVtcHR5LmApXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBqdWRnZSBzY29yZXM6YCwgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBqdWRnZSBzY29yZXMgZnJvbSBHb29nbGUgU2hlZXRzYClcbiAgICB9XG4gIH1cblxuICBhc3luYyBzYXZlSnVkZ2VTY29yZXMoY2xhc3NOYW1lOiBzdHJpbmcsIGp1ZGdlTmFtZTogc3RyaW5nLCBzY29yZXM6IEp1ZGdlU2NvcmVbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGFzc0NvbmZpZyA9IHRoaXMuZ2V0Q2xhc3NDb25maWcoY2xhc3NOYW1lKVxuICAgICAgaWYgKCFjbGFzc0NvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbmZpZ3VyYXRpb24gZm91bmQgZm9yIGNsYXNzOiAke2NsYXNzTmFtZX1gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBqdWRnZVNoZWV0TmFtZSA9IGBKdWRnZV8ke2p1ZGdlTmFtZX1gXG4gICAgICBjb25zdCBqdWRnZUhlYWRlclJvdyA9IFtcbiAgICAgICAgXCJTLk5vLlwiLFxuICAgICAgICBcIk5hbWUgb2YgdGhlIFN0dWRlbnRcIixcbiAgICAgICAgXCJHcmFkZVwiLFxuICAgICAgICBcIlByb2plY3QgVGl0bGVcIixcbiAgICAgICAgXCJQcm9qZWN0IElEXCIsXG4gICAgICAgIFwiQ3JlYXRpdml0eSAmIEltYWdpbmF0aW9uXCIsXG4gICAgICAgIFwiU2NpZW50aWZpYyBUaG91Z2h0XCIsXG4gICAgICAgIFwiVGVjaG5pY2FsIFNraWxsc1wiLFxuICAgICAgICBcIlByZXNlbnRhdGlvblwiLFxuICAgICAgICBcIlN0YXR1c1wiLFxuICAgICAgICBcIlRoZW1lIEZpdFwiLCAvLyBBZGRlZCBUaGVtZSBGaXQgdG8gaGVhZGVyXG4gICAgICBdXG5cbiAgICAgIC8vIEVuc3VyZSBqdWRnZSBzaGVldCBleGlzdHMgYW5kIGhhcyBoZWFkZXJcbiAgICAgIGF3YWl0IHRoaXMuZW5zdXJlU2hlZXRFeGlzdHMoY2xhc3NDb25maWcuaWQsIGp1ZGdlU2hlZXROYW1lLCBqdWRnZUhlYWRlclJvdylcblxuICAgICAgLy8gUHJlcGFyZSBuZXcgc2NvcmUgcm93cyBmb3IgYXBwZW5kaW5nXG4gICAgICBjb25zdCBuZXdSb3dzID0gc2NvcmVzLm1hcCgoc2NvcmUpID0+IFtcbiAgICAgICAgc2NvcmUuc25vLFxuICAgICAgICBzY29yZS5zdHVkZW50TmFtZSxcbiAgICAgICAgc2NvcmUuZ3JhZGUsXG4gICAgICAgIHNjb3JlLnByb2plY3RUaXRsZSxcbiAgICAgICAgc2NvcmUucHJvamVjdElkLFxuICAgICAgICBzY29yZS5jcmVhdGl2aXR5Py50b1N0cmluZygpIHx8IFwiXCIsXG4gICAgICAgIHNjb3JlLnNjaWVudGlmaWNUaG91Z2h0Py50b1N0cmluZygpIHx8IFwiXCIsXG4gICAgICAgIHNjb3JlLnRlY2huaWNhbFNraWxscz8udG9TdHJpbmcoKSB8fCBcIlwiLFxuICAgICAgICBzY29yZS5wcmVzZW50YXRpb24/LnRvU3RyaW5nKCkgfHwgXCJcIixcbiAgICAgICAgc2NvcmUuc3RhdHVzIHx8IFwiUHJlc2VudFwiLCAvLyBJbmNsdWRlIHN0YXR1c1xuICAgICAgICBzY29yZS50aGVtZUZpdCB8fCBcIlwiLCAvLyBJbmNsdWRlIHRoZW1lRml0XG4gICAgICBdKVxuXG4gICAgICAvLyBBcHBlbmQgbmV3IHNjb3JlcyAobmV2ZXIgb3ZlcndyaXRlKVxuICAgICAgYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5hcHBlbmQoe1xuICAgICAgICBzcHJlYWRzaGVldElkOiBjbGFzc0NvbmZpZy5pZCxcbiAgICAgICAgcmFuZ2U6IGAke2p1ZGdlU2hlZXROYW1lfSFBOktgLCAvLyBVcGRhdGVkIHJhbmdlIGZvciBhcHBlbmRpbmdcbiAgICAgICAgdmFsdWVJbnB1dE9wdGlvbjogXCJVU0VSX0VOVEVSRURcIixcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICB2YWx1ZXM6IG5ld1Jvd3MsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIEFwcGVuZGVkICR7bmV3Um93cy5sZW5ndGh9IG5ldyBzY29yZSByb3dzIHRvICR7anVkZ2VTaGVldE5hbWV9YClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYXBwZW5kaW5nIGp1ZGdlIHNjb3JlczpgLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGFwcGVuZCBqdWRnZSBzY29yZXMgdG8gR29vZ2xlIFNoZWV0c2ApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRFeGlzdGluZ0p1ZGdlRGF0YShzcHJlYWRzaGVldElkOiBzdHJpbmcsIHNoZWV0TmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5nZXQoe1xuICAgICAgICBzcHJlYWRzaGVldElkLFxuICAgICAgICByYW5nZTogYCR7c2hlZXROYW1lfSFBOktgLCAvLyBVcGRhdGVkIHJhbmdlXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEudmFsdWVzIHx8IFtdXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFNoZWV0IGRvZXNuJ3QgZXhpc3Qgb3IgaXMgZW1wdHlcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZW5zdXJlU2hlZXRFeGlzdHMoc3ByZWFkc2hlZXRJZDogc3RyaW5nLCBzaGVldE5hbWU6IHN0cmluZywgaGVhZGVyUm93Pzogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3ByZWFkc2hlZXQgPSBhd2FpdCB0aGlzLnNoZWV0cy5zcHJlYWRzaGVldHMuZ2V0KHtcbiAgICAgICAgc3ByZWFkc2hlZXRJZDogc3ByZWFkc2hlZXRJZCxcbiAgICAgICAgZmllbGRzOiBcInNoZWV0cy5wcm9wZXJ0aWVzLnRpdGxlLHNoZWV0cy5wcm9wZXJ0aWVzLnNoZWV0SWRcIixcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHNoZWV0RXhpc3RzID0gc3ByZWFkc2hlZXQuZGF0YS5zaGVldHM/LnNvbWUoKHNoZWV0OiBhbnkpID0+IHNoZWV0LnByb3BlcnRpZXMudGl0bGUgPT09IHNoZWV0TmFtZSlcblxuICAgICAgaWYgKCFzaGVldEV4aXN0cykge1xuICAgICAgICBhd2FpdCB0aGlzLnNoZWV0cy5zcHJlYWRzaGVldHMuYmF0Y2hVcGRhdGUoe1xuICAgICAgICAgIHNwcmVhZHNoZWV0SWQ6IHNwcmVhZHNoZWV0SWQsXG4gICAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgIHJlcXVlc3RzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhZGRTaGVldDoge1xuICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc2hlZXROYW1lLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIENyZWF0ZWQgbmV3IHNoZWV0OiAke3NoZWV0TmFtZX0gaW4gc3ByZWFkc2hlZXQgJHtzcHJlYWRzaGVldElkfWApXG5cbiAgICAgICAgLy8gSWYgaGVhZGVyIHJvdyBpcyBwcm92aWRlZCwgd3JpdGUgaXRcbiAgICAgICAgaWYgKGhlYWRlclJvdyAmJiBoZWFkZXJSb3cubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc2hlZXRzLnNwcmVhZHNoZWV0cy52YWx1ZXMuYXBwZW5kKHtcbiAgICAgICAgICAgIHNwcmVhZHNoZWV0SWQ6IHNwcmVhZHNoZWV0SWQsXG4gICAgICAgICAgICByYW5nZTogYCR7c2hlZXROYW1lfSFBMWAsXG4gICAgICAgICAgICB2YWx1ZUlucHV0T3B0aW9uOiBcIlVTRVJfRU5URVJFRFwiLFxuICAgICAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgICAgdmFsdWVzOiBbaGVhZGVyUm93XSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEFkZGVkIGhlYWRlciB0byBuZXcgc2hlZXQ6ICR7c2hlZXROYW1lfWApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZW5zdXJpbmcgc2hlZXQgJHtzaGVldE5hbWV9IGV4aXN0cyBpbiAke3NwcmVhZHNoZWV0SWR9OmAsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIG9yIHZlcmlmeSBzaGVldDogJHtzaGVldE5hbWV9YClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRBbGxTaGVldFRpdGxlcyhzcHJlYWRzaGVldElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLmdldCh7XG4gICAgICAgIHNwcmVhZHNoZWV0SWQ6IHNwcmVhZHNoZWV0SWQsXG4gICAgICAgIGZpZWxkczogXCJzaGVldHMucHJvcGVydGllcy50aXRsZVwiLFxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnNoZWV0cz8ubWFwKChzaGVldDogYW55KSA9PiBzaGVldC5wcm9wZXJ0aWVzLnRpdGxlKSB8fCBbXVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBzaGVldCB0aXRsZXMgZm9yICR7c3ByZWFkc2hlZXRJZH06YCwgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBzaGVldCB0aXRsZXMgZm9yIHNwcmVhZHNoZWV0ICR7c3ByZWFkc2hlZXRJZH0uYClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRBbGxKdWRnZVNoZWV0TmFtZXMoY2xhc3NTcHJlYWRzaGVldElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgYWxsU2hlZXRUaXRsZXMgPSBhd2FpdCB0aGlzLmdldEFsbFNoZWV0VGl0bGVzKGNsYXNzU3ByZWFkc2hlZXRJZClcbiAgICByZXR1cm4gYWxsU2hlZXRUaXRsZXMuZmlsdGVyKCh0aXRsZSkgPT4gdGl0bGUuc3RhcnRzV2l0aChcIkp1ZGdlX1wiKSlcbiAgfVxuXG4gIGFzeW5jIGdldFByb2plY3REZXRhaWxzTWFwKFxuICAgIGNsYXNzTmFtZTogc3RyaW5nLFxuICApOiBQcm9taXNlPE1hcDxzdHJpbmcsIHsgdGl0bGU6IHN0cmluZzsgdGhlbWU6IHN0cmluZzsgc3R1ZGVudE5hbWVzOiBTZXQ8c3RyaW5nPiB9Pj4ge1xuICAgIGNvbnN0IGNsYXNzQ29uZmlnID0gdGhpcy5nZXRDbGFzc0NvbmZpZyhjbGFzc05hbWUpXG4gICAgaWYgKCFjbGFzc0NvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBjb25maWd1cmF0aW9uIGZvdW5kIGZvciBjbGFzczogJHtjbGFzc05hbWV9YClcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRTaGVldERhdGEoY2xhc3NDb25maWcuaWQsIGNsYXNzQ29uZmlnLnJhbmdlKSAvLyBSZWFkcyBTaGVldDEhQTpGXG5cbiAgICBjb25zdCBwcm9qZWN0TWFwID0gbmV3IE1hcDxzdHJpbmcsIHsgdGl0bGU6IHN0cmluZzsgdGhlbWU6IHN0cmluZzsgc3R1ZGVudE5hbWVzOiBTZXQ8c3RyaW5nPiB9PigpXG4gICAgaWYgKGRhdGEudmFsdWVzICYmIGRhdGEudmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFNraXAgaGVhZGVyXG4gICAgICBkYXRhLnZhbHVlcy5zbGljZSgxKS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gcm93WzRdPy50cmltKCkgLy8gQ29sdW1uIEVcbiAgICAgICAgY29uc3QgcHJvamVjdFRpdGxlID0gcm93WzNdPy50cmltKCkgLy8gQ29sdW1uIERcbiAgICAgICAgY29uc3QgdGhlbWUgPSByb3dbNV0/LnRyaW0oKSAvLyBDb2x1bW4gRlxuICAgICAgICBjb25zdCBzdHVkZW50TmFtZSA9IHJvd1sxXT8udHJpbSgpIC8vIENvbHVtbiBCXG5cbiAgICAgICAgaWYgKHByb2plY3RJZCkge1xuICAgICAgICAgIGlmICghcHJvamVjdE1hcC5oYXMocHJvamVjdElkKSkge1xuICAgICAgICAgICAgcHJvamVjdE1hcC5zZXQocHJvamVjdElkLCB7XG4gICAgICAgICAgICAgIHRpdGxlOiBwcm9qZWN0VGl0bGUgfHwgXCJcIixcbiAgICAgICAgICAgICAgdGhlbWU6IHRoZW1lIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHN0dWRlbnROYW1lczogbmV3IFNldDxzdHJpbmc+KCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3R1ZGVudE5hbWUpIHtcbiAgICAgICAgICAgIHByb2plY3RNYXAuZ2V0KHByb2plY3RJZCk/LnN0dWRlbnROYW1lcy5hZGQoc3R1ZGVudE5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcHJvamVjdE1hcFxuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc0NsYXNzU2NvcmVzKGNsYXNzTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY2xhc3NDb25maWcgPSB0aGlzLmdldENsYXNzQ29uZmlnKGNsYXNzTmFtZSlcbiAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbmZpZ3VyYXRpb24gZm91bmQgZm9yIGNsYXNzOiAke2NsYXNzTmFtZX1gKVxuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzU3ByZWFkc2hlZXRJZCA9IGNsYXNzQ29uZmlnLmlkXG4gICAgY29uc3QgcHJvamVjdERldGFpbHNNYXAgPSBhd2FpdCB0aGlzLmdldFByb2plY3REZXRhaWxzTWFwKGNsYXNzTmFtZSlcbiAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gRm91bmQgJHtwcm9qZWN0RGV0YWlsc01hcC5zaXplfSB1bmlxdWUgcHJvamVjdHMgZnJvbSBCYXNlU2hlZXQuYClcblxuICAgIGNvbnN0IGp1ZGdlU2hlZXROYW1lcyA9IGF3YWl0IHRoaXMuZ2V0QWxsSnVkZ2VTaGVldE5hbWVzKGNsYXNzU3ByZWFkc2hlZXRJZClcbiAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gRm91bmQgJHtqdWRnZVNoZWV0TmFtZXMubGVuZ3RofSBqdWRnZSBzaGVldHMuYClcblxuICAgIC8vIE1hcCB0byBzdG9yZSB0aGUgbGF0ZXN0IHNjb3JlIGZvciBlYWNoIHByb2plY3QgYnkgZWFjaCBqdWRnZVxuICAgIGNvbnN0IGxhdGVzdFByb2plY3RTY29yZXNCeUp1ZGdlID0gbmV3IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIEp1ZGdlU2NvcmU+PigpIC8vIHByb2plY3RJZCAtPiAoanVkZ2VOYW1lIC0+IGxhdGVzdFNjb3JlKVxuXG4gICAgICAgIGNvbnN0IGp1ZGdlUmFuZ2VzID0ganVkZ2VTaGVldE5hbWVzLm1hcChqdWRnZVNoZWV0TmFtZSA9PiBgJHtqdWRnZVNoZWV0TmFtZX0hQTpLYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwianVkZ2VSYW5nZU1BZGR5XCIpO1xuICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBGZXRjaGluZyBkYXRhIGZvciBqdWRnZVJhbmdlTUFkZHkgc2hlZXRzOiAke2p1ZGdlUmFuZ2VzfWApO1xuXG4gICAgY29uc3QgYmF0Y2hEYXRhID0gYXdhaXQgdGhpcy5iYXRjaEdldFNoZWV0RGF0YShjbGFzc1NwcmVhZHNoZWV0SWQsIGp1ZGdlUmFuZ2VzKTtcbiAgICBjb25zb2xlLmxvZyhcImJhdGNoRGF0YTpcIiwgSlNPTi5zdHJpbmdpZnkoYmF0Y2hEYXRhLCBudWxsLCAyKSk7XG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIEZldGNoZWRNYWRkeSBkYXRhIGZvciAke2p1ZGdlUmFuZ2VzLmxlbmd0aH0gJHtqdWRnZVJhbmdlc30gJHtiYXRjaERhdGF9IGp1ZGdlIHNoZWV0cyBpbiBiYXRjaC5gKVxuICAgIFxuICAgIGZvciAoY29uc3QganVkZ2VTaGVldE5hbWUgb2YganVkZ2VTaGVldE5hbWVzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gUHJvY2Vzc2luZyBqdWRnZSBzaGVldCBtYWRkeTogJHtqdWRnZVNoZWV0TmFtZX1gKTtcbiAgICAgIGNvbnN0IGp1ZGdlTmFtZSA9IGp1ZGdlU2hlZXROYW1lLnJlcGxhY2UoXCJKdWRnZV9cIiwgXCJcIik7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBiYXRjaERhdGFbYCR7anVkZ2VTaGVldE5hbWV9IUExOksxMDAwYF0gfHwgW107XG4gICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gRm91bmRNQWRkeXMgJHt2YWx1ZXMubGVuZ3RofSByb3dzIGluIHNoZWV0ICR7anVkZ2VTaGVldE5hbWV9IGZvciBKdWRnZSAke2p1ZGdlTmFtZX0uYCk7XG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA8PSAxKSBjb250aW51ZTsgLy8gc2tpcCBpZiBvbmx5IGhlYWRlciBvciBlbXB0eVxuICAgIFxuICAgICAgLy8gUGFyc2Ugc2NvcmVzIGFzIGluIGdldEp1ZGdlU2NvcmVzXG4gICAgICBjb25zdCBzY29yZXNGb3JKdWRnZSA9IHZhbHVlc1xuICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgIHNubzogcm93WzBdIHx8IFwiXCIsXG4gICAgICAgICAgc3R1ZGVudE5hbWU6IHJvd1sxXSB8fCBcIlwiLFxuICAgICAgICAgIGdyYWRlOiByb3dbMl0gfHwgXCJcIixcbiAgICAgICAgICBwcm9qZWN0VGl0bGU6IHJvd1szXSB8fCBcIlwiLFxuICAgICAgICAgIHByb2plY3RJZDogcm93WzRdIHx8IFwiXCIsXG4gICAgICAgICAgY3JlYXRpdml0eTogcm93WzVdID8gTnVtYmVyLnBhcnNlRmxvYXQocm93WzVdKSA6IG51bGwsXG4gICAgICAgICAgc2NpZW50aWZpY1Rob3VnaHQ6IHJvd1s2XSA/IE51bWJlci5wYXJzZUZsb2F0KHJvd1s2XSkgOiBudWxsLFxuICAgICAgICAgIHRlY2huaWNhbFNraWxsczogcm93WzddID8gTnVtYmVyLnBhcnNlRmxvYXQocm93WzddKSA6IG51bGwsXG4gICAgICAgICAgcHJlc2VudGF0aW9uOiByb3dbOF0gPyBOdW1iZXIucGFyc2VGbG9hdChyb3dbOF0pIDogbnVsbCxcbiAgICAgICAgICBzdGF0dXM6IHJvd1s5XSB8fCBcIlByZXNlbnRcIixcbiAgICAgICAgICB0aGVtZUZpdDogcm93WzEwXSB8fCBudWxsLFxuICAgICAgICB9KSlcblxuICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBGb3VuZE1hZGR5ICR7c2NvcmVzRm9ySnVkZ2UubGVuZ3RofSBzY29yZXMgZm9yIEp1ZGdlICR7anVkZ2VOYW1lfSBpbiBzaGVldCAke2p1ZGdlU2hlZXROYW1lfS5gKTtcbiAgICAgIFxuICAgIGZvciAoY29uc3Qgc2NvcmUgb2Ygc2NvcmVzRm9ySnVkZ2UpIHtcbiAgICAgICAgY29uc3QgcElkID0gc2NvcmUucHJvamVjdElkLnRyaW0oKTtcbiAgICAgICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIFByb2Nlc3Npbmcgc2NvcmUgZm9yIFByb2plY3QgJHtwSWR9IGJ5IEp1ZGdlICR7anVkZ2VOYW1lfTpgLCBzY29yZSk7XG4gICAgICAgIGlmICghbGF0ZXN0UHJvamVjdFNjb3Jlc0J5SnVkZ2UuaGFzKHBJZCkpIHtcbiAgICAgICAgICBsYXRlc3RQcm9qZWN0U2NvcmVzQnlKdWRnZS5zZXQocElkLCBuZXcgTWFwPHN0cmluZywgSnVkZ2VTY29yZT4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGF0ZXN0UHJvamVjdFNjb3Jlc0J5SnVkZ2UuZ2V0KHBJZCk/LnNldChqdWRnZU5hbWUsIHNjb3JlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIENvbGxlY3RlZCBsYXRlc3Qgc2NvcmVzIGZvciBwcm9qZWN0cyBmcm9tIGVhY2gganVkZ2UuYClcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBbJHtjbGFzc05hbWV9XSBsYXRlc3RQcm9qZWN0U2NvcmVzQnlKdWRnZSBmb3IgYSBzYW1wbGUgcHJvamVjdCAoZS5nLiwgUDQwMDEpOmAsXG4gICAgICBsYXRlc3RQcm9qZWN0U2NvcmVzQnlKdWRnZS5nZXQoXCJQNDAwMVwiKSxcbiAgICApXG5cbiAgICAvLyBBZ2dyZWdhdGUgc2NvcmVzIHBlciBwcm9qZWN0XG4gICAgY29uc3QgcHJvamVjdEFnZ3JlZ2F0ZWRTY29yZXM6IHtcbiAgICAgIFtwcm9qZWN0SWQ6IHN0cmluZ106IHtcbiAgICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgICAgdGhlbWU6IHN0cmluZ1xuICAgICAgICBjcmVhdGl2aXR5U3VtOiBudW1iZXJcbiAgICAgICAgc2NpZW50aWZpY1Rob3VnaHRTdW06IG51bWJlclxuICAgICAgICB0ZWNobmljYWxTa2lsbHNTdW06IG51bWJlclxuICAgICAgICBwcmVzZW50YXRpb25TdW06IG51bWJlclxuICAgICAgICBqdWRnZUNvdW50OiBudW1iZXIgLy8gTnVtYmVyIG9mIGp1ZGdlcyB3aG8gc2NvcmVkIHRoaXMgcHJvamVjdCBhcyBQcmVzZW50XG4gICAgICAgIGFic2VudENvdW50OiBudW1iZXIgLy8gTnVtYmVyIG9mIGp1ZGdlcyB3aG8gbWFya2VkIHRoaXMgcHJvamVjdCBBYnNlbnRcbiAgICAgICAgc3R1ZGVudE5hbWVzOiBzdHJpbmdbXSAvLyBUbyBjb2xsZWN0IGFsbCBzdHVkZW50IG5hbWVzIGZvciB0aGlzIHByb2plY3RcbiAgICAgIH1cbiAgICB9ID0ge31cblxuICAgIC8vIEluaXRpYWxpemUgcHJvamVjdEFnZ3JlZ2F0ZWRTY29yZXMgd2l0aCBkZXRhaWxzIGZyb20gQmFzZVNoZWV0XG4gICAgZm9yIChjb25zdCBbcElkLCBkZXRhaWxzXSBvZiBwcm9qZWN0RGV0YWlsc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW3BJZF0gPSB7XG4gICAgICAgIHByb2plY3RUaXRsZTogZGV0YWlscy50aXRsZSxcbiAgICAgICAgdGhlbWU6IGRldGFpbHMudGhlbWUsXG4gICAgICAgIGNyZWF0aXZpdHlTdW06IDAsXG4gICAgICAgIHNjaWVudGlmaWNUaG91Z2h0U3VtOiAwLFxuICAgICAgICB0ZWNobmljYWxTa2lsbHNTdW06IDAsXG4gICAgICAgIHByZXNlbnRhdGlvblN1bTogMCxcbiAgICAgICAganVkZ2VDb3VudDogMCxcbiAgICAgICAgYWJzZW50Q291bnQ6IDAsXG4gICAgICAgIHN0dWRlbnROYW1lczogQXJyYXkuZnJvbShkZXRhaWxzLnN0dWRlbnROYW1lcykuc29ydCgpLFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBvcHVsYXRlIGFnZ3JlZ2F0ZWQgc2NvcmVzIGZyb20ganVkZ2Ugc3VibWlzc2lvbnNcbiAgICBmb3IgKGNvbnN0IFtwSWQsIGp1ZGdlU2NvcmVzTWFwXSBvZiBsYXRlc3RQcm9qZWN0U2NvcmVzQnlKdWRnZS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBQcm9jZXNzaW5nIHNjb3JlcyBmb3IgUHJvamVjdCAke3BJZH0gZnJvbSBqdWRnZXM6YCwgQXJyYXkuZnJvbShqdWRnZVNjb3Jlc01hcC5rZXlzKCkpKVxuICAgICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIGp1ZGdlU2NvcmVzTWFwIGZvciBQcm9qZWN0ICR7cElkfSBoYXMgJHtqdWRnZVNjb3Jlc01hcC5zaXplfSBlbnRyaWVzLmApXG4gICAgICBpZiAoIXByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW3BJZF0pIHtcbiAgICAgICAgLy8gVGhpcyBwcm9qZWN0IHdhcyBzY29yZWQgYnV0IG5vdCBmb3VuZCBpbiBCYXNlU2hlZXQgKGUuZy4sIGlmIEJhc2VTaGVldCBpcyBpbmNvbXBsZXRlKVxuICAgICAgICAvLyBUcnkgdG8gZ2V0IGRldGFpbHMgZnJvbSB0aGUgZmlyc3Qgc2NvcmUgZW50cnkgZm9yIHRoaXMgcHJvamVjdFxuICAgICAgICBjb25zdCBmaXJzdFNjb3JlID0gQXJyYXkuZnJvbShqdWRnZVNjb3Jlc01hcC52YWx1ZXMoKSlbMF1cbiAgICAgICAgcHJvamVjdEFnZ3JlZ2F0ZWRTY29yZXNbcElkXSA9IHtcbiAgICAgICAgICBwcm9qZWN0VGl0bGU6IGZpcnN0U2NvcmU/LnByb2plY3RUaXRsZSB8fCBcIlwiLFxuICAgICAgICAgIHRoZW1lOiBwcm9qZWN0RGV0YWlsc01hcC5nZXQocElkKT8udGhlbWUgfHwgXCJcIiwgLy8gRmFsbGJhY2sgdG8gQmFzZVNoZWV0IHRoZW1lIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGNyZWF0aXZpdHlTdW06IDAsXG4gICAgICAgICAgc2NpZW50aWZpY1Rob3VnaHRTdW06IDAsXG4gICAgICAgICAgdGVjaG5pY2FsU2tpbGxzU3VtOiAwLFxuICAgICAgICAgIHByZXNlbnRhdGlvblN1bTogMCxcbiAgICAgICAgICBqdWRnZUNvdW50OiAwLFxuICAgICAgICAgIGFic2VudENvdW50OiAwLFxuICAgICAgICAgIHN0dWRlbnROYW1lczogW10sIC8vIENhbm5vdCByZWxpYWJseSBnZXQgYWxsIHN0dWRlbnQgbmFtZXMgaWYgbm90IGluIEJhc2VTaGVldFxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgWyR7Y2xhc3NOYW1lfV0gUHJvamVjdCAke3BJZH0gZm91bmQgaW4ganVkZ2Ugc2hlZXRzIGJ1dCBub3QgaW4gQmFzZVNoZWV0LiBTdHVkZW50IG5hbWVzIG1pZ2h0IGJlIGluY29tcGxldGUuYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbanVkZ2VOYW1lLCBzY29yZV0gb2YganVkZ2VTY29yZXNNYXAuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChzY29yZS5zdGF0dXMgPT09IFwiQWJzZW50XCIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gSnVkZ2UgJHtqdWRnZU5hbWV9IG1hcmtlZCBQcm9qZWN0ICR7cElkfSBhcyBBYnNlbnQuYClcbiAgICAgICAgICBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdLmFic2VudENvdW50KytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQcmVzZW50XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgWyR7Y2xhc3NOYW1lfV0gQWRkaW5nIHNjb3JlIGZvciBQcm9qZWN0ICR7cElkfSBieSBKdWRnZSAke2p1ZGdlTmFtZX06IENyZWF0aXZpdHk9JHtzY29yZS5jcmVhdGl2aXR5fSwgU2NpZW50aWZpY1Rob3VnaHQ9JHtzY29yZS5zY2llbnRpZmljVGhvdWdodH0sIFRlY2huaWNhbFNraWxscz0ke3Njb3JlLnRlY2huaWNhbFNraWxsc30sIFByZXNlbnRhdGlvbj0ke3Njb3JlLnByZXNlbnRhdGlvbn1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdLmp1ZGdlQ291bnQrK1xuICAgICAgICAgIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW3BJZF0uY3JlYXRpdml0eVN1bSArPSBzY29yZS5jcmVhdGl2aXR5IHx8IDBcbiAgICAgICAgICBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdLnNjaWVudGlmaWNUaG91Z2h0U3VtICs9IHNjb3JlLnNjaWVudGlmaWNUaG91Z2h0IHx8IDBcbiAgICAgICAgICBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdLnRlY2huaWNhbFNraWxsc1N1bSArPSBzY29yZS50ZWNobmljYWxTa2lsbHMgfHwgMFxuICAgICAgICAgIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW3BJZF0ucHJlc2VudGF0aW9uU3VtICs9IHNjb3JlLnByZXNlbnRhdGlvbiB8fCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIEFnZ3JlZ2F0aW9uIGNvbXBsZXRlIGZvciBwcm9qZWN0IHNjb3Jlcy5gKVxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFske2NsYXNzTmFtZX1dIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzIGZvciBhIHNhbXBsZSBwcm9qZWN0IChlLmcuLCBQNDAwMSk6YCxcbiAgICAgIHByb2plY3RBZ2dyZWdhdGVkU2NvcmVzW1wiUDQwMDFcIl0sXG4gICAgKVxuXG4gICAgLy8gQ2FsY3VsYXRlIHByb2plY3QgYXZlcmFnZXMgYW5kIHByZXBhcmUgcm93cyBmb3IgXCJTY29yZVwiIHRhYlxuICAgIGNvbnN0IHNjb3JlVGFiUm93czogc3RyaW5nW11bXSA9IFtdXG4gICAgc2NvcmVUYWJSb3dzLnB1c2goW1xuICAgICAgXCJQcm9qZWN0IElEXCIsXG4gICAgICBcIlByb2plY3QgVGl0bGVcIixcbiAgICAgIFwiVGhlbWVcIixcbiAgICAgIFwiQXZnIENyZWF0aXZpdHlcIixcbiAgICAgIFwiQXZnIFNjaWVudGlmaWMgVGhvdWdodFwiLFxuICAgICAgXCJBdmcgVGVjaG5pY2FsIFNraWxsc1wiLFxuICAgICAgXCJBdmcgUHJlc2VudGF0aW9uXCIsXG4gICAgICBcIlByb2plY3QgQXZlcmFnZSBTY29yZVwiLFxuICAgICAgXCJTdHVkZW50IE5hbWVzXCIsXG4gICAgXSkgLy8gTmV3IEhlYWRlciBmb3IgU2NvcmUgdGFiXG5cbiAgICBjb25zdCBwcm9qZWN0c0ZvclNjb3JlVGFiOiBBcnJheTx7XG4gICAgICBwcm9qZWN0SWQ6IHN0cmluZ1xuICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgIHRoZW1lOiBzdHJpbmdcbiAgICAgIGF2Z0NyZWF0aXZpdHk6IG51bWJlclxuICAgICAgYXZnU2NpZW50aWZpY1Rob3VnaHQ6IG51bWJlclxuICAgICAgYXZnVGVjaG5pY2FsU2tpbGxzOiBudW1iZXJcbiAgICAgIGF2Z1ByZXNlbnRhdGlvbjogbnVtYmVyXG4gICAgICBwcm9qZWN0QXZnU2NvcmU6IG51bWJlclxuICAgICAgc3R1ZGVudE5hbWVzOiBzdHJpbmdcbiAgICB9PiA9IFtdXG5cbiAgICBmb3IgKGNvbnN0IHBJZCBpbiBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlcykge1xuICAgICAgY29uc3QgcHJvamVjdERhdGEgPSBwcm9qZWN0QWdncmVnYXRlZFNjb3Jlc1twSWRdXG4gICAgICBsZXQgYXZnQ3JlYXRpdml0eSA9IDBcbiAgICAgIGxldCBhdmdTY2llbnRpZmljVGhvdWdodCA9IDBcbiAgICAgIGxldCBhdmdUZWNobmljYWxTa2lsbHMgPSAwXG4gICAgICBsZXQgYXZnUHJlc2VudGF0aW9uID0gMFxuICAgICAgbGV0IHByb2plY3RBdmdTY29yZSA9IDBcblxuICAgICAgaWYgKHByb2plY3REYXRhLmp1ZGdlQ291bnQgPiAwKSB7XG4gICAgICAgIGF2Z0NyZWF0aXZpdHkgPSBwcm9qZWN0RGF0YS5jcmVhdGl2aXR5U3VtIC8gcHJvamVjdERhdGEuanVkZ2VDb3VudFxuICAgICAgICBhdmdTY2llbnRpZmljVGhvdWdodCA9IHByb2plY3REYXRhLnNjaWVudGlmaWNUaG91Z2h0U3VtIC8gcHJvamVjdERhdGEuanVkZ2VDb3VudFxuICAgICAgICBhdmdUZWNobmljYWxTa2lsbHMgPSBwcm9qZWN0RGF0YS50ZWNobmljYWxTa2lsbHNTdW0gLyBwcm9qZWN0RGF0YS5qdWRnZUNvdW50XG4gICAgICAgIGF2Z1ByZXNlbnRhdGlvbiA9IHByb2plY3REYXRhLnByZXNlbnRhdGlvblN1bSAvIHByb2plY3REYXRhLmp1ZGdlQ291bnRcbiAgICAgICAgcHJvamVjdEF2Z1Njb3JlID0gKGF2Z0NyZWF0aXZpdHkgKyBhdmdTY2llbnRpZmljVGhvdWdodCArIGF2Z1RlY2huaWNhbFNraWxscyArIGF2Z1ByZXNlbnRhdGlvbikgLyA0XG4gICAgICB9IGVsc2UgaWYgKHByb2plY3REYXRhLmFic2VudENvdW50ID4gMCAmJiBwcm9qZWN0RGF0YS5qdWRnZUNvdW50ID09PSAwKSB7XG4gICAgICAgIC8vIEFsbCBqdWRnZXMgbWFya2VkIHByb2plY3QgYWJzZW50LCBzbyBhbGwgc2NvcmVzIGFyZSAwXG4gICAgICAgIGF2Z0NyZWF0aXZpdHkgPSAwXG4gICAgICAgIGF2Z1NjaWVudGlmaWNUaG91Z2h0ID0gMFxuICAgICAgICBhdmdUZWNobmljYWxTa2lsbHMgPSAwXG4gICAgICAgIGF2Z1ByZXNlbnRhdGlvbiA9IDBcbiAgICAgICAgcHJvamVjdEF2Z1Njb3JlID0gMFxuICAgICAgfVxuICAgICAgLy8gSWYgbm8ganVkZ2VzIHNjb3JlZCB0aGUgcHJvamVjdCAoanVkZ2VDb3VudCBhbmQgYWJzZW50Q291bnQgYXJlIDApLCBhbGwgYXZlcmFnZXMgcmVtYWluIDAgKGluaXRpYWxpemVkKVxuXG4gICAgICBwcm9qZWN0c0ZvclNjb3JlVGFiLnB1c2goe1xuICAgICAgICBwcm9qZWN0SWQ6IHBJZCxcbiAgICAgICAgcHJvamVjdFRpdGxlOiBwcm9qZWN0RGF0YS5wcm9qZWN0VGl0bGUsXG4gICAgICAgIHRoZW1lOiBwcm9qZWN0RGF0YS50aGVtZSxcbiAgICAgICAgYXZnQ3JlYXRpdml0eTogYXZnQ3JlYXRpdml0eSxcbiAgICAgICAgYXZnU2NpZW50aWZpY1Rob3VnaHQ6IGF2Z1NjaWVudGlmaWNUaG91Z2h0LFxuICAgICAgICBhdmdUZWNobmljYWxTa2lsbHM6IGF2Z1RlY2huaWNhbFNraWxscyxcbiAgICAgICAgYXZnUHJlc2VudGF0aW9uOiBhdmdQcmVzZW50YXRpb24sXG4gICAgICAgIHByb2plY3RBdmdTY29yZTogcHJvamVjdEF2Z1Njb3JlLFxuICAgICAgICBzdHVkZW50TmFtZXM6IHByb2plY3REYXRhLnN0dWRlbnROYW1lcy5qb2luKFwiLCBcIiksIC8vIEpvaW4gc3R1ZGVudCBuYW1lc1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBTb3J0IHByb2plY3RzIGZvciB0aGUgU2NvcmUgdGFiIGJ5IFByb2plY3QgSUQgZm9yIGNvbnNpc3RlbnQgb3JkZXJpbmdcbiAgICBwcm9qZWN0c0ZvclNjb3JlVGFiLnNvcnQoKGEsIGIpID0+IGEucHJvamVjdElkLmxvY2FsZUNvbXBhcmUoYi5wcm9qZWN0SWQpKVxuXG4gICAgcHJvamVjdHNGb3JTY29yZVRhYi5mb3JFYWNoKChwcm9qZWN0KSA9PiB7XG4gICAgICBzY29yZVRhYlJvd3MucHVzaChbXG4gICAgICAgIHByb2plY3QucHJvamVjdElkLFxuICAgICAgICBwcm9qZWN0LnByb2plY3RUaXRsZSxcbiAgICAgICAgcHJvamVjdC50aGVtZSxcbiAgICAgICAgcHJvamVjdC5hdmdDcmVhdGl2aXR5LnRvRml4ZWQoMiksXG4gICAgICAgIHByb2plY3QuYXZnU2NpZW50aWZpY1Rob3VnaHQudG9GaXhlZCgyKSxcbiAgICAgICAgcHJvamVjdC5hdmdUZWNobmljYWxTa2lsbHMudG9GaXhlZCgyKSxcbiAgICAgICAgcHJvamVjdC5hdmdQcmVzZW50YXRpb24udG9GaXhlZCgyKSxcbiAgICAgICAgcHJvamVjdC5wcm9qZWN0QXZnU2NvcmUudG9GaXhlZCgyKSxcbiAgICAgICAgcHJvamVjdC5zdHVkZW50TmFtZXMsXG4gICAgICBdKVxuICAgIH0pXG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIFByZXBhcmVkICR7c2NvcmVUYWJSb3dzLmxlbmd0aCAtIDF9IHJvd3MgZm9yIFwiU2NvcmVcIiB0YWIgKGV4Y2x1ZGluZyBoZWFkZXIpLmApXG4gICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIEZpbmFsIHNjb3JlVGFiUm93cyBiZWZvcmUgd3JpdGluZzpgLCBzY29yZVRhYlJvd3MpXG5cbiAgICBjb25zdCBzY29yZVNoZWV0TmFtZSA9IFwiU2NvcmVcIlxuICAgIGF3YWl0IHRoaXMuZW5zdXJlU2hlZXRFeGlzdHMoY2xhc3NTcHJlYWRzaGVldElkLCBzY29yZVNoZWV0TmFtZSwgc2NvcmVUYWJSb3dzWzBdKSAvLyBQYXNzIGhlYWRlciBmb3IgY3JlYXRpb25cblxuICAgIC8vIENsZWFyIGV4aXN0aW5nIGNvbnRlbnQgYmVmb3JlIHdyaXRpbmcgbmV3IGRhdGEgKGV4Y2x1ZGluZyBoZWFkZXIpXG4gICAgYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5jbGVhcih7XG4gICAgICBzcHJlYWRzaGVldElkOiBjbGFzc1NwcmVhZHNoZWV0SWQsXG4gICAgICByYW5nZTogYCR7c2NvcmVTaGVldE5hbWV9IUEyOklgLCAvLyBDbGVhciBmcm9tIHJvdyAyIG9ud2FyZHMsIHVwIHRvIGNvbHVtbiBJXG4gICAgfSlcblxuICAgIC8vIFdyaXRlIG5ldyBkYXRhIChpbmNsdWRpbmcgaGVhZGVyKVxuICAgIGlmIChzY29yZVRhYlJvd3MubGVuZ3RoID4gMSkge1xuICAgICAgLy8gT25seSB1cGRhdGUgaWYgdGhlcmUncyBkYXRhIGJleW9uZCB0aGUgaGVhZGVyXG4gICAgICBhd2FpdCB0aGlzLnNoZWV0cy5zcHJlYWRzaGVldHMudmFsdWVzLnVwZGF0ZSh7XG4gICAgICAgIHNwcmVhZHNoZWV0SWQ6IGNsYXNzU3ByZWFkc2hlZXRJZCxcbiAgICAgICAgcmFuZ2U6IGAke3Njb3JlU2hlZXROYW1lfSFBMWAsIC8vIFN0YXJ0IGZyb20gQTEgdG8gaW5jbHVkZSBoZWFkZXJcbiAgICAgICAgdmFsdWVJbnB1dE9wdGlvbjogXCJVU0VSX0VOVEVSRURcIixcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICB2YWx1ZXM6IHNjb3JlVGFiUm93cyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFVwZGF0ZWQgXCJTY29yZVwiIHRhYiBmb3IgJHtjbGFzc05hbWV9IHdpdGggJHtzY29yZVRhYlJvd3MubGVuZ3RoIC0gMX0gcHJvamVjdCBhdmVyYWdlIGVudHJpZXMuYClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYFske2NsYXNzTmFtZX1dIE5vIHByb2plY3QgYXZlcmFnZSBzY29yZXMgdG8gd3JpdGUgdG8gXCJTY29yZVwiIHRhYi5gKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFRvcFByb2plY3RzKGNsYXNzTmFtZTogc3RyaW5nKTogUHJvbWlzZTxcbiAgICBBcnJheTx7XG4gICAgICBwcm9qZWN0SWQ6IHN0cmluZ1xuICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgIHRoZW1lOiBzdHJpbmdcbiAgICAgIHByb2plY3RBdmdTY29yZTogbnVtYmVyXG4gICAgICBzdGFuZGFyZDogc3RyaW5nXG4gICAgICByYW5rOiBudW1iZXJcbiAgICAgIHN0dWRlbnROYW1lczogc3RyaW5nXG4gICAgfT5cbiAgPiB7XG4gICAgY29uc3QgY2xhc3NDb25maWcgPSB0aGlzLmdldENsYXNzQ29uZmlnKGNsYXNzTmFtZSlcbiAgICBpZiAoIWNsYXNzQ29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbmZpZ3VyYXRpb24gZm91bmQgZm9yIGNsYXNzOiAke2NsYXNzTmFtZX1gKVxuICAgIH1cblxuICAgIGNvbnN0IHNjb3JlU2hlZXROYW1lID0gXCJTY29yZVwiXG4gICAgY29uc3Qgc2NvcmVSYW5nZSA9IGAke3Njb3JlU2hlZXROYW1lfSFBOklgIC8vIFVwZGF0ZWQgcmFuZ2UgZm9yIG5ldyBTY29yZSB0YWIgY29sdW1uc1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldFNoZWV0RGF0YShjbGFzc0NvbmZpZy5pZCwgc2NvcmVSYW5nZSlcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBSZWFkIFwiU2NvcmVcIiB0YWIgZm9yIHRvcCBwcm9qZWN0cy4gUm93cyBmZXRjaGVkOiAke2RhdGEudmFsdWVzLmxlbmd0aH0uYClcblxuICAgICAgaWYgKCFkYXRhLnZhbHVlcyB8fCBkYXRhLnZhbHVlcy5sZW5ndGggPD0gMSkge1xuICAgICAgICAvLyBObyBkYXRhIG9yIG9ubHkgaGVhZGVyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBcIlNjb3JlXCIgdGFiIGlzIGVtcHR5IG9yIG9ubHkgaGFzIGhlYWRlci4gTm8gcHJvamVjdHMgdG8gcmFuay5gKVxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvamVjdHM6IEFycmF5PHtcbiAgICAgICAgcHJvamVjdElkOiBzdHJpbmdcbiAgICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgICAgdGhlbWU6IHN0cmluZ1xuICAgICAgICBwcm9qZWN0QXZnU2NvcmU6IG51bWJlclxuICAgICAgICBzdHVkZW50TmFtZXM6IHN0cmluZ1xuICAgICAgfT4gPSBbXVxuXG4gICAgICBkYXRhLnZhbHVlcy5zbGljZSgxKS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gcm93WzBdPy50cmltKCkgLy8gUHJvamVjdCBJRCBpcyBub3cgY29sdW1uIEFcbiAgICAgICAgY29uc3QgcHJvamVjdFRpdGxlID0gcm93WzFdPy50cmltKCkgLy8gUHJvamVjdCBUaXRsZSBpcyBub3cgY29sdW1uIEJcbiAgICAgICAgY29uc3QgdGhlbWUgPSByb3dbMl0/LnRyaW0oKSAvLyBUaGVtZSBpcyBub3cgY29sdW1uIENcbiAgICAgICAgY29uc3QgcHJvamVjdEF2Z1Njb3JlID0gTnVtYmVyLnBhcnNlRmxvYXQocm93WzddKSB8fCAwIC8vIFByb2plY3QgQXZlcmFnZSBTY29yZSBpcyBub3cgY29sdW1uIEggKGluZGV4IDcpXG4gICAgICAgIGNvbnN0IHN0dWRlbnROYW1lcyA9IHJvd1s4XT8udHJpbSgpIHx8IFwiXCIgLy8gU3R1ZGVudCBOYW1lcyBpcyBub3cgY29sdW1uIEkgKGluZGV4IDgpXG5cbiAgICAgICAgaWYgKHByb2plY3RJZCkge1xuICAgICAgICAgIHByb2plY3RzLnB1c2goe1xuICAgICAgICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQsXG4gICAgICAgICAgICBwcm9qZWN0VGl0bGU6IHByb2plY3RUaXRsZSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIHByb2plY3RBdmdTY29yZTogcHJvamVjdEF2Z1Njb3JlLFxuICAgICAgICAgICAgc3R1ZGVudE5hbWVzOiBzdHVkZW50TmFtZXMsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgWyR7Y2xhc3NOYW1lfV0gU2tpcHBpbmcgcm93IGluIFwiU2NvcmVcIiB0YWIgZm9yIHRvcCBwcm9qZWN0cyBkdWUgdG8gbWlzc2luZyBQcm9qZWN0IElEOiAke3Jvdy5qb2luKFwiLCBcIil9YCxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gUGFyc2VkICR7cHJvamVjdHMubGVuZ3RofSBwcm9qZWN0cyBmcm9tIFwiU2NvcmVcIiB0YWIuYClcblxuICAgICAgLy8gU29ydCBieSBwcm9qZWN0IGF2ZXJhZ2Ugc2NvcmUgZGVzY2VuZGluZ1xuICAgICAgcHJvamVjdHMuc29ydCgoYSwgYikgPT4gYi5wcm9qZWN0QXZnU2NvcmUgLSBhLnByb2plY3RBdmdTY29yZSlcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtjbGFzc05hbWV9XSBQcm9qZWN0cyBzb3J0ZWQgYnkgYXZlcmFnZSBzY29yZS5gKVxuXG4gICAgICBjb25zdCB0b3BQcm9qZWN0czogQXJyYXk8e1xuICAgICAgICBwcm9qZWN0SWQ6IHN0cmluZ1xuICAgICAgICBwcm9qZWN0VGl0bGU6IHN0cmluZ1xuICAgICAgICB0aGVtZTogc3RyaW5nXG4gICAgICAgIHByb2plY3RBdmdTY29yZTogbnVtYmVyXG4gICAgICAgIHN0YW5kYXJkOiBzdHJpbmdcbiAgICAgICAgcmFuazogbnVtYmVyXG4gICAgICAgIHN0dWRlbnROYW1lczogc3RyaW5nXG4gICAgICB9PiA9IFtdXG4gICAgICBsZXQgY3VycmVudFJhbmsgPSAxXG4gICAgICBsZXQgcHJvamVjdHNBZGRlZCA9IDBcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9qZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcm9qZWN0ID0gcHJvamVjdHNbaV1cbiAgICAgICAgaWYgKHByb2plY3RzQWRkZWQgPCAzKSB7XG4gICAgICAgICAgdG9wUHJvamVjdHMucHVzaCh7IC4uLnByb2plY3QsIHN0YW5kYXJkOiBjbGFzc05hbWUsIHJhbms6IGN1cnJlbnRSYW5rIH0pXG4gICAgICAgICAgcHJvamVjdHNBZGRlZCsrXG4gICAgICAgIH0gZWxzZSBpZiAocHJvamVjdC5wcm9qZWN0QXZnU2NvcmUgPT09IHRvcFByb2plY3RzW3RvcFByb2plY3RzLmxlbmd0aCAtIDFdLnByb2plY3RBdmdTY29yZSkge1xuICAgICAgICAgIC8vIEhhbmRsZSB0aWVzIGZvciAzcmQgcGxhY2VcbiAgICAgICAgICB0b3BQcm9qZWN0cy5wdXNoKHsgLi4ucHJvamVjdCwgc3RhbmRhcmQ6IGNsYXNzTmFtZSwgcmFuazogY3VycmVudFJhbmsgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhayAvLyBTdG9wIGFmdGVyIHRvcCAzIChhbmQgdGllcylcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgcmFuayBmb3IgbmV4dCBkaXN0aW5jdCBzY29yZSwgb25seSBpZiBjdXJyZW50IHByb2plY3QncyBzY29yZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbGFzdCBhZGRlZCBwcm9qZWN0J3Mgc2NvcmVcbiAgICAgICAgaWYgKGkgPCBwcm9qZWN0cy5sZW5ndGggLSAxICYmIHByb2plY3RzW2kgKyAxXS5wcm9qZWN0QXZnU2NvcmUgPCBwcm9qZWN0LnByb2plY3RBdmdTY29yZSkge1xuICAgICAgICAgIGN1cnJlbnRSYW5rID0gdG9wUHJvamVjdHMubGVuZ3RoICsgMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgWyR7Y2xhc3NOYW1lfV0gSWRlbnRpZmllZCAke3RvcFByb2plY3RzLmxlbmd0aH0gdG9wIHByb2plY3RzLmApXG4gICAgICByZXR1cm4gdG9wUHJvamVjdHNcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyB0b3AgcHJvamVjdHMgZm9yICR7Y2xhc3NOYW1lfTpgLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB0b3AgcHJvamVjdHMgZm9yICR7Y2xhc3NOYW1lfS5gKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUFkbWluU3VtbWFyeShcbiAgICBzdW1tYXJ5RGF0YTogQXJyYXk8e1xuICAgICAgc3RhbmRhcmQ6IHN0cmluZ1xuICAgICAgcmFuazogbnVtYmVyXG4gICAgICBwcm9qZWN0SWQ6IHN0cmluZ1xuICAgICAgcHJvamVjdFRpdGxlOiBzdHJpbmdcbiAgICAgIHRoZW1lOiBzdHJpbmdcbiAgICAgIHByb2plY3RBdmdTY29yZTogbnVtYmVyXG4gICAgICBzdHVkZW50TmFtZXM6IHN0cmluZ1xuICAgIH0+LFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBhZG1pbk1hc3RlclNoZWV0SWQgPSBTUFJFQURTSEVFVF9DT05GSUcuQURNSU5fTUFTVEVSLmlkXG4gICAgY29uc3Qgc3VtbWFyeVNoZWV0TmFtZSA9IFwiU3VtbWFyeVwiXG4gICAgY29uc3Qgc3VtbWFyeUhlYWRlciA9IFtcbiAgICAgIFwiU3RhbmRhcmRcIixcbiAgICAgIFwiUmFua1wiLFxuICAgICAgXCJQcm9qZWN0IElEXCIsXG4gICAgICBcIlByb2plY3QgVGl0bGVcIixcbiAgICAgIFwiVGhlbWVcIixcbiAgICAgIFwiUHJvamVjdCBBdmcgU2NvcmVcIixcbiAgICAgIFwiU3R1ZGVudCBOYW1lc1wiLFxuICAgIF0gLy8gQWRkZWQgU3R1ZGVudCBOYW1lc1xuXG4gICAgYXdhaXQgdGhpcy5lbnN1cmVTaGVldEV4aXN0cyhhZG1pbk1hc3RlclNoZWV0SWQsIHN1bW1hcnlTaGVldE5hbWUsIHN1bW1hcnlIZWFkZXIpXG5cbiAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50IGluIFN1bW1hcnkgdGFiIChleGNsdWRpbmcgaGVhZGVyKVxuICAgIGF3YWl0IHRoaXMuc2hlZXRzLnNwcmVhZHNoZWV0cy52YWx1ZXMuY2xlYXIoe1xuICAgICAgc3ByZWFkc2hlZXRJZDogYWRtaW5NYXN0ZXJTaGVldElkLFxuICAgICAgcmFuZ2U6IGAke3N1bW1hcnlTaGVldE5hbWV9IUEyOkdgLCAvLyBVcGRhdGVkIHJhbmdlIGZvciBjbGVhcmluZyAoQS1HIGZvciA3IGNvbHVtbnMpXG4gICAgfSlcblxuICAgIGlmIChzdW1tYXJ5RGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiTm8gc3VtbWFyeSBkYXRhIHRvIGFwcGVuZCB0byBBZG1pbiBNYXN0ZXIgU2hlZXQuXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByb3dzVG9BcHBlbmQgPSBzdW1tYXJ5RGF0YS5tYXAoKGRhdGEpID0+IFtcbiAgICAgIGRhdGEuc3RhbmRhcmQsXG4gICAgICBkYXRhLnJhbmsudG9TdHJpbmcoKSxcbiAgICAgIGRhdGEucHJvamVjdElkLFxuICAgICAgZGF0YS5wcm9qZWN0VGl0bGUsXG4gICAgICBkYXRhLnRoZW1lLFxuICAgICAgZGF0YS5wcm9qZWN0QXZnU2NvcmUudG9GaXhlZCgyKSxcbiAgICAgIGRhdGEuc3R1ZGVudE5hbWVzLCAvLyBJbmNsdWRlIHN0dWRlbnQgbmFtZXNcbiAgICBdKVxuXG4gICAgYXdhaXQgdGhpcy5zaGVldHMuc3ByZWFkc2hlZXRzLnZhbHVlcy5hcHBlbmQoe1xuICAgICAgc3ByZWFkc2hlZXRJZDogYWRtaW5NYXN0ZXJTaGVldElkLFxuICAgICAgcmFuZ2U6IGAke3N1bW1hcnlTaGVldE5hbWV9IUEyYCwgLy8gQXBwZW5kIHN0YXJ0aW5nIGZyb20gQTIgKGFmdGVyIGhlYWRlcilcbiAgICAgIHZhbHVlSW5wdXRPcHRpb246IFwiVVNFUl9FTlRFUkVEXCIsXG4gICAgICByZXNvdXJjZToge1xuICAgICAgICB2YWx1ZXM6IHJvd3NUb0FwcGVuZCxcbiAgICAgIH0sXG4gICAgfSlcbiAgICBjb25zb2xlLmxvZyhg4pyFIEFwcGVuZGVkICR7cm93c1RvQXBwZW5kLmxlbmd0aH0gcm93cyB0byBcIlN1bW1hcnlcIiB0YWIgaW4gQWRtaW4gTWFzdGVyIFNoZWV0LmApXG4gIH1cblxuICBnZXRDbGFzc0NvbmZpZyhjbGFzc05hbWU6IHN0cmluZyk6IENsYXNzQ29uZmlnIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gU1BSRUFEU0hFRVRfQ09ORklHLkNMQVNTRVNbY2xhc3NOYW1lIGFzIGtleW9mIHR5cGVvZiBTUFJFQURTSEVFVF9DT05GSUcuQ0xBU1NFU11cbiAgfVxuXG4gIGdldFNwcmVhZHNoZWV0SWQoY2xhc3NOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNsYXNzQ29uZmlnID0gdGhpcy5nZXRDbGFzc0NvbmZpZyhjbGFzc05hbWUpXG4gICAgcmV0dXJuIGNsYXNzQ29uZmlnPy5pZCB8fCBcIlwiXG4gIH1cblxuICAvLyBOZXcgZnVuY3Rpb24gdG8gdXBkYXRlIGEgY2xhc3MncyBzcHJlYWRzaGVldCBJRFxuICB1cGRhdGVDbGFzc1NwcmVhZHNoZWV0SWQoY2xhc3NOYW1lOiBzdHJpbmcsIG5ld0lkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoU1BSRUFEU0hFRVRfQ09ORklHLkNMQVNTRVNbY2xhc3NOYW1lIGFzIGtleW9mIHR5cGVvZiBTUFJFQURTSEVFVF9DT05GSUcuQ0xBU1NFU10pIHtcbiAgICAgIC8vIFVwZGF0ZSBpbi1tZW1vcnkgY29uZmlnXG4gICAgICBTUFJFQURTSEVFVF9DT05GSUcgPSB7XG4gICAgICAgIC4uLlNQUkVBRFNIRUVUX0NPTkZJRyxcbiAgICAgICAgQ0xBU1NFUzoge1xuICAgICAgICAgIC4uLlNQUkVBRFNIRUVUX0NPTkZJRy5DTEFTU0VTLFxuICAgICAgICAgIFtjbGFzc05hbWVdOiB7XG4gICAgICAgICAgICAuLi5TUFJFQURTSEVFVF9DT05GSUcuQ0xBU1NFU1tjbGFzc05hbWUgYXMga2V5b2YgdHlwZW9mIFNQUkVBRFNIRUVUX0NPTkZJRy5DTEFTU0VTXSxcbiAgICAgICAgICAgIGlkOiBuZXdJZCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfVxuICAgICAgLy8gUGVyc2lzdCB0byBmaWxlXG4gICAgICBjb25zdCBpZHMgPSBsb2FkQ2xhc3NTaGVldElkcygpXG4gICAgICBpZHNbY2xhc3NOYW1lXSA9IG5ld0lkXG4gICAgICBzYXZlQ2xhc3NTaGVldElkcyhpZHMpXG4gICAgICBjb25zb2xlLmxvZyhgW0JhY2tlbmQgU2ltdWxhdGlvbl0gVXBkYXRlZCBTUFJFQURTSEVFVF9DT05GSUcgZm9yICR7Y2xhc3NOYW1lfSB0byBJRDogJHtuZXdJZH0gYW5kIHBlcnNpc3RlZCB0byBmaWxlYClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBbQmFja2VuZCBTaW11bGF0aW9uXSBDbGFzcyAke2NsYXNzTmFtZX0gbm90IGZvdW5kIGluIFNQUkVBRFNIRUVUX0NPTkZJRy5gKVxuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgZ29vZ2xlU2hlZXRzU2VydmljZSA9IG5ldyBHb29nbGVTaGVldHNTZXJ2aWNlKClcbiJdLCJuYW1lcyI6WyJHb29nbGVBdXRoIiwiZ29vZ2xlIiwiZnMiLCJwYXRoIiwib3MiLCJDTEFTU19TSEVFVF9JRFNfUEFUSCIsInJlc29sdmUiLCJwcm9jZXNzIiwiY3dkIiwibG9hZENsYXNzU2hlZXRJZHMiLCJyYXciLCJyZWFkRmlsZVN5bmMiLCJKU09OIiwicGFyc2UiLCJzYXZlQ2xhc3NTaGVldElkcyIsImlkcyIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJHT09HTEVfU0hFRVRTX0NPTkZJRyIsInNjb3BlcyIsInBlcnNpc3RlZElkcyIsIlNQUkVBRFNIRUVUX0NPTkZJRyIsIkNSRURFTlRJQUxTIiwiaWQiLCJlbnYiLCJDUkVERU5USUFMU19TUFJFQURTSEVFVF9JRCIsInJhbmdlIiwiQURNSU5fTUFTVEVSIiwiQURNSU5fTUFTVEVSX1NQUkVBRFNIRUVUX0lEIiwiQ0xBU1NFUyIsImJhc2VTaGVldCIsIkdvb2dsZVNoZWV0c1NlcnZpY2UiLCJjb25zdHJ1Y3RvciIsImJhc2U2NEtleSIsIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfS0VZX0JBU0U2NCIsIkVycm9yIiwia2V5RGF0YSIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsInRtcERpciIsInRtcGRpciIsImtleVBhdGgiLCJqb2luIiwiYXV0aCIsImtleUZpbGUiLCJzaGVldHMiLCJ2ZXJzaW9uIiwiY29uc29sZSIsImxvZyIsImVyciIsImVycm9yIiwiZ2V0U2hlZXREYXRhIiwic3ByZWFkc2hlZXRJZCIsInJlc3BvbnNlIiwic3ByZWFkc2hlZXRzIiwidmFsdWVzIiwiZ2V0IiwiZGF0YSIsImJhdGNoR2V0U2hlZXREYXRhIiwicmFuZ2VzIiwiYmF0Y2hHZXQiLCJyZXN1bHQiLCJ2YWx1ZVJhbmdlcyIsImZvckVhY2giLCJ2YWx1ZVJhbmdlIiwiZ2V0Q3JlZGVudGlhbHMiLCJsZW5ndGgiLCJzbGljZSIsIm1hcCIsInJvdyIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJyb2xlIiwiZmlsdGVyIiwiY3JlZCIsImdldFByb2plY3RJZHMiLCJjbGFzc05hbWUiLCJjbGFzc0NvbmZpZyIsImdldENsYXNzQ29uZmlnIiwicHJvamVjdElkcyIsInRyaW0iLCJTZXQiLCJnZXRTdHVkZW50c0J5UHJvamVjdElkIiwicHJvamVjdElkIiwic3R1ZGVudHMiLCJzbm8iLCJzdHVkZW50TmFtZSIsImdyYWRlIiwicHJvamVjdFRpdGxlIiwidGhlbWUiLCJzdHVkZW50IiwiZ2V0SnVkZ2VTY29yZXMiLCJqdWRnZU5hbWUiLCJqdWRnZVNoZWV0TmFtZSIsImp1ZGdlUmFuZ2UiLCJzY29yZXMiLCJjcmVhdGl2aXR5IiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsInNjaWVudGlmaWNUaG91Z2h0IiwidGVjaG5pY2FsU2tpbGxzIiwicHJlc2VudGF0aW9uIiwic3RhdHVzIiwidGhlbWVGaXQiLCJzY29yZSIsInNhdmVKdWRnZVNjb3JlcyIsImp1ZGdlSGVhZGVyUm93IiwiZW5zdXJlU2hlZXRFeGlzdHMiLCJuZXdSb3dzIiwiYXBwZW5kIiwidmFsdWVJbnB1dE9wdGlvbiIsInJlc291cmNlIiwiZ2V0RXhpc3RpbmdKdWRnZURhdGEiLCJzaGVldE5hbWUiLCJoZWFkZXJSb3ciLCJzcHJlYWRzaGVldCIsImZpZWxkcyIsInNoZWV0RXhpc3RzIiwic29tZSIsInNoZWV0IiwicHJvcGVydGllcyIsInRpdGxlIiwiYmF0Y2hVcGRhdGUiLCJyZXF1ZXN0cyIsImFkZFNoZWV0IiwiZ2V0QWxsU2hlZXRUaXRsZXMiLCJnZXRBbGxKdWRnZVNoZWV0TmFtZXMiLCJjbGFzc1NwcmVhZHNoZWV0SWQiLCJhbGxTaGVldFRpdGxlcyIsInN0YXJ0c1dpdGgiLCJnZXRQcm9qZWN0RGV0YWlsc01hcCIsInByb2plY3RNYXAiLCJNYXAiLCJoYXMiLCJzZXQiLCJzdHVkZW50TmFtZXMiLCJhZGQiLCJwcm9jZXNzQ2xhc3NTY29yZXMiLCJwcm9qZWN0RGV0YWlsc01hcCIsInNpemUiLCJqdWRnZVNoZWV0TmFtZXMiLCJsYXRlc3RQcm9qZWN0U2NvcmVzQnlKdWRnZSIsImp1ZGdlUmFuZ2VzIiwiYmF0Y2hEYXRhIiwicmVwbGFjZSIsInNjb3Jlc0Zvckp1ZGdlIiwicElkIiwicHJvamVjdEFnZ3JlZ2F0ZWRTY29yZXMiLCJkZXRhaWxzIiwiZW50cmllcyIsImNyZWF0aXZpdHlTdW0iLCJzY2llbnRpZmljVGhvdWdodFN1bSIsInRlY2huaWNhbFNraWxsc1N1bSIsInByZXNlbnRhdGlvblN1bSIsImp1ZGdlQ291bnQiLCJhYnNlbnRDb3VudCIsIkFycmF5Iiwic29ydCIsImp1ZGdlU2NvcmVzTWFwIiwia2V5cyIsImZpcnN0U2NvcmUiLCJ3YXJuIiwic2NvcmVUYWJSb3dzIiwicHVzaCIsInByb2plY3RzRm9yU2NvcmVUYWIiLCJwcm9qZWN0RGF0YSIsImF2Z0NyZWF0aXZpdHkiLCJhdmdTY2llbnRpZmljVGhvdWdodCIsImF2Z1RlY2huaWNhbFNraWxscyIsImF2Z1ByZXNlbnRhdGlvbiIsInByb2plY3RBdmdTY29yZSIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsInByb2plY3QiLCJ0b0ZpeGVkIiwic2NvcmVTaGVldE5hbWUiLCJjbGVhciIsInVwZGF0ZSIsImdldFRvcFByb2plY3RzIiwic2NvcmVSYW5nZSIsInByb2plY3RzIiwidG9wUHJvamVjdHMiLCJjdXJyZW50UmFuayIsInByb2plY3RzQWRkZWQiLCJpIiwic3RhbmRhcmQiLCJyYW5rIiwidXBkYXRlQWRtaW5TdW1tYXJ5Iiwic3VtbWFyeURhdGEiLCJhZG1pbk1hc3RlclNoZWV0SWQiLCJzdW1tYXJ5U2hlZXROYW1lIiwic3VtbWFyeUhlYWRlciIsInJvd3NUb0FwcGVuZCIsImdldFNwcmVhZHNoZWV0SWQiLCJ1cGRhdGVDbGFzc1NwcmVhZHNoZWV0SWQiLCJuZXdJZCIsImdvb2dsZVNoZWV0c1NlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/google-sheets.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/googleapis","vendor-chunks/google-auth-library","vendor-chunks/bignumber.js","vendor-chunks/googleapis-common","vendor-chunks/gaxios","vendor-chunks/qs","vendor-chunks/json-bigint","vendor-chunks/gtoken","vendor-chunks/google-logging-utils","vendor-chunks/gcp-metadata","vendor-chunks/object-inspect","vendor-chunks/get-intrinsic","vendor-chunks/jws","vendor-chunks/jwa","vendor-chunks/url-template","vendor-chunks/ecdsa-sig-formatter","vendor-chunks/base64-js","vendor-chunks/side-channel-list","vendor-chunks/extend","vendor-chunks/side-channel-weakmap","vendor-chunks/has-symbols","vendor-chunks/function-bind","vendor-chunks/side-channel-map","vendor-chunks/safe-buffer","vendor-chunks/side-channel","vendor-chunks/get-proto","vendor-chunks/call-bind-apply-helpers","vendor-chunks/buffer-equal-constant-time","vendor-chunks/dunder-proto","vendor-chunks/math-intrinsics","vendor-chunks/call-bound","vendor-chunks/es-errors","vendor-chunks/gopd","vendor-chunks/es-define-property","vendor-chunks/hasown","vendor-chunks/es-object-atoms"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fauth%2Froute&page=%2Fapi%2Fauth%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fauth%2Froute.ts&appDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Carunm%5CDownloads%5Cjudge-dashboard-nextjs-v29-judgePanelv1&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();